{"version":"1","records":[{"hierarchy":{"lvl1":"FAQ"},"type":"lvl1","url":"/faq-1","position":0},{"hierarchy":{"lvl1":"FAQ"},"content":"\n\nThis page answers frequently asked questions about the Open Catalyst Project and FAIRChem models for catalysis applications.\n\nGeneral\n\nBasic concepts and terminology\n\nML Questions\n\nModel details and predictions\n\nCatalysis\n\nUsing predictions for research\n\nComputational\n\nTechnical details and DFT","type":"content","url":"/faq-1","position":1},{"hierarchy":{"lvl1":"FAQ","lvl2":"General"},"type":"lvl2","url":"/faq-1#general","position":2},{"hierarchy":{"lvl1":"FAQ","lvl2":"General"},"content":"What is a catalyst? What is a bulk? What is a surface? What is an adsorbate?\n\nCatalyst: A catalyst is a material that makes a chemical reaction happen faster without itself being consumed. The catalysts shown here are one specific type of catalyst (heterogeneous) catalyst where the reactions happen as molecules interact with a catalyst surface.\n\nBulk: An inorganic crystal structure that will form the base structure of our catalyst surface and from which we will identify possible surfaces.\n\nSurface: A surface formed from a bulk crystal structure by cutting along a specific plane (specified by the Miller index)\n\nAdsorbate: The small organic molecule interacting with the catalyst surface that is adsorbed on the catalyst surface.\n\nWhat are these models and simulations useful for?\n\nSimulations like these are used to design materials (catalysts) that make chemical transportations more efficient. Example uses of catalysis in day-to-day life:\n\nThe catalytic converter in your car is a special catalyst that breaks down harmful automotive exhaust to more benign species\n\nCatalysts are responsible for taking nitrogen in the air and making ammonia for fertilizer and agricultural use. We couldn’t feed the world’s population without catalysts!\n\nEnergy can be stored as renewable hydrogen produced by splitting water over electrocatalysts\n\nFuel cell vehicles rely on catalysts to combine hydrogen and oxygen into water while producing electricity\n\nCarbon capture systems can use catalysts to turn waste or captured CO2 into useful chemicals\n\nThese simulations can help us design cheaper, more efficient, and more durable catalysts. These simulations can also help design catalysts for new chemical reactions that are currently difficult or infeasible to drive at scale. These simulations could also be used to design materials that are resistant to surface oxidation or corrosion.\n\nWhy does Meta care about catalysis?\n\nCatalysis is important for climate/renewable energy and achieving net-zero carbon emissions in the near future. Meta has a number of decarbonization goals that rely on societal solutions for renewable energy and energy storage. Catalysis is key to many of these technologies, and helping the community develop more efficient processes will help us reach those goals!\n\nMeta Fundamental AI Research (FAIR) is interested in pushing forward the state-of-the-art in many applications of AI/ML to the world, including vision, language, robotics, etc. Applications of AI in science and chemistry is one such exciting area of research.\n\nThe core models powering this API are from a class of models known as \n\ngraph neural networks (GNNs). GNNs are an exciting area of research in AI.\n\nAre there any rate limits on incoming requests?\n\nRate limits may apply when using the OCP API. Check the \n\nAPI documentation for current limits.\n\nHow do I know which surface/adsorbate/etc to pick when running this?\n\nIf you are new to catalysis:\n\nTry selecting some simple (one element) or complicated (multiple elements) bulk structures.\n\nTry selecting some small and larger adsorbates to see how interesting the structures may be\n\nWatch some of the relaxations and see how subtle some of these relaxations can be!\n\nDevelop some intuition for how the energies depend on different surfaces and bulk structures\n\nIf you have ideas on how to build better ML models to predict the final energies or relaxation pathways, you should visit \n\nopencatalystproject​.org! Hopefully this website gives you an idea of the challenge here and what the data will look like.\n\nIf you are an experienced catalyst researcher:\n\nYou might want to see how common descriptors for your favorite reactions (like *CO or *CH2) might vary across different surfaces or compositions\n\nIf you are interested in reaction pathways for a single surface, you might want to predict properties for several adsorbates on the same surface\n\nLet us know if you have other suggestions here! We’d love to hear what you’re using this for!\n\nHopefully this gives you an idea of what the state of the art is for reactive catalyst potentials! The world is your oyster!\n\nWhat are the black lines and boxes in all of the visualizations?\n\nThe systems considered here are periodic, i.e. they repeat over and over infinitely in the X/Y direction to approximate a very large catalyst surface. The black lines show the edges of the repeating unit cell, or \n\nperiodic boundary conditions.\n\nWhy do only some of the atoms move?\n\nThese structures are an approximation of small molecule intermediates interacting with a much larger nanoparticle surface. Even small nanoparticle catalysts will have many layers to the surface. It is very common to freeze the bottom few layers of the catalyst surface for these simulations so that they do not move and are more similar to the actual much deeper structure. You will notice mostly the small molecule moving during the relaxation, and you may also notice small movements of the top layer of surface atoms as they compensate for the adsorbate.\n\nWhy is the adsorbate broken up / appearing on two sides of the cell?\n\nWe are working to fix this!","type":"content","url":"/faq-1#general","position":3},{"hierarchy":{"lvl1":"FAQ","lvl2":"ML Questions"},"type":"lvl2","url":"/faq-1#ml-questions","position":4},{"hierarchy":{"lvl1":"FAQ","lvl2":"ML Questions"},"content":"What sort of models are used to generate these predictions?\n\nThe state-of-the-art in ML for chemistry is moving extremely quickly, and we track this exciting progress through the open leaderboards available at \n\nhttps://​opencatalystproject​.org​/leaderboard​.html. The models that are currently available are openly available models that are near the top of the leaderboard and have a desirable compute/accuracy trade-off. We are excited to see developments in many ML model types, but the ones that have worked best for large catalyst datasets tend to be message passing or graph neural networks.\n\nHow big are these models?\n\nThe models used here have >100 million free fitted parameters that are fit to the OC20 and OC22 datasets. These datasets have >100 million structures, each with O(30) energy/forces, so the number of targets available to fit is quite massive (in the context of work in AI for science).\n\nCan I run these models on my own computer? How long would it take?\n\nYes! All of the models and pre-trained checkpoints are open source and freely available at \n\nhttps://​fair​-chem​.github​.io/; models/datasets have varying licenses. They can run on CPUs with ~16Gb of RAM, and CUDA-compatible GPUs with >16Gb of memory. Each energy/force call usually takes O(1s) on a cpu core, and O(50ms) on a GPU, averaged over a reasonable batch size. Of course, this depends on your precise setup and your mileage may vary.\n\nWhat about the CO2 emissions associated with training and serving ML models?\n\nVery relevant question! Greenhouse gas emissions for training and using large ML models like those used on this website are an active research area. This includes how to measure them, and how to reduce them using methods like inference accelerators or more efficient training strategies. In this case, the models that we are replacing are even more resource intensive -- the density function theory (DFT) calculations that would typically be required for simulations like those shown often require 1000s of core-hours to analyze many possible configurations. The emissions associated with using the ML models here are a small fraction of what would be emitted while running traditional DFT simulations. We also hope that we will see community progress in developing more energy-efficient models with similar (or better) accuracies to the models shown here!\n\nI ran a prediction but the structures/energies look strange to me. What should I do?\n\nPlease let us know by posting as a \n\ngithub issue with your inputs, results page link, and structure so we can look into the problem on our end.\n\nAlternatively, a few things to try:\n\nFirst, try a couple of the ML models available on this website for the same surface/adsorbate and see if the results differ. This gives you an idea of whether it is specific to a model, or something about the surface/adsorbate that leads to problems.\n\nSecond, you can download the structures and try other ML models from \n\nhttps://​fair​-chem​.github​.io/ to see if the problems are consistent.\n\nFinally, if you have access to VASP you can try running the relaxations yourself to verify the results.\n\nDo you have any estimates on how much I should trust these predictions? Why aren’t there error bars?\n\nUncertainty quantification for large GNN models like those used here is a very active research area, with many different uncertainty calibration metrics and varying additional compute costs for the prediction.\n\nYou can get some idea of average MAE from the \n\nOCP leaderboard. The models used here have MAEs across many different catalyst/adsorbate systems of ~0.3 eV. For metals and smaller adsorbates, the residuals tend to be smaller.\n\nDeciding which configuration corresponds to the minimum energy tends to be more robust to residuals, so it is likely that the identified structure is identified. Recent results on validation datasets suggest that approximately 50% of the time the energy identified in this process is within 0.05 eV of the DFT-computed minimum (see the \n\nAdsorbML paper)\n\nWe are investigating efficient ways to add uncertainty to these predictions; more updates coming soon!","type":"content","url":"/faq-1#ml-questions","position":5},{"hierarchy":{"lvl1":"FAQ","lvl2":"Catalysis Questions"},"type":"lvl2","url":"/faq-1#catalysis-questions","position":6},{"hierarchy":{"lvl1":"FAQ","lvl2":"Catalysis Questions"},"content":"All I know is the rough composition of the material I’m interested in. How do I select a bulk structure or surface in the website?\n\nGenerally, materials with lower formation energies (or smaller distances to the lower hull of the phase diagram) are more likely to be stable or metastable. The Materials Project and other databases have a bunch of great tools to help predict bulk stability (including under reaction conditions!).\n\nFor surface structure, you have a few options:\n\nYou could see how your properties of interest vary across similar compositions or surfaces to get a feel for how surface structure or composition might impact reactivity\n\nYou could use DFT or other ML models to predict surface stability to help you select a specific surface\n\nYou could find a computational chemistry catalyst friend/collaborator to dig into the surface structure!\n\nHow do I use these predictions to understand or predict the activity/selectivity of a catalyst?\n\nThe catalyst predictions exposed on this service can be used in many ways; we’ve tried to highlight a few potential use cases in the \n\nexamples and tutorials section. A few possible use cases:\n\nIf you or others have already identified ideal adsorption energies for a particular chemistry, you can use this service to compare the adsorption energies across several facets on the catalyst, or compare different catalyst surfaces.\n\nThe adsorption energy on different sites of a particular surface may help you identify which surface is responsible for catalytic activity.\n\nIf you know the catalyst surface you are interested in, you could use these predictions to construct reaction energies and a free energy diagram to compare different reaction pathways. You could also do this using your favorite microkinetic modeling package!\n\nYou could use these calculations as a starting point for vibration calculations (e.g. IR spectra) or reaction activation barriers (transition states),\n\nIf you find these useful for your work, we’d love to highlight some additional use cases/stories, so please reach out via \n\nGitHub discussions!\n\nStability/durability is important for my application; can I predict that?\n\nYes, this is something you can predict, but probably using different ML models than the ones trained here. A few great options:\n\nThe formation energy, energy above the phase diagram hull in Materials Project and similar databases are popular descriptors for whether a material is stable, metastable, or unstable. Reaction conditions can be included via techniques like Pourbaix diagrams.\n\nThere are many machine learning models available to predict stability for arbitrary materials.\n\nThe stability of more complex catalyst interfaces is a very interesting research area, especially as some materials are self-passivating and stable even under conditions where they decompose.\n\nI made a catalyst with a different crystal structure than is present in the drop-down list; what should I do?\n\nIf you know the crystal structure of composition of your catalyst but it’s not present in the drop-down list, it’s probably because the structure is either not in the Materials Project, or it’s predicted to be unstable by more than 0.1 eV/atom, or our calculations failed when we relaxed the inputs with DFT/RPBE.\n\nYou can use the new \n\nOpen Catalyst API to enumerate surfaces and perform the adsorbate placement using python or your web browser. Make sure you have an RPBE-relaxed structure before starting this process!\n\nYou can also do these by hand using the \n\nOpen Catalyst Project tools\n\nI think my material is more complex than the surfaces shown here (surface segregation, additional terminations, etc); what should I do?\n\nThe models used here may be able to predict the adsorption on more complex surfaces (for example, solid solutions, single atom alloys, segregated materials, etc), but the models have not been validated in these situations. We recommend downloading and using the pre-trained models on your own machine using the ASE calculator interface and using them to predict the adsorption energy (\n\nsee the adsorption energies tutorial). If you find the models work well for your application, we’d love to hear from you! And if they don’t, feel free to reach out via a \n\ngithub issue.\n\nWe’re considering allowing predictions on more diverse surfaces, but there are some computational nuances that make doing so a bit difficult. Feel free to reach out via \n\nGitHub discussions if you have a specific use case or are interested in getting updates!\n\nI’m interested in electrochemistry, but I don’t see any solvent effects or water layer; what should I do?\n\nIt’s very common in the electrocatalyst modeling community to relate gas-phase adsorption energies (like those shown here) to adsorption energies in solvent by incorporating a per-adsorbate solvent correction to the adsorption energy. This correction tends to be largest for adsorbates that can hydrogen bond with a water layer (like *OH), or adsorbate that have a strong dipole moment that can be screened with a water layer. This approximation is helpful in screening millions of possible catalyst surfaces, especially because the structure of the water layers on each surface is difficult to predict.\nOf course, by not including a solvent the models cannot help predict the impact of the solvent on the catalyst activity/selectivity, the role of cation/anion additives in the solvent, or interesting enhancements/disturbances to proton transport, or reactions from the solvent layer to surface adsorbates. These are all exciting research areas!\n\nNote\n\nEven using DFT, full fidelity detailed modeling of the solvent/catalyst interface in electrochemical conditions is an active research challenge!\n:::{admonition} I'm interested in trying this across many different surfaces or discover new catalysts but it's hard to select them all on the website; how should I try this?\n:class: dropdown\n\nThis website is meant to acquaint you with the state-of-the-art in accelerated catalyst property prediction models, and demonstrate the capabilities of models trained on the Open Catalyst Project datasets. If you want to use these models for high-throughput simulations or programmatically across several materials, you are welcome to:\n\n* Use Open Catalyst Project API (python or REST); note that this may be rate-limited\n* Download and use the Open Catalyst Project models and toolkits (all open source and permissively licensed!) to predict properties on many systems\n\nIf either of these are unclear or you have trouble using them, please direct questions to the github repo!","type":"content","url":"/faq-1#catalysis-questions","position":7},{"hierarchy":{"lvl1":"FAQ","lvl2":"Computational Catalysis Questions"},"type":"lvl2","url":"/faq-1#computational-catalysis-questions","position":8},{"hierarchy":{"lvl1":"FAQ","lvl2":"Computational Catalysis Questions"},"content":"What are the caveats of using these calculations?\n\nAs the statistician George Box once said, “All models are wrong, but some are useful!”\n\nSimulations like these are extremely common in the catalysis community to develop intuition into limitations of specific catalysts, propose new catalyst modifications or active sites, or discover new catalysts with interesting reactivity/selectivity. However, there are a number of caveats to be aware of:\n\nThese simulations are based on Density Functional Theory, a quantum mechanical simulation technique that offers reasonably predictive properties, but is nonetheless an approximation.\n\nThe DFT settings in the training dataset were chosen for a reasonable combination of speed/accuracy trade-off (kpoints, energy cutoffs, pseudopotential, etc).\n\nAll simulations neglected spin polarization (magnetic moments), which often have a small impact on adsorption energies but may be important. Of course, this only applies to spin-polarized elements like Ni, Fe, etc.\n\nThe simulations neglect long-range dispersion interactions, which are more important for large adsorbates than small ones.\n\nThese simulations approximate a complex catalyst surface with a very small and defect-free representation of an active site. Real catalysts may undergo restructuring or segregation under reaction conditions. Solid solution materials are also not included in databases like the Materials Project so are not shown here.\n\nThese simulations do not include solvent interactions, which may be important for your application. However, adsorption energies with and without solvent are often strongly correlated, so this doesn’t mean the calculations can’t be used for catalysis in condensed phases!\n\nThe reaction energies here are enthalpies, and do not include entropic contributions to stability (as they would be if they were the Gibbs free energy).\n\nThe ML models shown are imperfect and rapidly developing. The mean absolute error for the OC20 validation datasets is ~0.3-4 eV (less for metals and small molecules, more for complex catalysts like nitrides or larger adsorbates) (see the \n\nOCP leaderboard). The best adsorption site according to DFT is one of the best 5 predicted by these methods about 90% of the time.\n\nThese caveats are all extremely common in computational catalysis, and are provided here not to scare you but to remind you of possible limitations. If you aren’t sure whether these caveats are important for your intended use case, talk to your favorite computational catalyst researcher friend, or post your questions on the discussion board!\n\nI’m interested in a different reaction energy than the ones listed for a particular adsorbate; what do I do?\n\nThe reaction energies listed on this website are helpful because they all use a single set of reference gas phase species. This makes it easy to mix and match reaction energies to make new reaction energies, perhaps using gas phase species.\n\nFor example, adsorption of *NH3 on a surface would show up on this site as:\n* + 1/2 N2(g) + 3/2 H2(g) -> *NH3\n\nIf you wanted to know the adsorption energy of *NH3 relative to gas phase NH3, we could add this reaction energy with the (known) gas phase formation energy of ammonia:\n* + 1/2 N2(g) + 3/2 H2(g) -> *NH3 (E1)\nNH3(g) -> 1/2 N2(g) + 3/2 H2(g) (E2)\n\nTo yield:\n* + NH3(g) -> *NH3 (E1 + E2)\n\nSimilar approaches can be used to prepare surface reaction energies.\n\nWhy are the reaction energies enthalpies and not free energies? How should I calculate dG?\n\nCalculating the free energy of reaction requires several additional steps in a typical computational catalysis workflow:\n\nVibrational calculations to obtain vibrational modes and energies\n\nCalculation of the zero point energy (ZPE) and entropic contributions (assuming harmonic or anharmonic vibrational modes)\n\n(optional) identification of adsorbate-specific solvent or frequency-dependent corrections\n\nCalculating the Gibbs free energy at a specific temperature\n\nWe expect that the ML models used here can also help predict vibrational modes and are working to validate these approaches. As a placeholder, we have provided rough estimates for Gibbs free energy of reaction for the reactions here by calculating corrections for some representative simple metal surfaces. These free energy corrections are usually fairly constant across different catalyst surfaces, but can change significantly if the binding configuration (mono- or bi-dentate) or active site changes.\n\nWhere did the list of bulk materials come from? How did you select them from the Materials Project?\n\nThe bulk materials for this demo were prepared by:\n\nSelecting all materials from the Materials Project using catalyst elements seen in OC20\n\nFiltering the materials to negative formation energies and energies above the phase diagram hull less than 0.1 eV/atom\n\nIsotropic relaxations of the structures with DFT and the RPBE functional, which had a small failure rate.\n\nWe’re interested in adding the ability to upload custom bulk structures, but making sure the materials are not strained from the perspective of the RPBE functional is a bit nuanced and it’s hard to know how well our models will work on very different structures. If you’re interested in this feature, reach out via a \n\ngithub issue!\n\nWhere did the list of adsorbates come from? How did you select them?\n\nThese adsorbates were the original 82 adsorbates used to construct OC20, which allows us to have some intuition and statistics on how well the models may work. We’re considering allowing users to upload custom adsorbate structures. If you’re interested in this feature, reach out as a \n\ngithub issue!\n\nMy favorite catalyst composition/surface/adsorbate is missing. What should I do?\n\nThis website is meant to acquaint you with the state-of-the-art in accelerated catalyst property prediction models, and demonstrate the capabilities of models trained on the Open Catalyst Project datasets. If you want to use these models for high-throughput simulations or programmatically across several materials, you are welcome to:\n\nUse Open Catalyst Project API (python or REST); note that this may be rate-limited\n\nDownload and use the Open Catalyst Project models and toolkits (all open source and permissively licensed!) to predict properties on many systems\n\nIf either of these are unclear or you have trouble using them, please direct questions to the \n\nGitHub discussions!\n\nThese are all low coverage energies, but I’m interested in adsorption energies at high coverage. Can we do that too?\n\nThis is a very exciting and interesting research area! We expect that OCP models like those shown here will be capable of predicting energies at higher coverages, but this is an ongoing research area. This is especially interesting for adsorbates with long-range interactions like *CO, which has a strong dipole moment. More training data or more sophisticated models may be needed to accurately resolve high-coverage adsorption energies.\n\nReaction energies are great, but I’m interested in reaction kinetics (activation energies). Can I use OCP models for kinetics?\n\nThis is a very exciting and interesting research area! We expect that OCP models like those shown here will be capable of predicting activation energies and reaction barriers, but this is an ongoing research area. More training data or more sophisticated models may be needed to accurately resolve transition state energies.\n\nTip\n\nCheck out the \n\nCatTsunami tutorial for transition state calculations using NEB methods.\n:::{admonition} What DFT settings should I use to verify the single-points? How would I reproduce these energies with DFT?\n:class: dropdown\n\nThe [Open Catalyst Dataset repo](https://github.com/facebookresearch/fairchem/tree/main/src/fairchem/data/oc) can be used to create DFT inputs. Specifically, the DFT settings are provided [here](https://github.com/facebookresearch/fairchem/blob/main/src/fairchem/data/oc/utils/vasp.py) to ensure consistency with the underlying OC20 DFT-level theory.\n\nWhat does the “shift” mean in the surface information?\n\nThe shift here is the absolute position of the cut and the resulting termination, and is used internally in \n\npymatgen for producing the surfaces. For very simple surfaces (e.g. Pt(111) or Cu(211)) there is only one unique surface termination so we don’t need to specify the shift. However, more complicated materials such as bimetallic systems may have several unique terminations that we can specify with the shift. It is sometimes possible to identify the best possible termination, but for bimetallic surfaces this is often not obvious so we include all of the possibilities here.\n\nI found a better adsorbate configuration than the one shown on this website; what should I do?\n\nThis is expected to happen when one of the following happens:\n\nOur adsorbate placement / guessing strategy isn’t exhaustive enough to find the best possible configuration\n\nThe trained ML models encounter errors or produce bad relaxations\n\nEither way, post on the discussion board so we can improve the models and datasets!","type":"content","url":"/faq-1#computational-catalysis-questions","position":9},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)"},"type":"lvl1","url":"/oc20","position":0},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)"},"content":"Dataset Overview\n\nProperty\n\nValue\n\nSize\n\n133M+ DFT calculations\n\nSystems\n\n~460K adsorbate-catalyst relaxations\n\nTasks\n\nS2EF, IS2RE, IS2RS\n\nElements\n\n55 elements from periodic table\n\nAdsorbates\n\n82 adsorbates\n\nPaper\n\nACS Catalysis 2021\n\nLicense\n\nCC-BY-4.0\n\nWarning\n\nData files for all tasks/splits were updated on Feb 10, 2021 due to minor bugs (affecting < 1% of the data) in earlier versions. If you downloaded data before Feb 10, 2021, please re-download the data.","type":"content","url":"/oc20","position":1},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl3":"Download and preprocess the dataset"},"type":"lvl3","url":"/oc20#download-and-preprocess-the-dataset","position":2},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl3":"Download and preprocess the dataset"},"content":"IS2* datasets are stored as LMDB files and are ready to be used upon download.\nS2EF train+val datasets require an additional preprocessing step.\n\nFor convenience, a self-contained script can be found \n\nhere to download, preprocess, and organize the data directories to be readily usable by the existing \n\nconfigs.\n\nFor IS2*, run the script as:python scripts/download_data.py --task is2re\n\nFor S2EF train/val, run the script as:python scripts/download_data.py --task s2ef --split SPLIT_SIZE --get-edges --num-workers WORKERS --ref-energy\n\n--split: split size to download: \"200k\", \"2M\", \"20M\", \"all\", \"val_id\", \"val_ood_ads\", \"val_ood_cat\", or \"val_ood_both\".\n\n--get-edges: includes edge information in LMDBs (~10x storage requirement, ~3-5x slowdown), otherwise, compute edges on the fly (larger GPU memory requirement).\n\n--num-workers: number of workers to parallelize preprocessing across.\n\n--ref-energy: uses referenced energies instead of raw energies.\n\nFor S2EF test, run the script as:python scripts/download_data.py --task s2ef --split test\n\nTo download and process the dataset in a directory other than your local fairchem/data folder, add the following command line argument --data-path.\n\nNote that the baseline \n\nconfigs.\nexpect the data to be found in fairchem/data, make sure you symlink your directory or\nmodify the paths in the configs accordingly.\n\nThe following sections list dataset download links and sizes for various S2EF\nand IS2RE/IS2RS task splits. If you used the above download_data.py script to\ndownload and preprocess the data, you are good to go and can stop reading here!","type":"content","url":"/oc20#download-and-preprocess-the-dataset","position":3},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl3":"Structure to Energy and Forces (S2EF) task"},"type":"lvl3","url":"/oc20#structure-to-energy-and-forces-s2ef-task","position":4},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl3":"Structure to Energy and Forces (S2EF) task"},"content":"For this task’s train and validation sets, we provide compressed trajectory files with the input structures and output energies and forces.  We provide precomputed LMDBs for the test sets. To use the train and validation datasets, first download the files and uncompress them. The uncompressed files are used to generate LMDBs, which are in turn used by the dataloaders to train the ML models. Code for the dataloaders and generating the LMDBs may be found in the Github repository.\n\nFour training datasets are provided with different sizes. Each is a subset of the other, i.e., the 2M dataset is contained in the 20M and all datasets.\n\nFour datasets are provided for validation set. Each dataset corresponds to a subsplit used to evaluate different types of extrapolation, in domain (id, same distribution as the training dataset), out of domain adsorbate (ood_ads, unseen adsorbate), out of domain catalyst (ood_cat, unseen catalyst composition), and out of domain both (ood_both, unseen adsorbate and catalyst composition).\n\nFor the test sets, we provide precomputed LMDBs for each of the 4 subsplits (In Domain, OOD Adsorbate, OOD Catalyst, OOD Both).\n\nEach tarball has a README file containing details about file formats, number of structures / trajectories, etc.\n\nSplits\n\nSize of compressed version (in bytes)\n\nSize of uncompressed version (in bytes)\n\nMD5 checksum (download link)\n\nTrain\n\n\n\n\n\n\n\nall\n\n225G\n\n1.1T\n\n12a7087bfd189a06ccbec9bc7add2bcd\n\n20M\n\n34G\n\n165G\n\n863bc983245ffc0285305a1850e19cf7\n\n2M\n\n3.4G\n\n17G\n\n953474cb93f0b08cdc523399f03f7c36\n\n200K\n\n344M\n\n1.7G\n\nf8d0909c2623a393148435dede7d3a46\n\n\n\n\n\n\n\n\n\nValidation\n\n\n\n\n\n\n\nval_id\n\n1.7G\n\n8.3G\n\nf57f7f5c1302637940f2cc858e789410\n\nval_ood_ads\n\n1.7G\n\n8.2G\n\n431ab0d7557a4639605ba8b67793f053\n\nval_ood_cat\n\n1.7G\n\n8.3G\n\n532d6cd1fe541a0ddb0aa0f99962b7db\n\nval_ood_both\n\n1.9G\n\n9.5G\n\n5731862978d80502bbf7017d68c2c729\n\n\n\n\n\n\n\n\n\nTest (LMDBs for all splits)\n\n30G\n\n415G\n\nbcada432482f6e87b24e14b6b744992a\n\n\n\n\n\n\n\n\n\nRattled data\n\n29G\n\n136G\n\n40431149b27b64ce1fb40cac4e2e064b\n\n\n\n\n\n\n\n\n\nMD data\n\n42G\n\n306G\n\n9fed845aaab8fb4bf85e3a8db57796e0\n\n\n\n\n\n\n\n","type":"content","url":"/oc20#structure-to-energy-and-forces-s2ef-task","position":5},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl3":"Initial Structure to Relaxed Structure (IS2RS) and Initial Structure to Relaxed Energy (IS2RE) tasks"},"type":"lvl3","url":"/oc20#initial-structure-to-relaxed-structure-is2rs-and-initial-structure-to-relaxed-energy-is2re-tasks","position":6},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl3":"Initial Structure to Relaxed Structure (IS2RS) and Initial Structure to Relaxed Energy (IS2RE) tasks"},"content":"For the IS2RS and IS2RE tasks, we are providing:\n\nOne .tar.gz file with precomputed LMDBs which once downloaded and uncompressed, can be used directly to train ML models. The LMDBs contain the input initial structures and the output relaxed structures and energies. Training datasets are split by size, with each being a subset of the larger splits, similar to S2EF. The validation and test datasets are broken into subsplits based on different extrapolation evaluations (In Domain, OOD Adsorbate, OOD Catalyst, OOD Both).\n\nunderlying ASE relaxation trajectories for the adsorbate+catalyst in the entire training and validation sets for the IS2RE and IS2RS tasks. These are not required to download for training ML models, but are available for interested users.\n\nEach tarball has README file containing details about file formats, number of structures / trajectories, etc.\n\nSplits\n\nSize of compressed version (in bytes)\n\nSize of uncompressed version (in bytes)\n\nMD5 checksum (download link)\n\nTrain (all splits) + Validation (all splits) + test (all splits)\n\n8.1G\n\n97G\n\ncfc04dd2f87b4102ab2f607240d25fb1\n\nTest-challenge 2021 (\n\nchallenge details)\n\n1.3G\n\n17G\n\naed414cdd240fbb5670b5de6887a138b\n\n\n\n\n\n\n\n","type":"content","url":"/oc20#initial-structure-to-relaxed-structure-is2rs-and-initial-structure-to-relaxed-energy-is2re-tasks","position":7},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl3":"Relaxation Trajectories"},"type":"lvl3","url":"/oc20#relaxation-trajectories","position":8},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl3":"Relaxation Trajectories"},"content":"","type":"content","url":"/oc20#relaxation-trajectories","position":9},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl4":"Adsorbate+catalyst system trajectories (optional download)","lvl3":"Relaxation Trajectories"},"type":"lvl4","url":"/oc20#adsorbate-catalyst-system-trajectories-optional-download","position":10},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl4":"Adsorbate+catalyst system trajectories (optional download)","lvl3":"Relaxation Trajectories"},"content":"Split\n\nSize of compressed version (in bytes)\n\nSize of uncompressed version (in bytes)\n\nMD5 checksum (download link)\n\nAll IS2RE/S training (~466k trajectories)\n\n109G\n\n841G\n\n9e3ed4d1e497bfdce4472ee70455edef\n\n\n\n\n\n\n\n\n\nIS2RE/S Validation\n\n\n\n\n\n\n\nval_id (~25K trajectories)\n\n5.9G\n\n46G\n\nfcb71363018fb1e7127db2500e39e11a\n\nval_ood_ads (~25K trajectories)\n\n5.7G\n\n44G\n\n5ced8ea84584aa229d31e693e0fb090f\n\nval_ood_cat (~25K trajectories)\n\n6.0G\n\n46G\n\n88dcc02fd8c174a72d2c416878fc44ff\n\nval_ood_both (~25K trajectories)\n\n4.4G\n\n35G\n\nbc74b6474a13542cc56eaa97bd51adfc","type":"content","url":"/oc20#adsorbate-catalyst-system-trajectories-optional-download","position":11},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl5":"Per-adsorbate trajectories (optional download)","lvl4":"Adsorbate+catalyst system trajectories (optional download)","lvl3":"Relaxation Trajectories"},"type":"lvl5","url":"/oc20#per-adsorbate-trajectories-optional-download","position":12},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl5":"Per-adsorbate trajectories (optional download)","lvl4":"Adsorbate+catalyst system trajectories (optional download)","lvl3":"Relaxation Trajectories"},"content":"Download links are in the table below:\n\nAdsorbate symbol\n\nDownloadable path\n\nsize\n\nMD5 checksum\n\n*O\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/0​.tar\n\n1006M\n\nd4151542856b4b6405f276808f75358a\n\n*H\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/1​.tar\n\n850M\n\n3697f04faf04251a23da8b88a78209f7\n\n*OH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/2​.tar\n\n1.6G\n\na21081f3f55eb0c98a91021bbe3dac44\n\n*OH2\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/3​.tar\n\n1.8G\n\nb12b706854f5d899e02a9ae6578b5d45\n\n*C\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/4​.tar\n\n1.1G\n\ne4fe9890764fcf59e01e3ceab089b978\n\n*CH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/6​.tar\n\n1.4G\n\nec9aa2c4c4bd4419359438ba7fbb881d\n\n*CHO\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/7​.tar\n\n1.4G\n\nd32200f74ad5c3bfd42e8835f36d57ab\n\n*COH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/8​.tar\n\n1.6G\n\n5418a1b331f6c7689a5405cca4cc8d15\n\n*CH2\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/9​.tar\n\n1.6G\n\n8ee1066149c305d7c17c219b369c5a73\n\nCH2O\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/10​.tar\n\n1.7G\n\n960c2450814024b66f3c79121179ac60\n\n*CHOH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/11​.tar\n\n1.8G\n\n60ac9f965f9589a3389483e3d1e58144\n\n*CH3\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/12​.tar\n\n1.7G\n\n7e123e6f4fb10d6897be3f47721dfd4a\n\n*OCH3\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/13​.tar\n\n1.8G\n\n0823047bbbe05fa0e63f9d83ec601487\n\n*CH2OH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/14​.tar\n\n1.9G\n\n9ac71e198d75b1427182cd34abb73e4d\n\n*CH4\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/15​.tar\n\n1.9G\n\na405ce403018bf8afbd4425d5c0b34d5\n\n*OHCH3\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/16​.tar\n\n2.1G\n\nd3c829f1952db6e4f428273ee05f59b1\n\nCC\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/17​.tar\n\n1.5G\n\nd687a151345305897b9245af4b0f9967\n\n*CCO\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/18​.tar\n\n1.7G\n\n214ca96e620c5ec6e8a6ff8144a22a04\n\n*CCH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/19​.tar\n\n1.6G\n\nda2268545e80ca1664026449dd2fdd24\n\n*CHCO\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/20​.tar\n\n1.7G\n\n386c99407fe63080d26cda525dfdd8cd\n\n*CCHO\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/21​.tar\n\n1.8G\n\n918b20960438494ab160a9dbd9668157\n\n*COCHO\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/22​.tar\n\n1.8G\n\n84424aa2ad30301e23ece1438ea39923\n\n*CCHOH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/23​.tar\n\n2.0G\n\n3cc90425ec042a70085ba7eb2916a79a\n\n*CCH2\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/24​.tar\n\n1.8G\n\n9dbcf7566e40965dd7f8a186a75a718e\n\nCHCH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/25​.tar\n\n1.7G\n\na193b4c72f915ba0b21a41790696b23c\n\nCH2*CO\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/26​.tar\n\n1.8G\n\nde83cf50247f5556fa4f9f64beff1eeb\n\n*CHCHO\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/27​.tar\n\n1.9G\n\n1d140aaa2e7b287124ab38911a711d70\n\nCHCOH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/28​.tar\n\n1.3G\n\n682d8a6b05ca5948b34dc5e5f6bbcd61\n\n*COCH2O\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/29​.tar\n\n1.9G\n\nc8742faa8ca40e8edb4110069817fa70\n\nCHOCHO\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/30​.tar\n\n2.0G\n\n8cfbb67beb312b98c40fcb891dfa480a\n\n*COHCHO\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/31​.tar\n\n1.9G\n\n6ffa903a62d8ec3319ecec6a03b06276\n\n*COHCOH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/32​.tar\n\n2.0G\n\ncaca0058b641bfdc9f8de4527e60feb7\n\n*CCH3\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/33​.tar\n\n1.8G\n\n906543aaefc171edab388ff4f0fe8a20\n\n*CHCH2\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/34​.tar\n\n1.8G\n\n4dfab479495f76179749c1956046fbd8\n\n*COCH3\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/35​.tar\n\n1.9G\n\n29d1b992715054e920e8bb2afe97b393\n\n*CHCHOH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/38​.tar\n\n2.0G\n\n9e5912df6f7b11706d1046cdb9e3087e\n\n*CCH2OH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/39​.tar\n\n2.1G\n\n7bcae43cee451306e34ec416588a7f09\n\n*CHOCHOH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/40​.tar\n\n2.0G\n\nf98866d08fe3451ae7ebc47bb51599aa\n\n*COCH2OH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/41​.tar\n\n1.4G\n\nbfaf689e5827fcf26c51e567bb8dd1be\n\n*COHCHOH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/42​.tar\n\n2.0G\n\n236fe4e950aa2fbdde94ef2821fb48d2\n\n*OCHCH3\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/44​.tar\n\n2.1G\n\n66acc5460a999625c3364f0f3bcca871\n\n*COHCH3\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/45​.tar\n\n2.1G\n\nbb4a01956736399c8cee5e219f8c1229\n\n*CHOHCH2\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/46​.tar\n\n2.1G\n\ne836de4ec146b1b611533f1ef682cace\n\n*CHCH2OH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/47​.tar\n\n2.0G\n\n66df44121806debef6dc038df7115d1d\n\n*OCH2CHOH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/48​.tar\n\n2.2G\n\nff6981fdbcd2e65d351505c15d218d76\n\n*CHOCH2OH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/49​.tar\n\n2.1G\n\n448f7d352ab6e32f754e24de64ca302a\n\n*COHCH2OH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/50​.tar\n\n2.1G\n\n8bff6bf3e10cc84acc4a283a375fcc23\n\n*CHOHCHOH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/51​.tar\n\n2.0G\n\n9c9e4d617d306751760a80f1453e71f1\n\n*CH2CH3\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/52​.tar\n\n2.0G\n\nec1e964d2ee6f468fa5773743e3994a4\n\n*OCH2CH3\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/53​.tar\n\n2.1G\n\nd297b27b02822f9b6af80bdb64aee819\n\n*CHOHCH3\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/54​.tar\n\n2.1G\n\n368de083dafdc3bbdb560d35e2a102c0\n\n*CH2CH2OH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/55​.tar\n\n2.1G\n\n3c1aaf790659f7ff89bf1eed8b396b63\n\n*CHOHCH2OH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/56​.tar\n\n2.2G\n\n2d71adb9e305e6f3bca49e5df9b5a86a\n\n*OHCH2CH3\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/57​.tar\n\n2.3G\n\ncf51128f8522b7b66fc68d79980d6def\n\n*NH2N(CH3)2\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/58​.tar\n\n1.6G\n\n36ba974d80c20ff636431f7c0ad225da\n\n*ONN(CH3)2\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/59​.tar\n\n2.3G\n\nfdc4cd19977496909d61be4aee61c4f1\n\n*OHNNCH3\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/60​.tar\n\n2.1G\n\n50a6ff098f9ba7adbba9ac115726cc5a\n\n*ONH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/62​.tar\n\n1.8G\n\n47573199c545afe46c554ff756c3e38f\n\n*NHNH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/63​.tar\n\n1.7G\n\ndd456b7e19ef592d9f0308d911b91d7c\n\nNNH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/65​.tar\n\n1.6G\n\nc05289fd56d64c74306ebf57f1061318\n\n*NO2NO2\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/67​.tar\n\n2.1G\n\n4822a06f6c5f41bdefd3cbbd8856c11f\n\nNNO\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/68​.tar\n\n1.6G\n\n2a27de122d32917cc5b6ac0a21c63c1c\n\n*N2\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/69​.tar\n\n1.5G\n\ncc668fecf679b6edaac8fd8fb9cdd404\n\n*ONNH2\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/70​.tar\n\n2.1G\n\ndff880f1a5baa7f67b52fd3ed745443d\n\n*NH2\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/71​.tar\n\n1.6G\n\nc7f383b50faa6244e265c9611466cb8f\n\n*NH3\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/72​.tar\n\n1.9G\n\n2b355741f9300445703270e0e4b8c01c\n\n*NONH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/73​.tar\n\n1.8G\n\n48877a0c6f2994baac82cb722711aaa2\n\n*NH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/74​.tar\n\n1.4G\n\n7979b9e7ab557d6979b33e352486f0ef\n\n*NO2\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/75​.tar\n\n1.7G\n\n9f352fbc32bb2b8caf4788aba28b2eb7\n\n*NO\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/76​.tar\n\n1.4G\n\n482ee306a5ae2eee78cac40d10059ebc\n\n*N\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/77​.tar\n\n1.1G\n\nbfb6e03d4a687987ff68976f0793cc46\n\n*NO3\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/78​.tar\n\n1.8G\n\n700834326e789a6e38bf3922d9fcb792\n\n*OHNH2\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/79​.tar\n\n2.1G\n\nfa24472e0c02c34d91f3ffe6b77bfb11\n\n*ONOH\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/80​.tar\n\n1.4G\n\n4ddcccd62a834a76fe6167461f512529\n\n*CN\n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/per​_adsorbate​_is2res​/81​.tar\n\n1.5G\n\nbc7c55330ece006d09496a5ff01d5d50\n\nNote - A few adsorbates are intentionally left out for the test splits.\n\nDownloading any of the above and extracting will result in a folder :\n\n<index>/\n\nsystem.txt Text file containing information about the different adsorbate+catalyst system names. In total there are N systems. More details described below.\n\n<index>/\n\nThis contains N compressed trajectory files of the format .extxyz.xz.\n\nFiles are named as  <system_id>.extxyz.xz (where system_id is defined below).\n\nwhere, <index> can be 0 to 81. N is dependent on which adsorbate index is chosen.\n\nThe file  system.txt  has information in the following format:\nsystem_id,reference_energy\n\nwhere:\n\nsystem_id - Internal random ID corresponding to an adsorbate+catalyst system.\n\nreference_energy - Energy used to reference system energies to bare catalyst+gas reference energies. Used for adsorption energy calculations.\n\nThe .extxyz.xz files are LZMA compressed .extxyz trajectory files. Each trajectory corresponds to a relaxation trajectory of a different adsorbate+catalyst system. Information about the .extxyz trajectory file format may be found at \n\nhttps://​wiki​.fysik​.dtu​.dk​/ase​/dev​/ase​/io​/formatoptions​.html​#extxyz .\n\nIn order to uncompress the files, uncompress.py provides a multi-core implementation which could be used.","type":"content","url":"/oc20#per-adsorbate-trajectories-optional-download","position":13},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl4":"Catalyst system trajectories (optional download)","lvl3":"Relaxation Trajectories"},"type":"lvl4","url":"/oc20#catalyst-system-trajectories-optional-download","position":14},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl4":"Catalyst system trajectories (optional download)","lvl3":"Relaxation Trajectories"},"content":"Number\n\nSize of compressed version (in bytes)\n\nSize of uncompressed version (in bytes)\n\nMD5 checksum (download link)\n\n294k systems\n\n20G\n\n151G\n\n347f4183465810e9b384e7a033baefc7","type":"content","url":"/oc20#catalyst-system-trajectories-optional-download","position":15},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl3":"Bader charge data"},"type":"lvl3","url":"/oc20#bader-charge-data","position":16},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl3":"Bader charge data"},"content":"We provide Bader charge data for all final frames of our train + validation systems in OC20 (for both S2EF and IS2RE/RS tasks). A .tar.gz file, when downloaded and uncompressed will contain several directories with unique system-ids (of the format random<XYZ> where XYZ is an integer). Each directory will contain raw Bader charge analysis outputs. For more details on the Bader charge analysis, see \n\nhttps://​theory​.cm​.utexas​.edu​/henkelman​/research​/bader/.\n\nDownloadable link: \n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/oc20​_bader​_data​.tar (MD5 checksum: aecc5e23542de49beceb4b7e44c153b9)","type":"content","url":"/oc20#bader-charge-data","position":17},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl3":"OC20 mappings"},"type":"lvl3","url":"/oc20#oc20-mappings","position":18},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl3":"OC20 mappings"},"content":"","type":"content","url":"/oc20#oc20-mappings","position":19},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl4":"Data mapping information","lvl3":"OC20 mappings"},"type":"lvl4","url":"/oc20#data-mapping-information","position":20},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl4":"Data mapping information","lvl3":"OC20 mappings"},"content":"We provide a Python pickle file containing information about the slab and adsorbates for each of the systems in OC20 dataset. Loading the pickle file will load a Python dictionary. The keys of this dictionary are the adsorbate+catalyst system-ids (of the format random<XYZ>  where XYZ is an integer), and the corresponding value of each key is a dictionary with information about:\n\nbulk_mpid : Materials Project ID of the bulk system used corresponding to the catalyst surface\n\nbulk_symbols  Chemical composition of the bulk counterpart\n\nads_symbols  Chemical composition of the adsorbate counterpart\n\nads_id : internal unique identifier, one for each of the 82 adsorbates used in the dataset\n\nbulk_id : internal unique identifier one for each of the 11500 bulks used in the dataset\n\nmiller_index: 3-tuple of integers indicating the Miller indices of the surface\n\nshift: c-direction shift used to determine cutoff for the surface (c-direction is following the nomenclature from Pymatgen)\n\ntop: boolean indicating whether the chosen surface was at the top or bottom of the originally enumerated surface\n\nadsorption_site: A tuple of 3-tuples containing the Cartesian coordinates of each binding adsorbate atom\n\nclass: integer indicating the class of materials the system’s slab is part of, where:\n\n0 - intermetallics\n\n1 - metalloids\n\n2 - non-metals\n\n3 - halides\n\nanomaly: integer indicating possible anomalies (based off general heuristics, not to be taken as perfect classifications), where:\n\n0 - no anomaly\n\n1 - adsorbate dissociation\n\n2 - adsorbate desorption\n\n3 - surface reconstruction\n\n4 - incorrect CHCOH placement, appears to be CHCO with a lone, uninteracting, H far off in the unit cell\n\nDownloadable link: \n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/oc20​_data​_mapping​.pkl (MD5 checksum: 6b5d485019861f6e7efca38338375b61)\n\nAn example entry is'random2181546': {'bulk_id': 6510,\n  'ads_id': 69,\n  'bulk_mpid': 'mp-22179',\n  'bulk_symbols': 'Si2Ti2Y2',\n  'ads_symbols': '*N2',\n  'miller_index': (2, 0, 1),\n  'shift': 0.145,\n  'top': True,\n  'adsorption_site': ((4.5, 12.85, 16.13),),\n  'class': 1,\n  'anomaly': 0}","type":"content","url":"/oc20#data-mapping-information","position":21},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl3":"Adsorbate-catalyst system to catalyst system mapping information"},"type":"lvl3","url":"/oc20#adsorbate-catalyst-system-to-catalyst-system-mapping-information","position":22},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl3":"Adsorbate-catalyst system to catalyst system mapping information"},"content":"We provide a Python pickle file containing information about the mapping from adsorbate-catalyst systems to their corresponding catalyst systems. Loading the pickle file will load a Python dictionary. The keys of this dictionary are the adsorbate+catalyst system-ids (of the format random<XYZ>  where XYZ is an integer), and values will be the catalyst system-ids (of the format random<PQR> where PQR is an integer).\n\nDownloadable link: \n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/mapping​_adslab​_slab​.pkl (MD5 checksum: 079041076c3f15d18ecb5d17c509cdfe)\n\nAn example entry is'random1981709': 'random533137'","type":"content","url":"/oc20#adsorbate-catalyst-system-to-catalyst-system-mapping-information","position":23},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl3":"Dataset changelog"},"type":"lvl3","url":"/oc20#dataset-changelog","position":24},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl3":"Dataset changelog"},"content":"","type":"content","url":"/oc20#dataset-changelog","position":25},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl4":"September 2021","lvl3":"Dataset changelog"},"type":"lvl4","url":"/oc20#september-2021","position":26},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl4":"September 2021","lvl3":"Dataset changelog"},"content":"Released IS2RE test-challenge data for the \n\nOpen Catalyst Challenge 2021","type":"content","url":"/oc20#september-2021","position":27},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl4":"March 2021","lvl3":"Dataset changelog"},"type":"lvl4","url":"/oc20#march-2021","position":28},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl4":"March 2021","lvl3":"Dataset changelog"},"content":"Modified the pickle corresponding to data mapping information. Now the pickle includes extra information about miller_index, shift, top and adsorption_site.\n\nAdded Molecular Dynamics (MD) and rattled data for S2EF task.","type":"content","url":"/oc20#march-2021","position":29},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl4":"Version 2, Feb 2021","lvl3":"Dataset changelog"},"type":"lvl4","url":"/oc20#version-2-feb-2021","position":30},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl4":"Version 2, Feb 2021","lvl3":"Dataset changelog"},"content":"Modifications:\n\nRemoved slab systems which had single frame checkpoints, this led to modifications of reference frame energies of 350k frames out of 130M.\n\nFixed stitching of checkpoints in adsorbate+catalyst trajectories.\n\nAdded release of slab trajectories.\n\nBelow are actual updates numbers, of the form old → new\n\nTotal S2EF frames:\n\ntrain: 133953162 → 133934018\n\nvalidation:\n\nval_id : 1000000 → 999866\n\nval_ood_ads: 1000000 → 999838\n\nval_ood_cat: 1000000 → 999809\n\nval_ood_both: 1000000 →  999944\n\ntest:\n\ntest_id: 1000000 → 999736\n\ntest_ood_ads: 1000000 → 999859\n\ntest_ood_cat: 1000000 → 999826\n\ntest_ood_both: 1000000 → 999973\n\nTotal IS2RE and IS2RS systems:\n\ntrain: 461313 → 460328\n\nvalidation:\n\nval_id : 24946 → 24943\n\nval_ood_ads: 24966 → 24961\n\nval_ood_cat: 24988 → 24963\n\nval_ood_both: 24963 → 24987\n\ntest:\n\ntest_id: 24951 → 24948\n\ntest_ood_ads: 24931 → 24930\n\ntest_ood_cat: 24967 → 24965\n\ntest_ood_both: 24986 → 24985","type":"content","url":"/oc20#version-2-feb-2021","position":31},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl4":"Version 1, Oct 2020","lvl3":"Dataset changelog"},"type":"lvl4","url":"/oc20#version-1-oct-2020","position":32},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl4":"Version 1, Oct 2020","lvl3":"Dataset changelog"},"content":"Total S2EF frames:\n\ntrain: 133953162\n\nvalidation:\n\nval_id : 1000000\n\nval_ood_ads: 1000000\n\nval_ood_cat: 1000000\n\nval_ood_both: 1000000\n\ntest:\n\ntest_id: 1000000\n\ntest_ood_ads: 1000000\n\ntest_ood_cat: 1000000\n\ntest_ood_both: 1000000\n\nTotal IS2RE and IS2RS systems:\n\ntrain: 461313\n\nvalidation:\n\nval_id : 24936\n\nval_ood_ads: 24966\n\nval_ood_cat: 24988\n\nval_ood_both: 24963\n\ntest:\n\ntest_id: 24951\n\ntest_ood_ads: 24931\n\ntest_ood_cat: 24967\n\ntest_ood_both: 24986","type":"content","url":"/oc20#version-1-oct-2020","position":33},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl3":"Citing OC20"},"type":"lvl3","url":"/oc20#citing-oc20","position":34},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl3":"Citing OC20"},"content":"The Open Catalyst 2020 (OC20) dataset is licensed under a \n\nCreative Commons Attribution 4.0 License.\n\nPlease consider citing the following paper in any research manuscript using the OC20 dataset:@article{ocp_dataset,\n    author = {Chanussot*, Lowik and Das*, Abhishek and Goyal*, Siddharth and Lavril*, Thibaut and Shuaibi*, Muhammed and Riviere, Morgane and Tran, Kevin and Heras-Domingo, Javier and Ho, Caleb and Hu, Weihua and Palizhati, Aini and Sriram, Anuroop and Wood, Brandon and Yoon, Junwoong and Parikh, Devi and Zitnick, C. Lawrence and Ulissi, Zachary},\n    title = {Open Catalyst 2020 (OC20) Dataset and Community Challenges},\n    journal = {ACS Catalysis},\n    year = {2021},\n    doi = {10.1021/acscatal.0c04525},\n}","type":"content","url":"/oc20#citing-oc20","position":35},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl2":"Per-adsorbate trajectories"},"type":"lvl2","url":"/oc20#per-adsorbate-trajectories","position":36},{"hierarchy":{"lvl1":"Open Catalyst 2020 (OC20)","lvl2":"Per-adsorbate trajectories"},"content":"Adsorbate symbol\n\nSize\n\nMD5 checksum (download link)\n\n*O\n\n1006M\n\nd4151542856b4b6405f276808f75358a\n\n*H\n\n850M\n\n3697f04faf04251a23da8b88a78209f7\n\n*OH\n\n1.6G\n\na21081f3f55eb0c98a91021bbe3dac44\n\n*OH2\n\n1.8G\n\nb12b706854f5d899e02a9ae6578b5d45\n\n*C\n\n1.1G\n\ne4fe9890764fcf59e01e3ceab089b978\n\n*CH\n\n1.4G\n\nec9aa2c4c4bd4419359438ba7fbb881d\n\n*CHO\n\n1.4G\n\nd32200f74ad5c3bfd42e8835f36d57ab\n\n*COH\n\n1.6G\n\n5418a1b331f6c7689a5405cca4cc8d15\n\n*CH2\n\n1.6G\n\n8ee1066149c305d7c17c219b369c5a73\n\nCH2O\n\n1.7G\n\n960c2450814024b66f3c79121179ac60\n\n*CHOH\n\n1.8G\n\n60ac9f965f9589a3389483e3d1e58144\n\n*CH3\n\n1.7G\n\n7e123e6f4fb10d6897be3f47721dfd4a\n\n*OCH3\n\n1.8G\n\n0823047bbbe05fa0e63f9d83ec601487\n\n*CH2OH\n\n1.9G\n\n9ac71e198d75b1427182cd34abb73e4d\n\n*CH4\n\n1.9G\n\na405ce403018bf8afbd4425d5c0b34d5\n\n*OHCH3\n\n2.1G\n\nd3c829f1952db6e4f428273ee05f59b1\n\nCC\n\n1.5G\n\nd687a151345305897b9245af4b0f9967\n\n*CCO\n\n1.7G\n\n214ca96e620c5ec6e8a6ff8144a22a04\n\n*CCH\n\n1.6G\n\nda2268545e80ca1664026449dd2fdd24\n\n*CHCO\n\n1.7G\n\n386c99407fe63080d26cda525dfdd8cd\n\n*CCHO\n\n1.8G\n\n918b20960438494ab160a9dbd9668157\n\n*COCHO\n\n1.8G\n\n84424aa2ad30301e23ece1438ea39923\n\n*CCHOH\n\n2.0G\n\n3cc90425ec042a70085ba7eb2916a79a\n\n*CCH2\n\n1.8G\n\n9dbcf7566e40965dd7f8a186a75a718e\n\nCHCH\n\n1.7G\n\na193b4c72f915ba0b21a41790696b23c\n\nCH2*CO\n\n1.8G\n\nde83cf50247f5556fa4f9f64beff1eeb\n\n*CHCHO\n\n1.9G\n\n1d140aaa2e7b287124ab38911a711d70\n\nCHCOH\n\n1.3G\n\n682d8a6b05ca5948b34dc5e5f6bbcd61\n\n*COCH2O\n\n1.9G\n\nc8742faa8ca40e8edb4110069817fa70\n\nCHOCHO\n\n2.0G\n\n8cfbb67beb312b98c40fcb891dfa480a\n\n*COHCHO\n\n1.9G\n\n6ffa903a62d8ec3319ecec6a03b06276\n\n*COHCOH\n\n2.0G\n\ncaca0058b641bfdc9f8de4527e60feb7\n\n*CCH3\n\n1.8G\n\n906543aaefc171edab388ff4f0fe8a20\n\n*CHCH2\n\n1.8G\n\n4dfab479495f76179749c1956046fbd8\n\n*COCH3\n\n1.9G\n\n29d1b992715054e920e8bb2afe97b393\n\n*CHCHOH\n\n2.0G\n\n9e5912df6f7b11706d1046cdb9e3087e\n\n*CCH2OH\n\n2.1G\n\n7bcae43cee451306e34ec416588a7f09\n\n*CHOCHOH\n\n2.0G\n\nf98866d08fe3451ae7ebc47bb51599aa\n\n*COCH2OH\n\n1.4G\n\nbfaf689e5827fcf26c51e567bb8dd1be\n\n*COHCHOH\n\n2.0G\n\n236fe4e950aa2fbdde94ef2821fb48d2\n\n*OCHCH3\n\n2.1G\n\n66acc5460a999625c3364f0f3bcca871\n\n*COHCH3\n\n2.1G\n\nbb4a01956736399c8cee5e219f8c1229\n\n*CHOHCH2\n\n2.1G\n\ne836de4ec146b1b611533f1ef682cace\n\n*CHCH2OH\n\n2.0G\n\n66df44121806debef6dc038df7115d1d\n\n*OCH2CHOH\n\n2.2G\n\nff6981fdbcd2e65d351505c15d218d76\n\n*CHOCH2OH\n\n2.1G\n\n448f7d352ab6e32f754e24de64ca302a\n\n*COHCH2OH\n\n2.1G\n\n8bff6bf3e10cc84acc4a283a375fcc23\n\n*CHOHCHOH\n\n2.0G\n\n9c9e4d617d306751760a80f1453e71f1\n\n*CH2CH3\n\n2.0G\n\nec1e964d2ee6f468fa5773743e3994a4\n\n*OCH2CH3\n\n2.1G\n\nd297b27b02822f9b6af80bdb64aee819\n\n*CHOHCH3\n\n2.1G\n\n368de083dafdc3bbdb560d35e2a102c0\n\n*CH2CH2OH\n\n2.1G\n\n3c1aaf790659f7ff89bf1eed8b396b63\n\n*CHOHCH2OH\n\n2.2G\n\n2d71adb9e305e6f3bca49e5df9b5a86a\n\n*OHCH2CH3\n\n2.3G\n\ncf51128f8522b7b66fc68d79980d6def\n\n*NH2N(CH3)2\n\n1.6G\n\n36ba974d80c20ff636431f7c0ad225da\n\n*ONN(CH3)2\n\n2.3G\n\nfdc4cd19977496909d61be4aee61c4f1\n\n*OHNNCH3\n\n2.1G\n\n50a6ff098f9ba7adbba9ac115726cc5a\n\n*ONH\n\n1.8G\n\n47573199c545afe46c554ff756c3e38f\n\n*NHNH\n\n1.7G\n\ndd456b7e19ef592d9f0308d911b91d7c\n\nNNH\n\n1.6G\n\nc05289fd56d64c74306ebf57f1061318\n\n*NO2NO2\n\n2.1G\n\n4822a06f6c5f41bdefd3cbbd8856c11f\n\nNNO\n\n1.6G\n\n2a27de122d32917cc5b6ac0a21c63c1c\n\n*N2\n\n1.5G\n\ncc668fecf679b6edaac8fd8fb9cdd404\n\n*ONNH2\n\n2.1G\n\ndff880f1a5baa7f67b52fd3ed745443d\n\n*NH2\n\n1.6G\n\nc7f383b50faa6244e265c9611466cb8f\n\n*NH3\n\n1.9G\n\n2b355741f9300445703270e0e4b8c01c\n\n*NONH\n\n1.8G\n\n48877a0c6f2994baac82cb722711aaa2\n\n*NH\n\n1.4G\n\n7979b9e7ab557d6979b33e352486f0ef\n\n*NO2\n\n1.7G\n\n9f352fbc32bb2b8caf4788aba28b2eb7\n\n*NO\n\n1.4G\n\n482ee306a5ae2eee78cac40d10059ebc\n\n*N\n\n1.1G\n\nbfb6e03d4a687987ff68976f0793cc46\n\n*NO3\n\n1.8G\n\n700834326e789a6e38bf3922d9fcb792\n\n*OHNH2\n\n2.1G\n\nfa24472e0c02c34d91f3ffe6b77bfb11\n\n*ONOH\n\n1.4G\n\n4ddcccd62a834a76fe6167461f512529\n\n*CN\n\n1.5G\n\nbc7c55330ece006d09496a5ff01d5d50\n\nNote - A few adsorbates are intentionally left out for the test splits.\n\nDownloading any of the above and extracting will result in a folder:\n\n<index>/\n\nsystem.txt Text file containing information about the different adsorbate+catalyst system names. In total there are N systems. More details described below.\n\n<index>/\n\nThis contains N compressed trajectory files of the format .extxyz.xz.\n\nFiles are named as  <system_id>.extxyz.xz (where system_id is defined below).\n\nwhere, <index> can be 0 to 81. N is dependent on which adsorbate index is chosen.\n\nThe file  system.txt  has information in the following format:\nsystem_id,reference_energy\n\nwhere:\n\nsystem_id - Internal random ID corresponding to an adsorbate+catalyst system.\n\nreference_energy - Energy used to reference system energies to bare catalyst+gas reference energies. Used for adsorption energy calculations.\n\nThe .extxyz.xz files are LZMA compressed .extxyz trajectory files. Each trajectory corresponds to a relaxation trajectory of a different adsorbate+catalyst system. Information about the .extxyz trajectory file format may be found at \n\nhttps://​wiki​.fysik​.dtu​.dk​/ase​/ase​/io​/formatoptions​.html​#extxyz.\n\nIn order to uncompress the files, uncompress.py provides a multi-core implementation which could be used.","type":"content","url":"/oc20#per-adsorbate-trajectories","position":37},{"hierarchy":{"lvl1":"Open Catalyst 2020 Multi-Adsorbate (mAds) Dataset"},"type":"lvl1","url":"/oc20-mads","position":0},{"hierarchy":{"lvl1":"Open Catalyst 2020 Multi-Adsorbate (mAds) Dataset"},"content":"Dataset Overview\n\nProperty\n\nValue\n\nSize\n\n21.8M structures\n\nMax Adsorbates\n\nUp to 5 adsorbates per surface\n\nPurpose\n\nMulti-adsorbate and coverage effects\n\nPaper\n\nUMA Paper\n\nLicense\n\nCC-BY-4.0","type":"content","url":"/oc20-mads","position":1},{"hierarchy":{"lvl1":"Open Catalyst 2020 Multi-Adsorbate (mAds) Dataset","lvl2":"Overview"},"type":"lvl2","url":"/oc20-mads#overview","position":2},{"hierarchy":{"lvl1":"Open Catalyst 2020 Multi-Adsorbate (mAds) Dataset","lvl2":"Overview"},"content":"The OC20-mAds dataset is a training set expanding the original OC20 dataset to include multi-adsorbate and coverage effects on catalyst surfaces. Adsorbates are randomly sampled from the list of OC20 adsorbates, up to 5 maximum adsorbates. For a small fraction of the dataset, all adsorbates on the surface may be identical. OC20-mAds is introduced in the \n\nUMA paper.","type":"content","url":"/oc20-mads#overview","position":3},{"hierarchy":{"lvl1":"Open Catalyst 2020 Multi-Adsorbate (mAds) Dataset","lvl2":"File Contents and Download"},"type":"lvl2","url":"/oc20-mads#file-contents-and-download","position":4},{"hierarchy":{"lvl1":"Open Catalyst 2020 Multi-Adsorbate (mAds) Dataset","lvl2":"File Contents and Download"},"content":"Splits\n\nSize\n\nMD5 checksum (download link)\n\nTrain\n\n21,804,758\n\n6435960ba5ad1a7c949bd2f2b51825bc\n\nThe following metadata can be accessed in the respective atoms.info entry:\n\nbulk_id: Bulk identifier\n\nmillers: 3-tuple of integers indicating the Miller indices of the surface.\n\nshift: C-direction shift used to determine cutoff for the surface (c-direction is following the nomenclature from Pymatgen).\n\ntop: Boolean indicating whether the chosen surface was at the top or bottom of the originally enumerated surface.\n\nadsorbates: List of adsorbates sampled and their respective placements.\n\nsid: Unique system identifier.\n\nfid: Frame index along the relaxation/AIMD trajectory.\n\nresults_path: Internal results location.\n\nfmax: Max per-atom force.","type":"content","url":"/oc20-mads#file-contents-and-download","position":5},{"hierarchy":{"lvl1":"Open Catalyst 2020 Dense (OC20Dense)"},"type":"lvl1","url":"/oc20dense","position":0},{"hierarchy":{"lvl1":"Open Catalyst 2020 Dense (OC20Dense)"},"content":"Dataset Overview\n\nProperty\n\nValue\n\nSize\n\n85,658 unique configurations\n\nSystems\n\n~1,000 adsorbate+surface materials\n\nPurpose\n\nGlobal minimum adsorption energy evaluation\n\nPaper\n\nAdsorbML (arXiv)\n\nLicense\n\nCC-BY-4.0","type":"content","url":"/oc20dense","position":1},{"hierarchy":{"lvl1":"Open Catalyst 2020 Dense (OC20Dense)","lvl2":"Overview"},"type":"lvl2","url":"/oc20dense#overview","position":2},{"hierarchy":{"lvl1":"Open Catalyst 2020 Dense (OC20Dense)","lvl2":"Overview"},"content":"The OC20Dense dataset is a validation dataset which was used to assess model performance in \n\nAdsorbML: A Leap in Efficiency for Adsorption Energy Calculations using Generalizable Machine Learning Potentials. OC20-Dense contains a dense sampling of adsorbate configurations on ~1,000 randomly selected adsorbate+surface materials from the \n\nOC20 dataset. It comprises a total of 85,658 unique input configurations. This dataset, and the paper written for it, supports the determination of global minimum adsorbate-surface energies (the adsorption energy). This differs from OC20, which contains local adsorbate relaxations. Under low coverage conditions, the global minimum energy site is the most likely to be occupied. For computational catalysis research, we correlate the adsorption energy with important figures of merit, so aquisition of it is an important task.","type":"content","url":"/oc20dense#overview","position":3},{"hierarchy":{"lvl1":"Open Catalyst 2020 Dense (OC20Dense)","lvl2":"File Contents and Download"},"type":"lvl2","url":"/oc20dense#file-contents-and-download","position":4},{"hierarchy":{"lvl1":"Open Catalyst 2020 Dense (OC20Dense)","lvl2":"File Contents and Download"},"content":"Splits\n\nSize of compressed version (in bytes)\n\nSize of uncompressed version (in bytes)\n\nMD5 checksum (download link)\n\nLMDB\n\n654M\n\n9.8G\n\n0163b0e8c4df6d9c426b875a28d9178a\n\nASE Trajectories\n\n29G\n\n112G\n\nee937e5290f8f720c914dc9a56e0281f\n\nThe following files are also provided to be used for evaluation and general information:\n\noc20dense_mapping.pkl : Mapping of the LMDB sid to general metadata information. If this file is not present, run the command python src/fairchem/core/scripts/download_large_files.py adsorbml from the root of the fairchem repo to download it. -\n\nsystem_id: Unique system identifier for an adsorbate, bulk, surface combination.\n\nconfig_id: Unique configuration identifier, where rand and heur correspond to random and heuristic initial configurations, respectively.\n\nmpid: Materials Project bulk identifier.\n\nmiller_idx: 3-tuple of integers indicating the Miller indices of the surface.\n\nshift: C-direction shift used to determine cutoff for the surface (c-direction is following the nomenclature from Pymatgen).\n\ntop: Boolean indicating whether the chosen surface was at the top or bottom of the originally enumerated surface.\n\nadsorbate: Chemical composition of the adsorbate.\n\nadsorption_site: A tuple of 3-tuples containing the Cartesian coordinates of each binding adsorbate atom\n\noc20dense_targets.pkl :  DFT adsorption energies across different system and placement ids.\n\noc20dense_compute.pkl :  DFT compute as measured in the number of ionic and scf steps for each evaluated relaxation.\n\noc20dense_ref_energies.pkl : Reference energy used for a specified system_id. This energy includes the relaxed clean surface and the gas phase adsorbate energy to ensure consistency across calculations.\n\noc20dense_tags.pkl : Tag information used for a specified system_id. Where 0 = subsurface, 1 = surface, 2 = adsorbate.\n\nAll mappings can be obtained at the following downloadable link: \n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/adsorbml​/oc20​_dense​_mappings​.tar​.gz\n\nMD5 checksums:c18735c405ce6ce5761432b07287d8d9  oc20_dense_mappings.tar.gz\n3e26c3bcef01ccfc9b001931065ea6e6  oc20dense_mapping.pkl\nfd589b013b72e62e11a6b2a5bd1d323c  oc20dense_targets.pkl\n78d25997e0aaf754df526ab37276bb89  oc20dense_compute.pkl\nb07c64158e4bfa5f7b9bf6263753ecc5  oc20dense_ref_energies.pkl\n1ba0bc266130f186850f5faa547b6a02  oc20dense_tags.pkl","type":"content","url":"/oc20dense#file-contents-and-download","position":5},{"hierarchy":{"lvl1":"Open Catalyst 2020 Nudged Elastic Band (OC20NEB)"},"type":"lvl1","url":"/oc20neb","position":0},{"hierarchy":{"lvl1":"Open Catalyst 2020 Nudged Elastic Band (OC20NEB)"},"content":"Dataset Overview\n\nProperty\n\nValue\n\nSize\n\n932 NEB relaxation trajectories\n\nReaction Types\n\nDesorptions, Dissociations, Transfers\n\nPurpose\n\nTransition state energy calculations\n\nPaper\n\nCatTSunami (arXiv)\n\nLicense\n\nCC-BY-4.0","type":"content","url":"/oc20neb","position":1},{"hierarchy":{"lvl1":"Open Catalyst 2020 Nudged Elastic Band (OC20NEB)","lvl2":"Overview"},"type":"lvl2","url":"/oc20neb#overview","position":2},{"hierarchy":{"lvl1":"Open Catalyst 2020 Nudged Elastic Band (OC20NEB)","lvl2":"Overview"},"content":"This is a validation dataset which was used to assess model performance in \n\nCatTSunami: Accelerating Transition State Energy Calculations with Pre-trained Graph Neural Networks. It is comprised of 932 NEB relaxation trajectories. There are three different types of reactions represented: desorptions, dissociations, and transfers. NEB calculations allow us to find transition states. The rate of reaction is determined by the transition state energy, so access to transition states is very important for catalysis research. For more information, check out the paper.","type":"content","url":"/oc20neb#overview","position":3},{"hierarchy":{"lvl1":"Open Catalyst 2020 Nudged Elastic Band (OC20NEB)","lvl2":"File Structure and Contents"},"type":"lvl2","url":"/oc20neb#file-structure-and-contents","position":4},{"hierarchy":{"lvl1":"Open Catalyst 2020 Nudged Elastic Band (OC20NEB)","lvl2":"File Structure and Contents"},"content":"The tar file contains 3 subdirectories: dissociations, desorptions, and transfers. As the names imply, these directories contain the converged DFT trajectories for each of the reaction classes. Within these directories, the trajectories are named to identify the contents of the file. Here is an example and the anatomy of the name:\n\ndesorption_id_83_2409_9_111-4_neb1.0.traj\n\ndesorption indicates the reaction type (dissociation and transfer are the other possibilities)\n\nid identifies that the material belongs to the validation in domain split (ood - out of domain is th e other possibility)\n\n83 is the task id. This does not provide relavent information\n\n2409 is the bulk index of the bulk used in the ocdata bulk pickle file\n\n9 is the reaction index. for each reaction type there is a reaction pickle file in the repository. In this case it is the 9th entry to that pickle file\n\n111-4 the first 3 numbers are the miller indices (i.e. the (1,1,1) surface), and the last number cooresponds to the shift value. In this case the 4th shift enumerated was the one used.\n\nneb1.0 the number here indicates the k value used. For the full dataset, 1.0 was used so this does not distiguish any of the trajectories from one another.\n\nThe content of these trajectory files is the repeating frame sets. Despite the initial and final frames not being optimized during the NEB, the initial and final frames are saved for every iteration in the trajectory. For the dataset, 10 frames were used - 8 which were optimized over the neb. So the length of the trajectory is the number of iterations (N) * 10. If you wanted to look at the frame set prior to optimization and the optimized frame set, you could get them like this:\n\nfrom __future__ import annotations\n\n!wget https://dl.fbaipublicfiles.com/opencatalystproject/data/large_files/desorption_id_83_2409_9_111-4_neb1.0.traj\n\nfrom ase.io import read\n\ntraj = read(\"desorption_id_83_2409_9_111-4_neb1.0.traj\", \":\")\nunrelaxed_frames = traj[0:10]\nrelaxed_frames = traj[-10:]\n\n\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/oc20neb#file-structure-and-contents","position":5},{"hierarchy":{"lvl1":"Open Catalyst 2020 Nudged Elastic Band (OC20NEB)","lvl2":"Download"},"type":"lvl2","url":"/oc20neb#download","position":6},{"hierarchy":{"lvl1":"Open Catalyst 2020 Nudged Elastic Band (OC20NEB)","lvl2":"Download"},"content":"Splits\n\nSize of compressed version (in bytes)\n\nSize of uncompressed version (in bytes)\n\nMD5 checksum (download link)\n\nASE Trajectories\n\n1.5G\n\n6.3G\n\n52af34a93758c82fae951e52af445089","type":"content","url":"/oc20neb#download","position":7},{"hierarchy":{"lvl1":"Open Catalyst 2020 Nudged Elastic Band (OC20NEB)","lvl2":"Use"},"type":"lvl2","url":"/oc20neb#use","position":8},{"hierarchy":{"lvl1":"Open Catalyst 2020 Nudged Elastic Band (OC20NEB)","lvl2":"Use"},"content":"One more note: We have not prepared an lmdb for this dataset. This is because it is NEB calculations are not supported directly in ocp. You must use the ase native OCP class along with ase infrastructure to run NEB calculations. Here is an example of a use:\n\nimport os\n\nfrom ase.io import read\nfrom ase.mep import DyNEB\nfrom ase.optimize import BFGS\nfrom fairchem.core import FAIRChemCalculator, pretrained_mlip\n\ntraj = read(\"desorption_id_83_2409_9_111-4_neb1.0.traj\", \":\")\nimages = traj[0:10]\npredictor = pretrained_mlip.get_predict_unit(\"uma-s-1p1\")\n\nneb = DyNEB(images, k=1)\nfor image in images:\n    image.calc = FAIRChemCalculator(predictor, task_name=\"oc20\")\n\noptimizer = BFGS(\n    neb,\n    trajectory=\"neb.traj\",\n)\n\n# Use a small number of steps here to keep the docs fast during CI, but otherwise do quite reasonable settings.\nfast_docs = os.environ.get(\"FAST_DOCS\", \"false\").lower() == \"true\"\nif fast_docs:\n    optimization_steps = 20\nelse:\n    optimization_steps = 300\n\nconv = optimizer.run(fmax=0.45, steps=optimization_steps)\nif conv:\n    neb.climb = True\n    conv = optimizer.run(fmax=0.05, steps=optimization_steps)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/oc20neb#use","position":9},{"hierarchy":{"lvl1":"Open Catalyst 2022 (OC22)"},"type":"lvl1","url":"/oc22","position":0},{"hierarchy":{"lvl1":"Open Catalyst 2022 (OC22)"},"content":"Dataset Overview\n\nProperty\n\nValue\n\nSize\n\n~62K oxide systems\n\nTasks\n\nS2EF-Total, IS2RE-Total, IS2RS\n\nFocus\n\nOxide electrocatalysts\n\nEnergy Type\n\nDFT total energies\n\nPaper\n\nACS Catalysis 2023\n\nLicense\n\nCC-BY-4.0\n\nNote\n\nOC22 models are trained on DFT total energies, in contrast to OC20 models which are trained on adsorption energies.","type":"content","url":"/oc22","position":1},{"hierarchy":{"lvl1":"Open Catalyst 2022 (OC22)","lvl2":"Structure to Total Energy and Forces (S2EF-Total) task"},"type":"lvl2","url":"/oc22#structure-to-total-energy-and-forces-s2ef-total-task","position":2},{"hierarchy":{"lvl1":"Open Catalyst 2022 (OC22)","lvl2":"Structure to Total Energy and Forces (S2EF-Total) task"},"content":"For this task’s train, validation and test sets, we provide precomputed LMDBs that can be directly used with dataloaders provided in our code. The LMDBs contain input structures from all points in relaxation trajectories along with the energy of the structure and the atomic forces. The validation and test datasets are broken into subsplits based on in-distribution and out-of-distribution materials relative to the training dataset. All LMDBs are compressed into a single .tar.gz file.\n\nSplits\n\nSize of compressed version (in bytes)\n\nSize of uncompressed version (in bytes)\n\nMD5 checksum (download link)\n\nTrain (all splits) + Validation (all splits) + test (all splits)\n\n20G\n\n71G\n\nebea523c6f8d61248a37b4dd660b11e6\n\n\n\n\n\n\n\n","type":"content","url":"/oc22#structure-to-total-energy-and-forces-s2ef-total-task","position":3},{"hierarchy":{"lvl1":"Open Catalyst 2022 (OC22)","lvl2":"Initial Structure to Relaxed Structure (IS2RS) and Initial Structure to Relaxed Total Energy (IS2RE-Total) tasks"},"type":"lvl2","url":"/oc22#initial-structure-to-relaxed-structure-is2rs-and-initial-structure-to-relaxed-total-energy-is2re-total-tasks","position":4},{"hierarchy":{"lvl1":"Open Catalyst 2022 (OC22)","lvl2":"Initial Structure to Relaxed Structure (IS2RS) and Initial Structure to Relaxed Total Energy (IS2RE-Total) tasks"},"content":"For IS2RE-Total / IS2RS training, validation and test sets, we provide precomputed LMDBs that can be directly used with dataloaders provided in our code. The LMDBs contain input initial structures and the output relaxed structures and energies. The validation and test datasets are broken into subsplits based on in-distribution and out-of-distribution materials relative to the training dataset. All LMDBs are compressed into a single .tar.gz file.\n\nSplits\n\nSize of compressed version (in bytes)\n\nSize of uncompressed version (in bytes)\n\nMD5 checksum (download link)\n\nTrain (all splits) + Validation (all splits) + test (all splits)\n\n109M\n\n424M\n\nb35dc24e99ef3aeaee6c5c949903de94\n\n\n\n\n\n\n\n","type":"content","url":"/oc22#initial-structure-to-relaxed-structure-is2rs-and-initial-structure-to-relaxed-total-energy-is2re-total-tasks","position":5},{"hierarchy":{"lvl1":"Open Catalyst 2022 (OC22)","lvl2":"Relaxation Trajectories"},"type":"lvl2","url":"/oc22#relaxation-trajectories","position":6},{"hierarchy":{"lvl1":"Open Catalyst 2022 (OC22)","lvl2":"Relaxation Trajectories"},"content":"","type":"content","url":"/oc22#relaxation-trajectories","position":7},{"hierarchy":{"lvl1":"Open Catalyst 2022 (OC22)","lvl3":"System trajectories (optional download)","lvl2":"Relaxation Trajectories"},"type":"lvl3","url":"/oc22#system-trajectories-optional-download","position":8},{"hierarchy":{"lvl1":"Open Catalyst 2022 (OC22)","lvl3":"System trajectories (optional download)","lvl2":"Relaxation Trajectories"},"content":"We provide relaxation trajectories for all systems used in train and validation sets of S2EF-Total and IS2RE-Total/RS task:\n\nNumber\n\nSize of compressed version (in bytes)\n\nSize of uncompressed version (in bytes)\n\nMD5 checksum (download link)\n\nS2EF and IS2RE (both train and validation)\n\n34G\n\n80G\n\n977b6be1cbac6864e63c4c7fbf8a3fce\n\n\n\n\n\n\n\n","type":"content","url":"/oc22#system-trajectories-optional-download","position":9},{"hierarchy":{"lvl1":"Open Catalyst 2022 (OC22)","lvl2":"OC22 Mappings"},"type":"lvl2","url":"/oc22#oc22-mappings","position":10},{"hierarchy":{"lvl1":"Open Catalyst 2022 (OC22)","lvl2":"OC22 Mappings"},"content":"","type":"content","url":"/oc22#oc22-mappings","position":11},{"hierarchy":{"lvl1":"Open Catalyst 2022 (OC22)","lvl3":"Data mapping information","lvl2":"OC22 Mappings"},"type":"lvl3","url":"/oc22#data-mapping-information","position":12},{"hierarchy":{"lvl1":"Open Catalyst 2022 (OC22)","lvl3":"Data mapping information","lvl2":"OC22 Mappings"},"content":"We provide a Python pickle file containing information about the slab and adsorbates for each of the systems in OC22 dataset. Loading the pickle file will load a Python dictionary. The keys of this dictionary are the system-ids (of the format XYZ  where XYZ is an integer, corresponding to the sid in the LMDB Data object), and the corresponding value of each key is a dictionary with information about:\n\nbulk_id: Materials Project ID of the bulk system used corresponding to the catalyst surface\n\nbulk_symbols: Chemical composition of the bulk counterpart\n\nmiller_index: 3-tuple of integers indicating the Miller indices of the surface\n\ntraj_id: Identifier associated with the accompanying raw trajectory (if available)\n\nslab_sid: Identifier associated with the corresponding slab (if available)\n\nads_symbols: Chemical composition of the adsorbate counterpart (adosrbate+slabs only)\n\nnads: Number of adsorbates present\n\nDownloadable link:  \n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/oc22​/oc22​_metadata​.pkl (MD5 checksum: 13dc06c6510346d8a7f614d5b26c8ffa )\n\nAn example adsorbate+slab entry: 6877: {'bulk_id': 'mp-559112',\n  'miller_index': (1, 0, 0),\n  'nads': 1,\n  'traj_id': 'K2Zn6O7_mp-559112_RyQXa0N0uc_ohyUKozY3G',\n  'bulk_symbols': 'K4Zn12O14',\n  'slab_sid': 30859,\n  'ads_symbols': 'O2'},\n\nAn example slab entry: 34815: {'bulk_id': 'mp-18793',\n  'miller_index': (1, 2, 1),\n  'nads': 0,\n  'traj_id': 'LiCrO2_mp-18793_clean_3HDHBg6TIz',\n  'bulk_symbols': 'Li2Cr2O4'},","type":"content","url":"/oc22#data-mapping-information","position":13},{"hierarchy":{"lvl1":"Open Catalyst 2022 (OC22)","lvl3":"","lvl2":"OC22 Mappings"},"type":"lvl3","url":"/oc22","position":14},{"hierarchy":{"lvl1":"Open Catalyst 2022 (OC22)","lvl3":"","lvl2":"OC22 Mappings"},"content":"","type":"content","url":"/oc22","position":15},{"hierarchy":{"lvl1":"Open Catalyst 2022 (OC22)","lvl3":"OC20 reference information","lvl2":"OC22 Mappings"},"type":"lvl3","url":"/oc22#oc20-reference-information","position":16},{"hierarchy":{"lvl1":"Open Catalyst 2022 (OC22)","lvl3":"OC20 reference information","lvl2":"OC22 Mappings"},"content":"In order to train models on OC20 total energy, we provide a Python pickle file containing the energy necessary to convert adsorption energy values to total energy. Loading the pickle file will load a Python dictionary. The keys of this dictionary are the system-ids (of the format random<XYZ>  where XYZ is an integer, corresponding to the sid in the LMDB Data object), and the corresponding value of each key is the energy to be added to OC20 energy values. To train on total energies for OC20, specify the path to this pickle file in your training configs.\n\nDownloadable link:  \n\nhttps://​dl​.fbaipublicfiles​.com​/opencatalystproject​/data​/oc22​/oc20​_ref​.pkl (MD5 checksum: 043e1e0b0cce64c62f01a8563dbc3178)","type":"content","url":"/oc22#oc20-reference-information","position":17},{"hierarchy":{"lvl1":"Open Catalyst 2022 (OC22)","lvl3":"","lvl2":"OC22 Mappings"},"type":"lvl3","url":"/oc22","position":18},{"hierarchy":{"lvl1":"Open Catalyst 2022 (OC22)","lvl3":"","lvl2":"OC22 Mappings"},"content":"","type":"content","url":"/oc22","position":19},{"hierarchy":{"lvl1":"Open Catalyst 2022 (OC22)","lvl2":"Citing OC22"},"type":"lvl2","url":"/oc22#citing-oc22","position":20},{"hierarchy":{"lvl1":"Open Catalyst 2022 (OC22)","lvl2":"Citing OC22"},"content":"The Open Catalyst 2022 (OC22) dataset is licensed under a \n\nCreative Commons Attribution 4.0 License.\n\nPlease consider citing the following paper in any research manuscript using the OC22 dataset:@article{oc22_dataset,\n    author = {Tran*, Richard and Lan*, Janice and Shuaibi*, Muhammed and Wood*, Brandon and Goyal*, Siddharth and Das, Abhishek and Heras-Domingo, Javier and Kolluru, Adeesh and Rizvi, Ammar and Shoghi, Nima and Sriram, Anuroop and Ulissi, Zachary and Zitnick, C. Lawrence},\n    title = {The Open Catalyst 2022 (OC22) dataset and challenges for oxide electrocatalysts},\n    journal = {ACS Catalysis},\n    year={2023},\n}","type":"content","url":"/oc22#citing-oc22","position":21},{"hierarchy":{"lvl1":"OC25"},"type":"lvl1","url":"/oc25","position":0},{"hierarchy":{"lvl1":"OC25"},"content":"Dataset Overview\n\nProperty\n\nValue\n\nSize\n\n~8 million DFT calculations\n\nSystems\n\n1.5 million explicit solvent environments\n\nAvg. System Size\n\n144 atoms\n\nElements\n\n88 elements\n\nDFT Level\n\nVASP with RPBE+D3 functional\n\nLicense\n\nCC-BY-4.0\n\nThe Open Catalyst 2025 (OC25) dataset consists of nearly 8 million DFT calculations across 1.5 million unique explicit solvent environments with system sizes of 144 atoms on average. This dataset represents the largest and most diverse solid-liquid interface dataset that is currently available and provides configurational and elemental diversity: spanning 88 elements, commonly used solvents/ions, varying solvent layers, and off-equilibrium sampling.\n\nThe dataset enables training of state-of-the-art machine-learned interatomic\npotentials for applications in electrocatalysis. All structures are labeled\nwith total energies (eV) and forces (eV/Angstrom) computed using VASP with the\nRPBE+D3 functional.\n\nTip\n\nAll information about the dataset is available at the\n\n\nOC25 Huggingface site.\nFor questions or issues, please open a GitHub issue in this repository.","type":"content","url":"/oc25","position":1},{"hierarchy":{"lvl1":"OC25","lvl2":"Dataset format"},"type":"lvl2","url":"/oc25#dataset-format","position":2},{"hierarchy":{"lvl1":"OC25","lvl2":"Dataset format"},"content":"The dataset is provided in ASE DB compatible lmdb files (*.aselmdb).","type":"content","url":"/oc25#dataset-format","position":3},{"hierarchy":{"lvl1":"OC25","lvl3":"Citing OC25","lvl2":"Dataset format"},"type":"lvl3","url":"/oc25#citing-oc25","position":4},{"hierarchy":{"lvl1":"OC25","lvl3":"Citing OC25","lvl2":"Dataset format"},"content":"The OC25 dataset is licensed under a \n\nCreative Commons Attribution 4.0 License.\n\nPlease consider citing the following paper in any publications that uses this dataset:@misc{oc25,\n    title={The Open Catalyst 2025 (OC25) Dataset and Models for Solid-Liquid Interfaces},\n    author={Sushree Jagriti Sahoo and Mikael Maraschin and Daniel S. Levine and Zachary Ulissi and C. Lawrence Zitnick and Joel B Varley and Joseph A. Gauthier and Nitish Govindarajan and Muhammed Shuaibi},\n    year={2025},\n    eprint={},\n    archivePrefix={arXiv},\n    primaryClass={},\n    url={},\n}","type":"content","url":"/oc25#citing-oc25","position":5},{"hierarchy":{"lvl1":"Open Catalyst Experiments 2024 (OCx24): Bridging Experiments and Computational Models"},"type":"lvl1","url":"/ocx24","position":0},{"hierarchy":{"lvl1":"Open Catalyst Experiments 2024 (OCx24): Bridging Experiments and Computational Models"},"content":"Dataset Overview\n\nProperty\n\nValue\n\nType\n\nExperimental + Computational\n\nReactions\n\nHER, CO2 electrochemical reduction\n\nData\n\nXRF, XRD, electrochemical testing\n\nPaper\n\narXiv:2411.11783\n\nLicense\n\nCC-BY-4.0\n\nIn this work, we seek to directly bridge the gap between computational descriptors and experimental outcomes for heterogeneous catalysis. We consider two important green chemistries: the hydrogen evolution reaction and the electrochemical reduction of carbon dioxide. To do this, we created a curated dataset of experimental results with materials synthesized and tested in a reproducible manner under industrially relevant conditions. We used this data to build models to directly predict experimental outcomes using computational features. For more information, please read the manuscript \n\npaper.","type":"content","url":"/ocx24","position":1},{"hierarchy":{"lvl1":"Open Catalyst Experiments 2024 (OCx24): Bridging Experiments and Computational Models","lvl2":"Experimental datasets"},"type":"lvl2","url":"/ocx24#experimental-datasets","position":2},{"hierarchy":{"lvl1":"Open Catalyst Experiments 2024 (OCx24): Bridging Experiments and Computational Models","lvl2":"Experimental datasets"},"content":"To support this work, we performed X-ray fluorescence (XRF), X-ray diffraction (XRD), and electrochemical testing. Summaries of this data is all publically available \n\nhere.","type":"content","url":"/ocx24#experimental-datasets","position":3},{"hierarchy":{"lvl1":"Open Catalyst Experiments 2024 (OCx24): Bridging Experiments and Computational Models","lvl2":"Computational datasets"},"type":"lvl2","url":"/ocx24#computational-datasets","position":4},{"hierarchy":{"lvl1":"Open Catalyst Experiments 2024 (OCx24): Bridging Experiments and Computational Models","lvl2":"Computational datasets"},"content":"Splits\n\nSize of uncompressed version (in bytes)\n\nMD5 checksum (download link)\n\nComputational screening data\n\n1.5G\n\n9e75b95bb1a2ae691f07cf630eac3378","type":"content","url":"/ocx24#computational-datasets","position":5},{"hierarchy":{"lvl1":"Open Catalyst Experiments 2024 (OCx24): Bridging Experiments and Computational Models","lvl2":"Citing this work"},"type":"lvl2","url":"/ocx24#citing-this-work","position":6},{"hierarchy":{"lvl1":"Open Catalyst Experiments 2024 (OCx24): Bridging Experiments and Computational Models","lvl2":"Citing this work"},"content":"If you use this codebase in your work, please consider citing:@misc{abed2024opencatalystexperiments2024,\n      title={Open Catalyst Experiments 2024 (OCx24): Bridging Experiments and Computational Models}, \n      author={Jehad Abed and Jiheon Kim and Muhammed Shuaibi and Brook Wander and Boris Duijf and Suhas Mahesh and Hyeonseok Lee and Vahe Gharakhanyan and Sjoerd Hoogland and Erdem Irtem and Janice Lan and Niels Schouten and Anagha Usha Vijayakumar and Jason Hattrick-Simpers and John R. Kitchin and Zachary W. Ulissi and Aaike van Vugt and Edward H. Sargent and David Sinton and C. Lawrence Zitnick},\n      year={2024},\n      eprint={2411.11783},\n      archivePrefix={arXiv},\n      primaryClass={cond-mat.mtrl-sci},\n      url={https://arxiv.org/abs/2411.11783}, \n}","type":"content","url":"/ocx24#citing-this-work","position":7},{"hierarchy":{"lvl1":"Datasets"},"type":"lvl1","url":"/summary-3","position":0},{"hierarchy":{"lvl1":"Datasets"},"content":"\n\nThis section provides documentation for all catalyst-related datasets in the Open Catalyst Project. These datasets are used to train and evaluate machine learning models for heterogeneous catalysis applications.\n\nTip\n\nFor most new users, we recommend starting with the \n\nUMA model, which has been trained on all of these datasets and provides state-of-the-art performance.\n\nOC20\n\nThe foundational Open Catalyst 2020 dataset with 133M+ DFT calculations for adsorbate-surface systems.\n\nOC20-mAds\n\nMulti-adsorbate extension of OC20 including coverage effects on catalyst surfaces.\n\nOC20Dense\n\nDense sampling of adsorbate configurations for adsorption energy calculations.\n\nOC20NEB\n\nNEB trajectories for transition state calculations including desorptions, dissociations, and transfers.\n\nOC22\n\nOpen Catalyst 2022 dataset focusing on oxide electrocatalysts with total energy predictions.\n\nOC25\n\nSolid-liquid interface dataset with 8M DFT calculations for electrocatalysis applications.\n\nOCx24\n\nExperimental validation dataset bridging computational and experimental catalysis research.","type":"content","url":"/summary-3","position":1},{"hierarchy":{"lvl1":"Intro to Adsorption Energies"},"type":"lvl1","url":"/ocp-introduction","position":0},{"hierarchy":{"lvl1":"Intro to Adsorption Energies"},"content":"Tutorial Overview\n\nProperty\n\nValue\n\nDifficulty\n\nBeginner\n\nTime\n\n15-30 minutes\n\nPrerequisites\n\nBasic Python, familiarity with ASE\n\nGoal\n\nCalculate adsorption energies using UMA models\n\nTo introduce OCP we start with using it to calculate adsorption energies for a simple, atomic adsorbate where we specify the site we want to the adsorption energy for. Conceptually, you do this like you would do it with density functional theory. You create a slab model for the surface, place an adsorbate on it as an initial guess, run a relaxation to get the lowest energy geometry, and then compute the adsorption energy using reference states for the adsorbate.\n\nImportant\n\nSome OCP model/checkpoint combinations return a total energy like density functional theory would, but some return an “adsorption energy” directly. You have to know which one you are using. In this example, the model we use returns an “adsorption energy”.\n\n","type":"content","url":"/ocp-introduction","position":1},{"hierarchy":{"lvl1":"Intro to Adsorption Energies","lvl2":"Intro to Adsorption energies"},"type":"lvl2","url":"/ocp-introduction#intro-to-adsorption-energies","position":2},{"hierarchy":{"lvl1":"Intro to Adsorption Energies","lvl2":"Intro to Adsorption energies"},"content":"Adsorption energies are always a reaction energy (an adsorbed species relative to some implied combination of reactants). There are many common schemes in the catalysis literature.\n\nFor example, you may want the adsorption energy of oxygen, and you might compute that from this reaction:1/2 O2 + slab -> slab-O\n\nDFT has known errors with the energy of a gas-phase O2 molecule, so it’s more common to compute this energy relative to a linear combination of H2O and H2. The suggested reference scheme for consistency with OC20 is a reactionx CO + (x + y/2 - z) H2 + (z-x) H2O + w/2 N2 + * -> CxHyOzNw*\n\nHere, x=y=w=0, z=1, so the reaction ends up as-H2 + H2O + * -> O*\n\nor alternatively,H2O + * -> O* + H2\n\nIt is possible through thermodynamic cycles to compute other reactions. If we can look up rH1 below and compute rH2H2 + 1/2 O2 -> H2O  re1 = -3.03 eV, from exp\nH2O + * -> O* + H2  re2  # Get from UMA\n\nThen, the adsorption energy for1/2O2 + * -> O*\n\nis just re1 + re2.\n\nBased on \n\nhttps://atct.anl.gov/Thermochemical Data/version 1.118/species/?species_number=986, the formation energy of water is about -3.03 eV at standard state experimentally. You could also compute this using DFT, but you would probably get the wrong answer for this.\n\nThe first step is getting a checkpoint for the model we want to use. UMA is currently the state-of-the-art model and will provide total energy estimates at the RPBE level of theory if you use the “OC20” task.\n\nNeed to install fairchem-core or get UMA access or getting permissions/401 errors?\n\nInstall the necessary packages using pip, uv etc\n\n! pip install fairchem-core fairchem-data-oc fairchem-applications-cattsunami\n\n\n\nGet access to any necessary huggingface gated models\n\nGet and login to your Huggingface account\n\nRequest access to \n\nhttps://​huggingface​.co​/facebook​/UMA\n\nCreate a Huggingface token at \n\nhttps://​huggingface​.co​/settings​/tokens/ with the permission “Permissions: Read access to contents of all public gated repos you can access”\n\nAdd the token as an environment variable using huggingface-cli login or by setting the HF_TOKEN environment variable.\n\n# Login using the huggingface-cli utility\n! huggingface-cli login\n\n# alternatively,\nimport os\nos.environ['HF_TOKEN'] = 'MY_TOKEN'\n\n\n\nIf you find your kernel is crashing, it probably means you have exceeded the allowed amount of memory. This checkpoint works fine in this example, but it may crash your kernel if you use it in the NRR example.\n\nThis next cell will automatically download the checkpoint from huggingface and load it.\n\nfrom __future__ import annotations\n\nfrom fairchem.core import FAIRChemCalculator, pretrained_mlip\n\npredictor = pretrained_mlip.get_predict_unit(\"uma-s-1p1\")\ncalc = FAIRChemCalculator(predictor, task_name=\"oc20\")\n\n\n\nNext we can build a slab with an adsorbate on it. Here we use the ASE module to build a Pt slab. We use the experimental lattice constant that is the default. This can introduce some small errors with DFT since the lattice constant can differ by a few percent, and it is common to use DFT lattice constants. In this example, we do not constrain any layers.\n\nfrom ase.build import add_adsorbate, fcc111\nfrom ase.optimize import BFGS\n\n\n\n\n\n# reference energies from a linear combination of H2O/N2/CO/H2!\natomic_reference_energies = {\n    \"H\": -3.477,\n    \"N\": -8.083,\n    \"O\": -7.204,\n    \"C\": -7.282,\n}\n\nre1 = -3.03\n\nslab = fcc111(\"Pt\", size=(2, 2, 5), vacuum=20.0)\nslab.pbc = True\n\nadslab = slab.copy()\nadd_adsorbate(adslab, \"O\", height=1.2, position=\"fcc\")\n\nslab.set_calculator(calc)\nopt = BFGS(slab)\nopt.run(fmax=0.05, steps=100)\nslab_e = slab.get_potential_energy()\n\nadslab.set_calculator(calc)\nopt = BFGS(adslab)\nopt.run(fmax=0.05, steps=100)\nadslab_e = adslab.get_potential_energy()\n\n# Energy for ((H2O-H2) + * -> *O) + (H2 + 1/2O2 -> H2) leads to 1/2O2 + * -> *O!\nadslab_e - slab_e - atomic_reference_energies[\"O\"] + re1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIt is good practice to look at your geometries to make sure they are what you expect.\n\nimport matplotlib.pyplot as plt\nfrom ase.visualize.plot import plot_atoms\n\nfig, axs = plt.subplots(1, 2)\nplot_atoms(slab, axs[0])\nplot_atoms(slab, axs[1], rotation=(\"-90x\"))\naxs[0].set_axis_off()\naxs[1].set_axis_off()\n\n\n\n\n\nimport matplotlib.pyplot as plt\nfrom ase.visualize.plot import plot_atoms\n\nfig, axs = plt.subplots(1, 2)\nplot_atoms(adslab, axs[0])\nplot_atoms(adslab, axs[1], rotation=(\"-90x\"))\naxs[0].set_axis_off()\naxs[1].set_axis_off()\n\n\n\nHow did we do? We need a reference point. In the paper below, there is an atomic adsorption energy for O on Pt(111) of about -4.264 eV. This is for the reaction O + * -> O*. To convert this to the dissociative adsorption energy, we have to add the reaction:1/2 O2 -> O   D = 2.58 eV (expt)\n\nto get a comparable energy of about -1.68 eV. There is about ~0.2 eV difference (we predicted -1.47 eV above, and the reference comparison is -1.68 eV) to account for. The biggest difference is likely due to the differences in exchange-correlation functional. The reference data used the PBE functional, and eSCN was trained on RPBE data. To additional places where there are differences include:\n\nDifference in lattice constant\n\nThe reference energy used for the experiment references. These can differ by up to 0.5 eV from comparable DFT calculations.\n\nHow many layers are relaxed in the calculation\n\nSome of these differences tend to be systematic, and you can calibrate and correct these, especially if you can augment these with your own DFT calculations.\n\nSee \n\nconvergence study for some additional studies of factors that influence this number.\n\n","type":"content","url":"/ocp-introduction#intro-to-adsorption-energies","position":3},{"hierarchy":{"lvl1":"Intro to Adsorption Energies","lvl3":"Exercises","lvl2":"Intro to Adsorption energies"},"type":"lvl3","url":"/ocp-introduction#exercises","position":4},{"hierarchy":{"lvl1":"Intro to Adsorption Energies","lvl3":"Exercises","lvl2":"Intro to Adsorption energies"},"content":"Explore the effect of the lattice constant on the adsorption energy.\n\nTry different sites, including the bridge and top sites. Compare the energies, and inspect the resulting geometries.\n\n","type":"content","url":"/ocp-introduction#exercises","position":5},{"hierarchy":{"lvl1":"Intro to Adsorption Energies","lvl2":"Trends in adsorption energies across metals."},"type":"lvl2","url":"/ocp-introduction#trends-in-adsorption-energies-across-metals","position":6},{"hierarchy":{"lvl1":"Intro to Adsorption Energies","lvl2":"Trends in adsorption energies across metals."},"content":"Xu, Z., & Kitchin, J. R. (2014). Probing the coverage dependence of site and adsorbate configurational correlations on (111) surfaces of late transition metals. J. Phys. Chem. C, 118(44), 25597–25602. \n\nXu & Kitchin (2014)\n\nSupporting information.\n\nThese are atomic adsorption energies:O + * -> O*\n\nWe have to do some work to get comparable numbers from OCPH2 + 1/2 O2 -> H2O  re1 = -3.03 eV\nH2O + * -> O* + H2  re2   # Get from UMA\nO -> 1/2 O2         re3 = -2.58 eV\n\nThen, the adsorption energy forO + * -> O*\n\nis just re1 + re2 + re3.\n\nHere we just look at the fcc site on Pt. First, we get the data stored in the paper.\n\nNext we get the structures and compute their energies. Some subtle points are that we have to account for stoichiometry, and normalize the adsorption energy by the number of oxygens.\n\nFirst we get a reference energy from the paper (PBE, 0.25 ML O on Pt(111)).\n\nimport json\n\nwith open(\"energies.json\") as f:\n    edata = json.load(f)\n\nwith open(\"structures.json\") as f:\n    sdata = json.load(f)\n\nedata[\"Pt\"][\"O\"][\"fcc\"][\"0.25\"]\n\n\n\nNext, we load data from the SI to get the geometry to start from.\n\nwith open(\"structures.json\") as f:\n    s = json.load(f)\n\nsfcc = s[\"Pt\"][\"O\"][\"fcc\"][\"0.25\"]\n\n\n\nNext, we construct the atomic geometry, run the geometry optimization, and compute the energy.\n\nre3 = -2.58  # O -> 1/2 O2         re3 = -2.58 eV\n\nfrom ase import Atoms\n\nadslab = Atoms(sfcc[\"symbols\"], positions=sfcc[\"pos\"], cell=sfcc[\"cell\"], pbc=True)\n\n# Grab just the metal surface atoms\nslab = adslab[adslab.arrays[\"numbers\"] == adslab.arrays[\"numbers\"][0]]\nadsorbates = adslab[~(adslab.arrays[\"numbers\"] == adslab.arrays[\"numbers\"][0])]\nslab.set_calculator(calc)\nopt = BFGS(slab)\nopt.run(fmax=0.05, steps=100)\n\nadslab.set_calculator(calc)\nopt = BFGS(adslab)\n\nopt.run(fmax=0.05, steps=100)\nre2 = (\n    adslab.get_potential_energy()\n    - slab.get_potential_energy()\n    - sum([atomic_reference_energies[x] for x in adsorbates.get_chemical_symbols()])\n)\n\nnO = 0\nfor atom in adslab:\n    if atom.symbol == \"O\":\n        nO += 1\n        re2 += re1 + re3\n\nprint(re2 / nO)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/ocp-introduction#trends-in-adsorption-energies-across-metals","position":7},{"hierarchy":{"lvl1":"Intro to Adsorption Energies","lvl3":"Site correlations","lvl2":"Trends in adsorption energies across metals."},"type":"lvl3","url":"/ocp-introduction#site-correlations","position":8},{"hierarchy":{"lvl1":"Intro to Adsorption Energies","lvl3":"Site correlations","lvl2":"Trends in adsorption energies across metals."},"content":"This cell reproduces a portion of a figure in the paper. We compare oxygen adsorption energies in the fcc and hcp sites across metals and coverages. These adsorption energies are highly correlated with each other because the adsorption sites are so similar.\n\nAt higher coverages, the agreement is not as good. This is likely because the model is extrapolating and needs to be fine-tuned.\n\nimport time\n\nfrom tqdm import tqdm\n\nt0 = time.time()\n\ndata = {\"fcc\": [], \"hcp\": []}\n\nrefdata = {\"fcc\": [], \"hcp\": []}\n\n\nfor metal in [\"Cu\", \"Ag\", \"Pd\", \"Pt\", \"Rh\", \"Ir\"]:\n    print(metal)\n    for site in [\"fcc\", \"hcp\"]:\n        for adsorbate in [\"O\"]:\n            for coverage in tqdm([\"0.25\"]):\n\n                entry = s[metal][adsorbate][site][coverage]\n\n                adslab = Atoms(\n                    entry[\"symbols\"],\n                    positions=entry[\"pos\"],\n                    cell=entry[\"cell\"],\n                    pbc=True,\n                )\n\n                # Grab just the metal surface atoms\n                adsorbates = adslab[\n                    ~(adslab.arrays[\"numbers\"] == adslab.arrays[\"numbers\"][0])\n                ]\n\n                slab = adslab[adslab.arrays[\"numbers\"] == adslab.arrays[\"numbers\"][0]]\n                slab.set_calculator(calc)\n                opt = BFGS(slab)\n                opt.run(fmax=0.05, steps=100)\n\n                adslab.set_calculator(calc)\n                opt = BFGS(adslab)\n                opt.run(fmax=0.05, steps=100)\n\n                re2 = (\n                    adslab.get_potential_energy()\n                    - slab.get_potential_energy()\n                    - sum(\n                        [\n                            atomic_reference_energies[x]\n                            for x in adsorbates.get_chemical_symbols()\n                        ]\n                    )\n                )\n\n                nO = 0\n                for atom in adslab:\n                    if atom.symbol == \"O\":\n                        nO += 1\n                        re2 += re1 + re3\n\n                data[site] += [re2 / nO]\n                refdata[site] += [edata[metal][adsorbate][site][coverage]]\n\nf\"Elapsed time = {time.time() - t0} seconds\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFirst, we compare the computed data and reference data. There is a systematic difference of about 0.5 eV due to the difference between RPBE and PBE functionals, and other subtle differences like lattice constant differences and reference energy differences. This is pretty typical, and an expected deviation.\n\nplt.plot(refdata[\"fcc\"], data[\"fcc\"], \"r.\", label=\"fcc\")\nplt.plot(refdata[\"hcp\"], data[\"hcp\"], \"b.\", label=\"hcp\")\nplt.plot([-5.5, -3.5], [-5.5, -3.5], \"k-\")\nplt.xlabel(\"Ref. data (DFT)\")\nplt.ylabel(\"UMA-OC20 prediction\");\n\n\n\nNext we compare the correlation between the hcp and fcc sites. Here we see the same trends. The data falls below the parity line because the hcp sites tend to be a little weaker binding than the fcc sites.\n\nplt.plot(refdata[\"hcp\"], refdata[\"fcc\"], \"r.\")\nplt.plot(data[\"hcp\"], data[\"fcc\"], \".\")\nplt.plot([-6, -1], [-6, -1], \"k-\")\nplt.xlabel(\"$H_{ads, hcp}$\")\nplt.ylabel(\"$H_{ads, fcc}$\")\nplt.legend([\"DFT (PBE)\", \"UMA-OC20\"]);\n\n\n\n","type":"content","url":"/ocp-introduction#site-correlations","position":9},{"hierarchy":{"lvl1":"Intro to Adsorption Energies","lvl3":"Exercises","lvl2":"Trends in adsorption energies across metals."},"type":"lvl3","url":"/ocp-introduction#exercises-1","position":10},{"hierarchy":{"lvl1":"Intro to Adsorption Energies","lvl3":"Exercises","lvl2":"Trends in adsorption energies across metals."},"content":"You can also explore a few other adsorbates: C, H, N.\n\nExplore the higher coverages. The deviations from the reference data are expected to be higher, but relative differences tend to be better. You probably need fine tuning to improve this performance. This data set doesn’t have forces though, so it isn’t practical to do it here.\n\n","type":"content","url":"/ocp-introduction#exercises-1","position":11},{"hierarchy":{"lvl1":"Intro to Adsorption Energies","lvl2":"Next steps"},"type":"lvl2","url":"/ocp-introduction#next-steps","position":12},{"hierarchy":{"lvl1":"Intro to Adsorption Energies","lvl2":"Next steps"},"content":"In the next step, we consider some more complex adsorbates in nitrogen reduction, and how we can leverage OCP to automate the search for the most stable adsorbate geometry. See \n\nthe next step.\n\n","type":"content","url":"/ocp-introduction#next-steps","position":13},{"hierarchy":{"lvl1":"Intro to Adsorption Energies","lvl3":"Convergence study","lvl2":"Next steps"},"type":"lvl3","url":"/ocp-introduction#convergence-study","position":14},{"hierarchy":{"lvl1":"Intro to Adsorption Energies","lvl3":"Convergence study","lvl2":"Next steps"},"content":"In \n\nthe adsorption energies section we discussed some possible reasons we might see a discrepancy. Here we investigate some factors that impact the computed energies.\n\nIn this section, the energies refer to the reaction 1/2 O2 -> O*.\n\n","type":"content","url":"/ocp-introduction#convergence-study","position":15},{"hierarchy":{"lvl1":"Intro to Adsorption Energies","lvl3":"Effects of number of layers","lvl2":"Next steps"},"type":"lvl3","url":"/ocp-introduction#effects-of-number-of-layers","position":16},{"hierarchy":{"lvl1":"Intro to Adsorption Energies","lvl3":"Effects of number of layers","lvl2":"Next steps"},"content":"Slab thickness could be a factor. Here we relax the whole slab, and see by about 4 layers the energy is converged to ~0.02 eV.\n\nfor nlayers in [3, 4, 5, 6, 7, 8]:\n    slab = fcc111(\"Pt\", size=(2, 2, nlayers), vacuum=10.0)\n\n    slab.pbc = True\n    slab.set_calculator(calc)\n    opt_slab = BFGS(slab, logfile=None)\n    opt_slab.run(fmax=0.05, steps=100)\n    slab_e = slab.get_potential_energy()\n\n    adslab = slab.copy()\n    add_adsorbate(adslab, \"O\", height=1.2, position=\"fcc\")\n\n    adslab.pbc = True\n    adslab.set_calculator(calc)\n    opt_adslab = BFGS(adslab, logfile=None)\n    opt_adslab.run(fmax=0.05, steps=100)\n    adslab_e = adslab.get_potential_energy()\n\n    print(\n        f\"nlayers = {nlayers}: {adslab_e - slab_e - atomic_reference_energies['O'] + re1:1.2f} eV\"\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/ocp-introduction#effects-of-number-of-layers","position":17},{"hierarchy":{"lvl1":"Intro to Adsorption Energies","lvl3":"Effects of relaxation","lvl2":"Next steps"},"type":"lvl3","url":"/ocp-introduction#effects-of-relaxation","position":18},{"hierarchy":{"lvl1":"Intro to Adsorption Energies","lvl3":"Effects of relaxation","lvl2":"Next steps"},"content":"It is common to only relax a few layers, and constrain lower layers to bulk coordinates. We do that here. We only relax the adsorbate and the top layer.\n\nThis has a small effect (0.1 eV).\n\nfrom ase.constraints import FixAtoms\n\nfor nlayers in [3, 4, 5, 6, 7, 8]:\n    slab = fcc111(\"Pt\", size=(2, 2, nlayers), vacuum=10.0)\n\n    slab.set_constraint(FixAtoms(mask=[atom.tag > 1 for atom in slab]))\n    slab.pbc = True\n    slab.set_calculator(calc)\n    opt_slab = BFGS(slab, logfile=None)\n    opt_slab.run(fmax=0.05, steps=100)\n    slab_e = slab.get_potential_energy()\n\n    adslab = slab.copy()\n    add_adsorbate(adslab, \"O\", height=1.2, position=\"fcc\")\n\n    adslab.set_constraint(FixAtoms(mask=[atom.tag > 1 for atom in adslab]))\n    adslab.pbc = True\n    adslab.set_calculator(calc)\n    opt_adslab = BFGS(adslab, logfile=None)\n    opt_adslab.run(fmax=0.05, steps=100)\n    adslab_e = adslab.get_potential_energy()\n\n    print(\n        f\"nlayers = {nlayers}: {adslab_e - slab_e - atomic_reference_energies['O'] + re1:1.2f} eV\"\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/ocp-introduction#effects-of-relaxation","position":19},{"hierarchy":{"lvl1":"Intro to Adsorption Energies","lvl3":"Unit cell size","lvl2":"Next steps"},"type":"lvl3","url":"/ocp-introduction#unit-cell-size","position":20},{"hierarchy":{"lvl1":"Intro to Adsorption Energies","lvl3":"Unit cell size","lvl2":"Next steps"},"content":"Coverage effects are quite noticeable with oxygen. Here we consider larger unit cells. This effect is large, and the results don’t look right, usually adsorption energies get more favorable at lower coverage, not less. This suggests fine-tuning could be important even at low coverages.\n\nfor size in [1, 2, 3, 4, 5]:\n\n    slab = fcc111(\"Pt\", size=(size, size, 5), vacuum=10.0)\n\n    slab.set_constraint(FixAtoms(mask=[atom.tag > 1 for atom in slab]))\n    slab.pbc = True\n    slab.set_calculator(calc)\n    opt_slab = BFGS(slab, logfile=None)\n    opt_slab.run(fmax=0.05, steps=100)\n    slab_e = slab.get_potential_energy()\n\n    adslab = slab.copy()\n    add_adsorbate(adslab, \"O\", height=1.2, position=\"fcc\")\n\n    adslab.set_constraint(FixAtoms(mask=[atom.tag > 1 for atom in adslab]))\n    adslab.pbc = True\n    adslab.set_calculator(calc)\n    opt_adslab = BFGS(adslab, logfile=None)\n    opt_adslab.run(fmax=0.05, steps=100)\n    adslab_e = adslab.get_potential_energy()\n\n    print(\n        f\"({size}x{size}): {adslab_e - slab_e - atomic_reference_energies['O'] + re1:1.2f} eV\"\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/ocp-introduction#unit-cell-size","position":21},{"hierarchy":{"lvl1":"Intro to Adsorption Energies","lvl2":"Summary"},"type":"lvl2","url":"/ocp-introduction#summary","position":22},{"hierarchy":{"lvl1":"Intro to Adsorption Energies","lvl2":"Summary"},"content":"As with DFT, you should take care to see how these kinds of decisions affect your results, and determine if they would change any interpretations or not.","type":"content","url":"/ocp-introduction#summary","position":23},{"hierarchy":{"lvl1":"AdsorbML Tutorial"},"type":"lvl1","url":"/adsorbml-walkthrough","position":0},{"hierarchy":{"lvl1":"AdsorbML Tutorial"},"content":"Tutorial Overview\n\nProperty\n\nValue\n\nDifficulty\n\nIntermediate\n\nTime\n\n20-30 minutes\n\nPrerequisites\n\nBasic Python, ASE\n\nGoal\n\nFind optimal adsorption sites using ML-accelerated relaxations\n\nThe \n\nAdsorbML paper showed that pre-trained machine learning potentials were now viable to find and prioritize the best adsorption sites for a given surface. The results were quite impressive, especially if you were willing to do a DFT single-point calculation on the best calculations.\n\nThe latest UMA models are now total-energy models, and the results for the adsorption energy are even more impressive (\n\nsee the paper for details and benchmarks). The AdsorbML package helps you with automated multi-adsorbate placement, and will automatically run calculations using the ML models to find the best sites to sample.\n\nNeed to install fairchem-core or get UMA access or getting permissions/401 errors?\n\nInstall the necessary packages using pip, uv etc\n\n! pip install fairchem-core fairchem-data-oc fairchem-applications-cattsunami\n\n\n\nGet access to any necessary huggingface gated models\n\nGet and login to your Huggingface account\n\nRequest access to \n\nhttps://​huggingface​.co​/facebook​/UMA\n\nCreate a Huggingface token at \n\nhttps://​huggingface​.co​/settings​/tokens/ with the permission “Permissions: Read access to contents of all public gated repos you can access”\n\nAdd the token as an environment variable using huggingface-cli login or by setting the HF_TOKEN environment variable.\n\n# Login using the huggingface-cli utility\n! huggingface-cli login\n\n# alternatively,\nimport os\nos.environ['HF_TOKEN'] = 'MY_TOKEN'\n\n","type":"content","url":"/adsorbml-walkthrough","position":1},{"hierarchy":{"lvl1":"AdsorbML Tutorial","lvl2":"Define desired adsorbate+slab system"},"type":"lvl2","url":"/adsorbml-walkthrough#define-desired-adsorbate-slab-system","position":2},{"hierarchy":{"lvl1":"AdsorbML Tutorial","lvl2":"Define desired adsorbate+slab system"},"content":"\n\nfrom __future__ import annotations\n\nimport pandas as pd\nfrom fairchem.data.oc.core import Adsorbate, Bulk, Slab\n\nbulk_src_id = \"mp-30\"\nadsorbate_smiles = \"*CO\"\n\nbulk = Bulk(bulk_src_id_from_db=bulk_src_id)\nadsorbate = Adsorbate(adsorbate_smiles_from_db=adsorbate_smiles)\nslabs = Slab.from_bulk_get_specific_millers(bulk=bulk, specific_millers=(1, 1, 1))\n\n# There may be multiple slabs with this miller index.\n# For demonstrative purposes we will take the first entry.\nslab = slabs[0]\n\n\n\n","type":"content","url":"/adsorbml-walkthrough#define-desired-adsorbate-slab-system","position":3},{"hierarchy":{"lvl1":"AdsorbML Tutorial","lvl2":"Run heuristic/random adsorbate placement and ML relaxations"},"type":"lvl2","url":"/adsorbml-walkthrough#run-heuristic-random-adsorbate-placement-and-ml-relaxations","position":4},{"hierarchy":{"lvl1":"AdsorbML Tutorial","lvl2":"Run heuristic/random adsorbate placement and ML relaxations"},"content":"Now that we’ve defined the bulk, slab, and adsorbates of interest, we can quickly use the pre-trained UMA model as a calculator and the helper script fairchem.core.components.calculate.recipes.adsorbml.run_adsorbml. More details on the automated pipeline can be found at \n\nsrc​/fairchem​/core​/components​/calculate​/recipes​/adsorbml​.py.\n\nfrom ase.optimize import LBFGS\nfrom fairchem.core import FAIRChemCalculator, pretrained_mlip\nfrom fairchem.core.components.calculate.recipes.adsorbml import run_adsorbml\n\npredictor = pretrained_mlip.get_predict_unit(\"uma-s-1p1\")\ncalc = FAIRChemCalculator(predictor, task_name=\"oc20\")\n\noutputs = run_adsorbml(\n    slab=slab,\n    adsorbate=adsorbate,\n    calculator=calc,\n    optimizer_cls=LBFGS,\n    fmax=0.02,\n    steps=20,  # Increase to 200 for practical application, 20 is used for demonstrations\n    num_placements=10,  # Increase to 100 for practical application, 10 is used for demonstrations\n    reference_ml_energies=True,  # True if using a total energy model (i.e. UMA)\n    relaxed_slab_atoms=None,\n    place_on_relaxed_slab=False,\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntop_candidates = outputs[\"adslabs\"]\nglobal_min_candidate = top_candidates[0]\n\n\n\ntop_candidates = outputs[\"adslabs\"]\npd.DataFrame(top_candidates)\n\n\n\n","type":"content","url":"/adsorbml-walkthrough#run-heuristic-random-adsorbate-placement-and-ml-relaxations","position":5},{"hierarchy":{"lvl1":"AdsorbML Tutorial","lvl2":"Write VASP input files"},"type":"lvl2","url":"/adsorbml-walkthrough#write-vasp-input-files","position":6},{"hierarchy":{"lvl1":"AdsorbML Tutorial","lvl2":"Write VASP input files"},"content":"If you want to verify the results, you should run VASP. This assumes you have access to VASP pseudopotentials. The default VASP flags (which are equivalent to those used to make OC20) are located in ocdata.utils.vasp. Alternatively, you may pass your own vasp flags to the write_vasp_input_files function as vasp_flags. Note that to run this you need access to the VASP pseudopotentials and need to have those set up in ASE.\n\nimport os\n\nfrom fairchem.data.oc.utils.vasp import write_vasp_input_files\n\n# Grab the 5 systems with the lowest energy\ntop_5_candidates = top_candidates[:5]\n\n# Write the inputs\nfor idx, config in enumerate(top_5_candidates):\n    os.makedirs(f\"data/{idx}\", exist_ok=True)\n    write_vasp_input_files(config[\"atoms\"], outdir=f\"data/{idx}/\")\n\n","type":"content","url":"/adsorbml-walkthrough#write-vasp-input-files","position":7},{"hierarchy":{"lvl1":"Expert Adsorption Energies"},"type":"lvl1","url":"/adsorption-energies","position":0},{"hierarchy":{"lvl1":"Expert Adsorption Energies"},"content":"Tutorial Overview\n\nProperty\n\nValue\n\nDifficulty\n\nAdvanced\n\nTime\n\n45-60 minutes\n\nPrerequisites\n\nBasic catalysis knowledge, Python, ASE\n\nGoal\n\nReproduce NRR/HER selectivity literature results\n\nOne of the most common tasks in computational catalysis is calculating the binding energies or adsorption energies of small molecules on catalyst surfaces.\n\nNeed to install fairchem-core or get UMA access or getting permissions/401 errors?\n\nInstall the necessary packages using pip, uv etc\n\n! pip install fairchem-core fairchem-data-oc fairchem-applications-cattsunami\n\n\n\nGet access to any necessary huggingface gated models\n\nGet and login to your Huggingface account\n\nRequest access to \n\nhttps://​huggingface​.co​/facebook​/UMA\n\nCreate a Huggingface token at \n\nhttps://​huggingface​.co​/settings​/tokens/ with the permission “Permissions: Read access to contents of all public gated repos you can access”\n\nAdd the token as an environment variable using huggingface-cli login or by setting the HF_TOKEN environment variable.\n\n# Login using the huggingface-cli utility\n! huggingface-cli login\n\n# alternatively,\nimport os\nos.environ['HF_TOKEN'] = 'MY_TOKEN'\n\n\n\nfrom __future__ import annotations\n\nimport os\nimport pickle\nimport time\nfrom glob import glob\n\nimport ase.io\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom ase.optimize import QuasiNewton\nfrom fairchem.core import FAIRChemCalculator, pretrained_mlip\nfrom fairchem.data.oc.core import Adsorbate, AdsorbateSlabConfig, Bulk, Slab\nfrom fairchem.data.oc.utils import DetectTrajAnomaly\nfrom scipy.stats import linregress\n\n# Set random seed to ensure adsorbate enumeration yields a valid candidate\n# If using a larger number of random samples this wouldn't be necessary\nnp.random.seed(22)\n\n\n\n","type":"content","url":"/adsorption-energies","position":1},{"hierarchy":{"lvl1":"Expert Adsorption Energies","lvl2":"Introduction"},"type":"lvl2","url":"/adsorption-energies#introduction","position":2},{"hierarchy":{"lvl1":"Expert Adsorption Energies","lvl2":"Introduction"},"content":"We will reproduce Fig 6b from the following paper: Zhou, Jing, et al. “Enhanced Catalytic Activity of Bimetallic Ordered Catalysts for Nitrogen Reduction Reaction by Perturbation of Scaling Relations.” ACS Catalysis 134 (2023): 2190-2201 (\n\nZhou et al. (2023)).\n\nThe gist of this figure is a correlation between H* and NNH* adsorbates across many different alloy surfaces. Then, they identify a dividing line between these that separates surfaces known for HER and those known for NRR.\n\nTo do this, we will enumerate adsorbate-slab configurations and run ML relaxations on them to find the lowest energy configuration. We will assess parity between the model predicted values and those reported in the paper. Finally we will make the figure and assess separability of the NRR favored and HER favored domains.\n\n","type":"content","url":"/adsorption-energies#introduction","position":3},{"hierarchy":{"lvl1":"Expert Adsorption Energies","lvl2":"Enumerate the adsorbate-slab configurations to run relaxations on"},"type":"lvl2","url":"/adsorption-energies#enumerate-the-adsorbate-slab-configurations-to-run-relaxations-on","position":4},{"hierarchy":{"lvl1":"Expert Adsorption Energies","lvl2":"Enumerate the adsorbate-slab configurations to run relaxations on"},"content":"\n\nBe sure to set the path in fairchem/data/oc/configs/paths.py to point to the correct place or pass the paths as an argument. The database pickles can be found in fairchem/data/oc/databases/pkls (some pkl files are only downloaded by running the command python src/fairchem/core/scripts/download_large_files.py oc from the root of the fairchem repo). We will show one explicitly here as an example and then run all of them in an automated fashion for brevity.\n\nfrom pathlib import Path\n\nimport fairchem.data.oc\n\ndb = Path(fairchem.data.oc.__file__).parent / Path(\"databases/pkls/adsorbates.pkl\")\ndb\n\n\n\n","type":"content","url":"/adsorption-energies#enumerate-the-adsorbate-slab-configurations-to-run-relaxations-on","position":5},{"hierarchy":{"lvl1":"Expert Adsorption Energies","lvl3":"Work out a single example","lvl2":"Enumerate the adsorbate-slab configurations to run relaxations on"},"type":"lvl3","url":"/adsorption-energies#work-out-a-single-example","position":6},{"hierarchy":{"lvl1":"Expert Adsorption Energies","lvl3":"Work out a single example","lvl2":"Enumerate the adsorbate-slab configurations to run relaxations on"},"content":"We load one bulk id, create a bulk reference structure from it, then generate the surfaces we want to compute.\n\nbulk_src_id = \"oqmd-343039\"\nadsorbate_smiles_nnh = \"*N*NH\"\nadsorbate_smiles_h = \"*H\"\n\nbulk = Bulk(bulk_src_id_from_db=bulk_src_id, bulk_db_path=\"NRR_example_bulks.pkl\")\nadsorbate_H = Adsorbate(\n    adsorbate_smiles_from_db=adsorbate_smiles_h, adsorbate_db_path=db\n)\nadsorbate_NNH = Adsorbate(\n    adsorbate_smiles_from_db=adsorbate_smiles_nnh, adsorbate_db_path=db\n)\nslab = Slab.from_bulk_get_specific_millers(bulk=bulk, specific_millers=(1, 1, 1))\nslab\n\n\n\nWe now need to generate potential placements. We use two kinds of guesses, a heuristic and a random approach. This cell generates 13 potential adsorption geometries.\n\n# Perform heuristic placements\nheuristic_adslabs = AdsorbateSlabConfig(slab[0], adsorbate_H, mode=\"heuristic\")\n\n# Perform random placements\n# (for AdsorbML we use `num_sites = 100` but we will use 4 for brevity here)\nrandom_adslabs = AdsorbateSlabConfig(\n    slab[0], adsorbate_H, mode=\"random_site_heuristic_placement\", num_sites=4\n)\n\nadslabs = [*heuristic_adslabs.atoms_list, *random_adslabs.atoms_list]\nlen(adslabs)\n\n\n\nLet’s see what we are looking at. It is a little tricky to see the tiny H atom in these figures, but with some inspection you can see there are ontop, bridge, and hollow sites in different places. This is not an exhaustive search; you can increase the number of random placements to check more possibilities. The main idea here is to increase the probability you find the most relevant sites.\n\nfrom ase.visualize.plot import plot_atoms\n\nfig, axs = plt.subplots(4, 4)\n\nfor i, slab in enumerate(adslabs):\n    plot_atoms(slab, axs[i % 4, i // 4])\n    axs[i % 4, i // 4].set_axis_off()\n\nfor i in range(16):\n    axs[i % 4, i // 4].set_axis_off()\n\nplt.tight_layout()\n\n\n\n","type":"content","url":"/adsorption-energies#work-out-a-single-example","position":7},{"hierarchy":{"lvl1":"Expert Adsorption Energies","lvl4":"Run an ML relaxation","lvl3":"Work out a single example","lvl2":"Enumerate the adsorbate-slab configurations to run relaxations on"},"type":"lvl4","url":"/adsorption-energies#run-an-ml-relaxation","position":8},{"hierarchy":{"lvl1":"Expert Adsorption Energies","lvl4":"Run an ML relaxation","lvl3":"Work out a single example","lvl2":"Enumerate the adsorbate-slab configurations to run relaxations on"},"content":"We will use an ASE compatible calculator to run these.\n\nRunning the model with QuasiNewton prints at each relaxation step which is a lot to print. So we will just run one to demonstrate what happens on each iteration.\n\nos.makedirs(f\"data/{bulk_src_id}_{adsorbate_smiles_h}\", exist_ok=True)\n\n# Define the\npredictor = pretrained_mlip.get_predict_unit(\"uma-s-1p1\")\ncalc = FAIRChemCalculator(predictor, task_name=\"oc20\")\n\n\n\nNow we setup and run the relaxation.\n\nt0 = time.time()\nos.makedirs(f\"data/{bulk_src_id}_H\", exist_ok=True)\nadslab = adslabs[0]\nadslab.calc = calc\nadslab.pbc = True\nopt = QuasiNewton(adslab, trajectory=f\"data/{bulk_src_id}_H/test.traj\")\nopt.run(fmax=0.05, steps=100)\n\nprint(f\"Elapsed time {time.time() - t0:1.1f} seconds\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nWith a GPU this runs pretty quickly. It is much slower on a CPU.\n\n","type":"content","url":"/adsorption-energies#run-an-ml-relaxation","position":9},{"hierarchy":{"lvl1":"Expert Adsorption Energies","lvl2":"Run all the systems"},"type":"lvl2","url":"/adsorption-energies#run-all-the-systems","position":10},{"hierarchy":{"lvl1":"Expert Adsorption Energies","lvl2":"Run all the systems"},"content":"In principle you can run all the systems now. It takes about an hour though, and we leave that for a later exercise if you want. For now we will run the first two, and for later analysis we provide a results file of all the runs. Let’s read in our reference file and take a look at what is in it.\n\nwith open(\"NRR_example_bulks.pkl\", \"rb\") as f:\n    bulks = pickle.load(f)\n\nbulks\n\n\n\nWe have 19 bulk materials we will consider. Next we extract the src-id for each one.\n\nbulk_ids = [row[\"src_id\"] for row in bulks]\n\n\n\nIn theory you would run all of these, but it takes about an hour with a GPU. We provide the relaxation logs and trajectories in the repo for the next step.\n\nThese steps are embarrassingly parallel, and can be launched that way to speed things up. The only thing you need to watch is that you don’t exceed the available RAM, which will cause the Jupyter kernel to crash.\n\nThe goal here is to relax each candidate adsorption geometry and save the results in a trajectory file we will analyze later. Each trajectory file will have the geometry and final energy of the relaxed structure.\n\nIt is somewhat time consuming to run this. We’re going to use a small number of bulks for the testing of this documentation, but otherwise run all of the results for the actual documentation.\n\nimport os\n\nfast_docs = os.environ.get(\"FAST_DOCS\", \"false\").lower() == \"true\"\nif fast_docs:\n    num_bulks = 1\n    num_sites = 5\n    relaxation_steps = 20\nelse:\n    num_bulks = -1\n    num_sites = 20\n    relaxation_steps = 300\n\n\n\n\n\nimport random\nimport time\n\nfrom tqdm import tqdm\n\ntinit = time.time()\n\nrandom.seed(42)\nrandom.shuffle(bulk_ids)\n\n# Note we're just doing the first bulk_id!\nfor bulk_src_id in tqdm(bulk_ids[:num_bulks]):\n\n    # Set up data directories\n    os.makedirs(\"data/slabs/\", exist_ok=True)\n    os.makedirs(f\"data/adslabs/{bulk_src_id}_H\", exist_ok=True)\n    os.makedirs(f\"data/adslabs/{bulk_src_id}_NNH\", exist_ok=True)\n\n    # Enumerate slabs and establish adsorbates\n    bulk = Bulk(bulk_src_id_from_db=bulk_src_id, bulk_db_path=\"NRR_example_bulks.pkl\")\n    slab = Slab.from_bulk_get_specific_millers(bulk=bulk, specific_millers=(1, 1, 1))\n\n    slab_atoms = slab[0].atoms.copy()\n    slab_atoms.calc = calc\n    slab_atoms.pbc = True\n    opt = QuasiNewton(\n        slab_atoms,\n        trajectory=f\"data/slabs/{bulk_src_id}.traj\",\n        logfile=f\"data/slabs/{bulk_src_id}.log\",\n    )\n    opt.run(fmax=0.05, steps=relaxation_steps)\n    print(\n        f\"  Elapsed time: {time.time() - t0:1.1f} seconds for data/slabs/{bulk_src_id} slab relaxation\"\n    )\n\n    # Perform heuristic placements\n    heuristic_adslabs_H = AdsorbateSlabConfig(\n        slab[0],\n        adsorbate_H,\n        mode=\"random_site_heuristic_placement\",\n        num_sites=num_sites,\n    )\n    heuristic_adslabs_NNH = AdsorbateSlabConfig(\n        slab[0],\n        adsorbate_NNH,\n        mode=\"random_site_heuristic_placement\",\n        num_sites=num_sites,\n    )\n\n    print(f\"{len(heuristic_adslabs_H.atoms_list)} H slabs to compute for {bulk_src_id}\")\n    print(\n        f\"{len(heuristic_adslabs_NNH.atoms_list)} NNH slabs to compute for {bulk_src_id}\"\n    )\n\n    for idx, adslab in enumerate(heuristic_adslabs_H.atoms_list):\n        t0 = time.time()\n        adslab.calc = calc\n        adslab.pbc = True\n        print(f\"Running data/adslabs/{bulk_src_id}_H/{idx}\")\n        opt = QuasiNewton(\n            adslab,\n            trajectory=f\"data/adslabs/{bulk_src_id}_H/{idx}.traj\",\n            logfile=f\"data/adslabs/{bulk_src_id}_H/{idx}.log\",\n        )\n        opt.run(fmax=0.05, steps=200)\n        print(\n            f\"  Elapsed time: {time.time() - t0:1.1f} seconds for data/adslabs/{bulk_src_id}_H/{idx}\"\n        )\n\n    for idx, adslab in enumerate(heuristic_adslabs_NNH.atoms_list):\n        t0 = time.time()\n        adslab.calc = calc\n        adslab.pbc = True\n        print(f\"Running data/adslabs/{bulk_src_id}_NNH/{idx}\")\n        opt = QuasiNewton(\n            adslab,\n            trajectory=f\"data/adslabs/{bulk_src_id}_NNH/{idx}.traj\",\n            logfile=f\"data/adslabs/{bulk_src_id}_NNH/{idx}.log\",\n        )\n        opt.run(fmax=0.05, steps=relaxation_steps)\n        print(\n            f\"  Elapsed time: {time.time() - t0:1.1f} seconds for data/adslabs/{bulk_src_id}_NNH/{idx}\"\n        )\n\nprint(f\"Elapsed time: {time.time() - tinit:1.1f} seconds\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/adsorption-energies#run-all-the-systems","position":11},{"hierarchy":{"lvl1":"Expert Adsorption Energies","lvl2":"Parse the trajectories and post-process"},"type":"lvl2","url":"/adsorption-energies#parse-the-trajectories-and-post-process","position":12},{"hierarchy":{"lvl1":"Expert Adsorption Energies","lvl2":"Parse the trajectories and post-process"},"content":"As a post-processing step we check to see if:\n\nthe adsorbate desorbed\n\nthe adsorbate disassociated\n\nthe adsorbate intercalated\n\nthe surface has changed\n\nWe check these because they affect our referencing scheme and may result in energies that don’t mean what we think, e.g. they aren’t just adsorption, but include contributions from other things like desorption, dissociation or reconstruction. For (4), the relaxed surface should really be supplied as well. It will be necessary when correcting the SP / RX energies later. Since we don’t have it here, we will ommit supplying it, and the detector will instead compare the initial and final slab from the adsorbate-slab relaxation trajectory. If a relaxed slab is provided, the detector will compare it and the slab after the adsorbate-slab relaxation. The latter is more correct!\n\nTo compute the adsorption energies using the total energy UMA-OC20 model, we’ll need the gas-phase reference energies from OC20 (see the original paper!). You could also calculate these quickly in DFT using a linear combination of H2O, H2, N2, and CO.\n\n# reference energies from a linear combination of H2O/N2/CO/H2!\natomic_reference_energies = {\n    \"H\": -3.477,\n    \"N\": -8.083,\n    \"O\": -7.204,\n    \"C\": -7.282,\n}\n\n\n\nIn this loop we find the most stable (most negative) adsorption energy for each adsorbate on each surface and save them in a DataFrame.\n\n# Iterate over trajs to extract results\nmin_E = []\nfor file_outer in glob(\"data/adslabs/*\"):\n    ads = file_outer.split(\"_\")[1]\n    bulk = file_outer.split(\"/\")[-1].split(\"_\")[0]\n\n    slab = ase.io.read(f\"data/slabs/{bulk}.traj\")\n    results = []\n    for file in glob(f\"{file_outer}/*.traj\"):\n        rx_id = file.split(\"/\")[-1].split(\".\")[0]\n        traj = ase.io.read(file, \":\")\n\n        # Check to see if the trajectory is anomolous\n        detector = DetectTrajAnomaly(traj[0], traj[-1], traj[0].get_tags())\n        anom = (\n            detector.is_adsorbate_dissociated()\n            or detector.is_adsorbate_desorbed()\n            or detector.has_surface_changed()\n            or detector.is_adsorbate_intercalated()\n        )\n        rx_energy = (\n            traj[-1].get_potential_energy()\n            - slab.get_potential_energy()\n            - sum(\n                [\n                    atomic_reference_energies[x]\n                    for x in traj[0][traj[0].get_tags() == 2].get_chemical_symbols()\n                ]\n            )\n        )\n\n        results.append(\n            {\n                \"relaxation_idx\": rx_id,\n                \"relaxed_atoms\": traj[-1],\n                \"relaxed_energy_ml\": rx_energy,\n                \"anomolous\": anom,\n            }\n        )\n    df = pd.DataFrame(results)\n\n    df = df[~df.anomolous].copy().reset_index()\n    min_e = min(df.relaxed_energy_ml.tolist())\n    min_E.append({\"adsorbate\": ads, \"bulk_id\": bulk, \"min_E_ml\": min_e})\n\ndf = pd.DataFrame(min_E)\ndf_h = df[df.adsorbate == \"H\"]\ndf_nnh = df[df.adsorbate == \"NNH\"]\ndf_flat = df_h.merge(df_nnh, on=\"bulk_id\")\n\n\n\n","type":"content","url":"/adsorption-energies#parse-the-trajectories-and-post-process","position":13},{"hierarchy":{"lvl1":"Expert Adsorption Energies","lvl2":"Make parity plots for values obtained by ML v. reported in the paper"},"type":"lvl2","url":"/adsorption-energies#make-parity-plots-for-values-obtained-by-ml-v-reported-in-the-paper","position":14},{"hierarchy":{"lvl1":"Expert Adsorption Energies","lvl2":"Make parity plots for values obtained by ML v. reported in the paper"},"content":"\n\n# Add literature data to the dataframe\nwith open(\"literature_data.pkl\", \"rb\") as f:\n    literature_data = pickle.load(f)\ndf_all = df_flat.merge(pd.DataFrame(literature_data), on=\"bulk_id\")\n\n\n\n\n\nf, (ax1, ax2) = plt.subplots(1, 2, sharey=True)\nf.set_figheight(15)\nx = df_all.min_E_ml_x.tolist()\ny = df_all.E_lit_H.tolist()\nax1.set_title(\"*H parity\")\nax1.plot([-3.5, 2], [-3.5, 2], \"k-\", linewidth=3)\nslope, intercept, r, p, se = linregress(x, y)\nax1.plot(\n    [-3.5, 2],\n    [\n        -3.5 * slope + intercept,\n        2 * slope + intercept,\n    ],\n    \"k--\",\n    linewidth=2,\n)\n\nax1.legend(\n    [\n        \"y = x\",\n        f\"y = {slope:1.2f} x + {intercept:1.2f}, R-sq = {r**2:1.2f}\",\n    ],\n    loc=\"upper left\",\n)\nax1.scatter(x, y)\nax1.axis(\"square\")\nax1.set_xlim([-3.5, 2])\nax1.set_ylim([-3.5, 2])\nax1.set_xlabel(\"dE predicted UMA [eV]\")\nax1.set_ylabel(\"dE NRR paper [eV]\")\n\n\nx = df_all.min_E_ml_y.tolist()\ny = df_all.E_lit_NNH.tolist()\nax2.set_title(\"*N*NH parity\")\nax2.plot([-3.5, 2], [-3.5, 2], \"k-\", linewidth=3)\nslope, intercept, r, p, se = linregress(x, y)\nax2.plot(\n    [-3.5, 2],\n    [\n        -3.5 * slope + intercept,\n        2 * slope + intercept,\n    ],\n    \"k--\",\n    linewidth=2,\n)\n\nax2.legend(\n    [\n        \"y = x\",\n        f\"y = {slope:1.2f} x + {intercept:1.2f}, R-sq = {r**2:1.2f}\",\n    ],\n    loc=\"upper left\",\n)\nax2.scatter(x, y)\nax2.axis(\"square\")\nax2.set_xlim([-3.5, 2])\nax2.set_ylim([-3.5, 2])\nax2.set_xlabel(\"dE predicted UMA [eV]\")\nax2.set_ylabel(\"dE NRR paper [eV]\")\nf.set_figwidth(15)\nf.set_figheight(7)\n\n\n\n\n\n","type":"content","url":"/adsorption-energies#make-parity-plots-for-values-obtained-by-ml-v-reported-in-the-paper","position":15},{"hierarchy":{"lvl1":"Expert Adsorption Energies","lvl2":"Make figure 6b and compare to literature results"},"type":"lvl2","url":"/adsorption-energies#make-figure-6b-and-compare-to-literature-results","position":16},{"hierarchy":{"lvl1":"Expert Adsorption Energies","lvl2":"Make figure 6b and compare to literature results"},"content":"\n\nf, (ax1, ax2) = plt.subplots(1, 2, sharey=True)\nx = df_all[df_all.reaction == \"HER\"].min_E_ml_y.tolist()\ny = df_all[df_all.reaction == \"HER\"].min_E_ml_x.tolist()\ncomp = df_all[df_all.reaction == \"HER\"].composition.tolist()\n\nax1.scatter(x, y, c=\"r\", label=\"HER\")\nfor i, txt in enumerate(comp):\n    ax1.annotate(txt, (x[i], y[i]))\n\nx = df_all[df_all.reaction == \"NRR\"].min_E_ml_y.tolist()\ny = df_all[df_all.reaction == \"NRR\"].min_E_ml_x.tolist()\ncomp = df_all[df_all.reaction == \"NRR\"].composition.tolist()\nax1.scatter(x, y, c=\"b\", label=\"NRR\")\nfor i, txt in enumerate(comp):\n    ax1.annotate(txt, (x[i], y[i]))\n\n\nax1.legend()\nax1.set_xlabel(\"dE *N*NH predicted UMA [eV]\")\nax1.set_ylabel(\"dE *H predicted UMA [eV]\")\n\n\nx = df_all[df_all.reaction == \"HER\"].E_lit_NNH.tolist()\ny = df_all[df_all.reaction == \"HER\"].E_lit_H.tolist()\ncomp = df_all[df_all.reaction == \"HER\"].composition.tolist()\n\nax2.scatter(x, y, c=\"r\", label=\"HER\")\nfor i, txt in enumerate(comp):\n    ax2.annotate(txt, (x[i], y[i]))\n\nx = df_all[df_all.reaction == \"NRR\"].E_lit_NNH.tolist()\ny = df_all[df_all.reaction == \"NRR\"].E_lit_H.tolist()\ncomp = df_all[df_all.reaction == \"NRR\"].composition.tolist()\nax2.scatter(x, y, c=\"b\", label=\"NRR\")\nfor i, txt in enumerate(comp):\n    ax2.annotate(txt, (x[i], y[i]))\n\nax2.legend()\nax2.set_xlabel(\"dE *N*NH literature [eV]\")\nax2.set_ylabel(\"dE *H literature [eV]\")\nf.set_figwidth(15)\nf.set_figheight(7)\n\n","type":"content","url":"/adsorption-energies#make-figure-6b-and-compare-to-literature-results","position":17},{"hierarchy":{"lvl1":"Transition State Search (NEBs)"},"type":"lvl1","url":"/cattsunami-tutorial","position":0},{"hierarchy":{"lvl1":"Transition State Search (NEBs)"},"content":"Tutorial Overview\n\nProperty\n\nValue\n\nDifficulty\n\nAdvanced\n\nTime\n\n30-45 minutes\n\nPrerequisites\n\nUnderstanding of NEB, ASE, catalysis\n\nGoal\n\nFind transition states using CatTsunami tools\n\nFAIR chemistry models can be used to enumerate and study reaction pathways via transition state search tools built into ASE or in packages like Sella via the ASE interface.\n\nNote\n\nThe first section of this tutorial walks through how to use the CatTsunami tools to automatically enumerate a number of hypothetical initial/final configurations for various types of reactions on a heterogeneous catalyst surface. If you already have a NEB you’re looking to optimize, you can jump straight to the last section (Run NEBs).\n\nSince the NEB calculations here can be a bit time consuming, we’ll use a small number of steps during the documentation testing, and otherwise use a reasonable guess.\n\nimport os\n\n# Use a small number of steps here to keep the docs fast during CI, but otherwise do quite reasonable settings.\nfast_docs = os.environ.get(\"FAST_DOCS\", \"false\").lower() == \"true\"\nif fast_docs:\n    optimization_steps = 20\nelse:\n    optimization_steps = 300\n\n\n\nNeed to install fairchem-core or get UMA access or getting permissions/401 errors?\n\nInstall the necessary packages using pip, uv etc\n\n! pip install fairchem-core fairchem-data-oc fairchem-applications-cattsunami\n\n\n\nGet access to any necessary huggingface gated models\n\nGet and login to your Huggingface account\n\nRequest access to \n\nhttps://​huggingface​.co​/facebook​/UMA\n\nCreate a Huggingface token at \n\nhttps://​huggingface​.co​/settings​/tokens/ with the permission “Permissions: Read access to contents of all public gated repos you can access”\n\nAdd the token as an environment variable using huggingface-cli login or by setting the HF_TOKEN environment variable.\n\n# Login using the huggingface-cli utility\n! huggingface-cli login\n\n# alternatively,\nimport os\nos.environ['HF_TOKEN'] = 'MY_TOKEN'\n\n","type":"content","url":"/cattsunami-tutorial","position":1},{"hierarchy":{"lvl1":"Transition State Search (NEBs)","lvl2":"Do enumerations in an AdsorbML style"},"type":"lvl2","url":"/cattsunami-tutorial#do-enumerations-in-an-adsorbml-style","position":2},{"hierarchy":{"lvl1":"Transition State Search (NEBs)","lvl2":"Do enumerations in an AdsorbML style"},"content":"\n\nfrom __future__ import annotations\n\nimport matplotlib.pyplot as plt\nfrom ase.io import read\nfrom ase.mep import DyNEB\nfrom ase.optimize import BFGS\nfrom fairchem.applications.cattsunami.core import Reaction\nfrom fairchem.applications.cattsunami.core.autoframe import AutoFrameDissociation\nfrom fairchem.applications.cattsunami.databases import DISSOCIATION_REACTION_DB_PATH\nfrom fairchem.core import FAIRChemCalculator, pretrained_mlip\nfrom fairchem.data.oc.core import Adsorbate, AdsorbateSlabConfig, Bulk, Slab\nfrom fairchem.data.oc.databases.pkls import ADSORBATE_PKL_PATH, BULK_PKL_PATH\nfrom x3dase.x3d import X3D\n\n# Instantiate the reaction class for the reaction of interest\nreaction = Reaction(\n    reaction_str_from_db=\"*CH -> *C + *H\",\n    reaction_db_path=DISSOCIATION_REACTION_DB_PATH,\n    adsorbate_db_path=ADSORBATE_PKL_PATH,\n)\n\n\n\n# Instantiate our adsorbate class for the reactant and product\nreactant = Adsorbate(\n    adsorbate_id_from_db=reaction.reactant1_idx, adsorbate_db_path=ADSORBATE_PKL_PATH\n)\nproduct1 = Adsorbate(\n    adsorbate_id_from_db=reaction.product1_idx, adsorbate_db_path=ADSORBATE_PKL_PATH\n)\nproduct2 = Adsorbate(\n    adsorbate_id_from_db=reaction.product2_idx, adsorbate_db_path=ADSORBATE_PKL_PATH\n)\n\n\n\n# Grab the bulk and cut the slab we are interested in\nbulk = Bulk(bulk_src_id_from_db=\"mp-33\", bulk_db_path=BULK_PKL_PATH)\nslab = Slab.from_bulk_get_specific_millers(bulk=bulk, specific_millers=(0, 0, 1))\n\n\n\n# Perform site enumeration\n# For AdsorbML num_sites = 100, but we use 5 here for brevity. This should be increased for practical use.\nreactant_configs = AdsorbateSlabConfig(\n    slab=slab[0],\n    adsorbate=reactant,\n    mode=\"random_site_heuristic_placement\",\n    num_sites=10,\n).atoms_list\nproduct1_configs = AdsorbateSlabConfig(\n    slab=slab[0],\n    adsorbate=product1,\n    mode=\"random_site_heuristic_placement\",\n    num_sites=10,\n).atoms_list\nproduct2_configs = AdsorbateSlabConfig(\n    slab=slab[0],\n    adsorbate=product2,\n    mode=\"random_site_heuristic_placement\",\n    num_sites=10,\n).atoms_list\n\n\n\n# Instantiate the calculator\npredictor = pretrained_mlip.get_predict_unit(\"uma-s-1p1\")\ncalc = FAIRChemCalculator(predictor, task_name=\"oc20\")\n\n\n\n# Relax the reactant systems\nreactant_energies = []\nfor config in reactant_configs:\n    config.calc = calc\n    config.pbc = True\n    opt = BFGS(config)\n    opt.run(fmax=0.05, steps=optimization_steps)\n    reactant_energies.append(config.get_potential_energy())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Relax the product systems\nproduct1_energies = []\nfor config in product1_configs:\n    config.calc = calc\n    config.pbc = True\n    opt = BFGS(config)\n    opt.run(fmax=0.05, steps=optimization_steps)\n    product1_energies.append(config.get_potential_energy())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nproduct2_energies = []\nfor config in product2_configs:\n    config.calc = calc\n    config.pbc = True\n    opt = BFGS(config)\n    opt.run(fmax=0.05, steps=optimization_steps)\n    product2_energies.append(config.get_potential_energy())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/cattsunami-tutorial#do-enumerations-in-an-adsorbml-style","position":3},{"hierarchy":{"lvl1":"Transition State Search (NEBs)","lvl2":"Enumerate NEBs"},"type":"lvl2","url":"/cattsunami-tutorial#enumerate-nebs","position":4},{"hierarchy":{"lvl1":"Transition State Search (NEBs)","lvl2":"Enumerate NEBs"},"content":"\n\naf = AutoFrameDissociation(\n    reaction=reaction,\n    reactant_system=reactant_configs[reactant_energies.index(min(reactant_energies))],\n    product1_systems=product1_configs,\n    product1_energies=product1_energies,\n    product2_systems=product2_configs,\n    product2_energies=product2_energies,\n    r_product1_max=2,  # r1 in the above fig\n    r_product2_max=3,  # r3 in the above fig\n    r_product2_min=1,  # r2 in the above fig\n)\n\n\n\nimport random\n\nnframes = 10\nrandom.seed(\n    42\n)  # set the seed to make the random generation deterministic for the tutorial!\nframe_sets, mapping_idxs = af.get_neb_frames(\n    calc,\n    n_frames=nframes,\n    n_pdt1_sites=4,  # = 5 in the above fig (step 1)\n    n_pdt2_sites=4,  # = 5 in the above fig (step 2)\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/cattsunami-tutorial#enumerate-nebs","position":5},{"hierarchy":{"lvl1":"Transition State Search (NEBs)","lvl2":"Run NEBs"},"type":"lvl2","url":"/cattsunami-tutorial#run-nebs","position":6},{"hierarchy":{"lvl1":"Transition State Search (NEBs)","lvl2":"Run NEBs"},"content":"\n\n## This will run all NEBs enumerated - to just run one, run the code cell below.\n# On GPU, each NEB takes an average of ~1 minute so this could take around a half hour on GPU\n# But much longer on CPU\n# Remember that not all NEBs will converge -- the k, nframes would be adjusted to achieve convergence\n\nfmax = 0.05  # [eV / ang**2]\ndelta_fmax_climb = 0.4\nconverged_idxs = []\n\nfor idx, frame_set in enumerate(frame_sets):\n    neb = DyNEB(frame_set, k=1)\n    for image in frame_set:\n        image.calc = FAIRChemCalculator(predictor, task_name=\"oc20\")\n\n    optimizer = BFGS(\n        neb,\n        trajectory=f\"ch_dissoc_on_Ru_{idx}.traj\",\n    )\n    conv = optimizer.run(fmax=fmax + delta_fmax_climb, steps=optimization_steps)\n    if conv:\n        neb.climb = True\n        conv = optimizer.run(fmax=fmax, steps=optimization_steps)\n        if conv:\n            converged_idxs.append(idx)\n\nprint(converged_idxs)\n\n\n\nThis cell will run a shorter calculations for just a single one of the enumerated transition state pathways. You can adapt this code to run transition state searches via nudged elastic band (NEB) calculations for any reaction.\n\n# If you run the above cell -- dont run this one\nfmax = 0.05  # [eV / ang**2]\ndelta_fmax_climb = 0.4\nimages = frame_sets[0]\nneb = DyNEB(images, k=1)\nfor image in images:\n    image.calc = FAIRChemCalculator(predictor, task_name=\"oc20\")\n\noptimizer = BFGS(\n    neb,\n    trajectory=\"ch_dissoc_on_Ru_0.traj\",\n)\nconv = optimizer.run(fmax=fmax + delta_fmax_climb, steps=optimization_steps)\nif conv:\n    neb.climb = True\n    conv = optimizer.run(fmax=fmax, steps=optimization_steps)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/cattsunami-tutorial#run-nebs","position":7},{"hierarchy":{"lvl1":"Transition State Search (NEBs)","lvl2":"Visualize the results"},"type":"lvl2","url":"/cattsunami-tutorial#visualize-the-results","position":8},{"hierarchy":{"lvl1":"Transition State Search (NEBs)","lvl2":"Visualize the results"},"content":"Finally, let’s visualize the results!\n\noptimized_neb = read(\"ch_dissoc_on_Ru_0.traj\", \":\")[-1 * nframes :]\n\n\n\nes = []\nfor frame in optimized_neb:\n    frame.set_calculator(calc)\n    es.append(frame.get_potential_energy())\n\n\n\n# Plot the reaction coordinate\n\nes = [e - es[0] for e in es]\nplt.plot(es)\nplt.xlabel(\"frame number\")\nplt.ylabel(\"relative energy [eV]\")\nplt.title(f\"CH dissociation on Ru(0001), Ea = {max(es):1.2f} eV\")\nplt.savefig(\"CH_dissoc_on_Ru_0001.png\")\n\n\n\nTo generalize an interactive visualization, use ase gui from the command line or the X3D package\n\n# Make an interative html file of the optimized neb trajectory\nx3d = X3D(optimized_neb)\nx3d.write(\"optimized_neb_ch_disoc_on_Ru0001.html\")\n\n","type":"content","url":"/cattsunami-tutorial#visualize-the-results","position":9},{"hierarchy":{"lvl1":"ocpapi"},"type":"lvl1","url":"/ocpapi","position":0},{"hierarchy":{"lvl1":"ocpapi"},"content":"API Overview\n\nProperty\n\nValue\n\nPurpose\n\nProgrammatic access to Open Catalyst Demo\n\nInterface\n\nPython async/await\n\nLicense\n\nMIT\n\nPython library for programmatic use of the \n\nOpen Catalyst Demo. Users unfamiliar with the Open Catalyst Demo are encouraged to read more about it before continuing.","type":"content","url":"/ocpapi","position":1},{"hierarchy":{"lvl1":"ocpapi","lvl2":"Installation"},"type":"lvl2","url":"/ocpapi#installation","position":2},{"hierarchy":{"lvl1":"ocpapi","lvl2":"Installation"},"content":"Need to install fairchem-core or get UMA access or getting permissions/401 errors?\n\nInstall the necessary packages using pip, uv etc\n\n! pip install fairchem-core fairchem-data-oc fairchem-applications-cattsunami\n\n\n\nGet access to any necessary huggingface gated models\n\nGet and login to your Huggingface account\n\nRequest access to \n\nhttps://​huggingface​.co​/facebook​/UMA\n\nCreate a Huggingface token at \n\nhttps://​huggingface​.co​/settings​/tokens/ with the permission “Permissions: Read access to contents of all public gated repos you can access”\n\nAdd the token as an environment variable using huggingface-cli login or by setting the HF_TOKEN environment variable.\n\n# Login using the huggingface-cli utility\n! huggingface-cli login\n\n# alternatively,\nimport os\nos.environ['HF_TOKEN'] = 'MY_TOKEN'\n\n","type":"content","url":"/ocpapi#installation","position":3},{"hierarchy":{"lvl1":"ocpapi","lvl2":"Quickstart"},"type":"lvl2","url":"/ocpapi#quickstart","position":4},{"hierarchy":{"lvl1":"ocpapi","lvl2":"Quickstart"},"content":"The following examples are used to search for *OH binding sites on Pt surfaces. They use the find_adsorbate_binding_sites function, which is a high-level workflow on top of other methods included in this library. Once familiar with this routine, users are encouraged to learn about lower-level methods and features that support more advanced use cases.","type":"content","url":"/ocpapi#quickstart","position":5},{"hierarchy":{"lvl1":"ocpapi","lvl3":"Note about async methods","lvl2":"Quickstart"},"type":"lvl3","url":"/ocpapi#note-about-async-methods","position":6},{"hierarchy":{"lvl1":"ocpapi","lvl3":"Note about async methods","lvl2":"Quickstart"},"content":"This package relies heavily on \n\nasyncio. The examples throughout this document can be copied to a python repl launched with:\n\n%%sh\n$ python -m asyncio\n\n\n\nAlternatively, an async function can be run in a script by wrapping it with \n\nasyncio.run():\n\nimport asyncio\nfrom fairchem.demo.ocpapi import find_adsorbate_binding_sites\n\nasyncio.run(find_adsorbate_binding_sites(...))\n\n\n\nSince this is being evaluated as a jupyter notebook, ipython will handle this for you automatically!","type":"content","url":"/ocpapi#note-about-async-methods","position":7},{"hierarchy":{"lvl1":"ocpapi","lvl3":"Search over all surfaces","lvl2":"Quickstart"},"type":"lvl3","url":"/ocpapi#search-over-all-surfaces","position":8},{"hierarchy":{"lvl1":"ocpapi","lvl3":"Search over all surfaces","lvl2":"Quickstart"},"content":"\n\nfrom fairchem.demo.ocpapi import find_adsorbate_binding_sites\n\nresults = await find_adsorbate_binding_sites(\n    adsorbate=\"*OH\",\n    bulk=\"mp-126\",\n)\n\n\n\nUsers will be prompted to select one or more surfaces that should be relaxed.\n\nInput to this function includes:\n\nThe name of the adsorbate to place\n\nA unique ID of the bulk structure from which surfaces will be generated\n\nThis function will perform the following steps:\n\nEnumerate surfaces of the bulk material\n\nOn each surface, enumerate initial guesses for adorbate binding sites\n\nRun local force-based relaxations of each adsorbate placement\n\nIn addition, this handles:\n\nRetrying failed calls to the Open Catalyst Demo API\n\nRetrying submission of relaxations when they are rate limited\n\nThis should take 2-10 minutes to finish while tens to hundreds (depending on the number of surfaces that are selected) of individual adsorbate placements are relaxed on unique surfaces of Pt. Each of the objects in the returned list includes (among other details):\n\nInformation about the surface being searched, including its structure and Miller indices\n\nThe initial positions of the adsorbate before relaxation\n\nThe final structure after relaxation\n\nThe predicted energy of the final structure\n\nThe predicted force on each atom in the final structure\n\n","type":"content","url":"/ocpapi#search-over-all-surfaces","position":9},{"hierarchy":{"lvl1":"ocpapi","lvl3":"Supported bulks and adsorbates","lvl2":"Quickstart"},"type":"lvl3","url":"/ocpapi#supported-bulks-and-adsorbates","position":10},{"hierarchy":{"lvl1":"ocpapi","lvl3":"Supported bulks and adsorbates","lvl2":"Quickstart"},"content":"A finite set of bulk materials and adsorbates can be referenced by ID throughout the OCP API. The lists of supported values can be viewed in two ways.\n\nVisit the UI at \n\nhttps://​open​-catalyst​.metademolab​.com​/demo and explore the lists in Step 1 and Step 3.\n\nUse the low-level client that ships with this library:\n\nfrom fairchem.demo.ocpapi import Client\n\nclient = Client()\n\nbulks = await client.get_bulks()\nprint({b.src_id: b.formula for b in bulks.bulks_supported})\n\nadsorbates = await client.get_adsorbates()\nprint(adsorbates.adsorbates_supported)\n\n\n\n","type":"content","url":"/ocpapi#supported-bulks-and-adsorbates","position":11},{"hierarchy":{"lvl1":"ocpapi","lvl3":"Skip relaxation approval prompts","lvl2":"Quickstart"},"type":"lvl3","url":"/ocpapi#skip-relaxation-approval-prompts","position":12},{"hierarchy":{"lvl1":"ocpapi","lvl3":"Skip relaxation approval prompts","lvl2":"Quickstart"},"content":"Calls to find_adsorbate_binding_sites() will, by default, show the user all pending relaxations and ask for approval before they are submitted. In order to run the relaxations automatically without manual approval, adslab_filter can be set to a function that automatically approves any or all adsorbate/slab (adslab) configurations.\n\nRun relaxations for all slabs that are generated:\n\nfrom fairchem.demo.ocpapi import find_adsorbate_binding_sites, keep_all_slabs\n\nresults = await find_adsorbate_binding_sites(\n    adsorbate=\"*OH\",\n    bulk=\"mp-126\",\n    adslab_filter=keep_all_slabs(),\n)\n\n\n\nRun relaxations only for slabs with Miller Indices in the input set:\n\nfrom fairchem.demo.ocpapi import find_adsorbate_binding_sites, keep_slabs_with_miller_indices\n\nresults = await find_adsorbate_binding_sites(\n    adsorbate=\"*OH\",\n    bulk=\"mp-126\",\n    adslab_filter=keep_slabs_with_miller_indices([(1, 0, 0), (1, 1, 1)]),\n)\nprint(results)\n\n\n\n","type":"content","url":"/ocpapi#skip-relaxation-approval-prompts","position":13},{"hierarchy":{"lvl1":"ocpapi","lvl3":"Persisting results","lvl2":"Quickstart"},"type":"lvl3","url":"/ocpapi#persisting-results","position":14},{"hierarchy":{"lvl1":"ocpapi","lvl3":"Persisting results","lvl2":"Quickstart"},"content":"Results should be saved whenever possible in order to avoid expensive recomputation.\n\nAssuming results was generated with the find_adsorbate_binding_sites method used above, it is an AdsorbateBindingSites object. This can be saved to file with:\n\nwith open(\"results.json\", \"w\") as f:\n    f.write(results.to_json())\n\n\n\nSimilarly, results can be read back from file to an AdsorbateBindingSites object with:\n\nfrom fairchem.demo.ocpapi import AdsorbateBindingSites\n\nwith open(\"results.json\", \"r\") as f:\n    results = AdsorbateBindingSites.from_json(f.read())\n\n\n\n","type":"content","url":"/ocpapi#persisting-results","position":15},{"hierarchy":{"lvl1":"ocpapi","lvl3":"Viewing results in the web UI","lvl2":"Quickstart"},"type":"lvl3","url":"/ocpapi#viewing-results-in-the-web-ui","position":16},{"hierarchy":{"lvl1":"ocpapi","lvl3":"Viewing results in the web UI","lvl2":"Quickstart"},"content":"Relaxation results can be viewed in a web UI. For example, \n\nhttps://​open​-catalyst​.metademolab​.com​/results​/7eaa0d63​-83aa​-473f​-ac84​-423ffd0c67f5 shows the results of relaxing *OH on a Pt (1,1,1) surface; the uuid, “7eaa0d63-83aa-473f-ac84-423ffd0c67f5”, is referred to as the system_id.\n\nExtending the examples above, the URLs to visualize the results of relaxations on each Pt surface can be obtained with:\n\nprint([\n    slab.ui_url\n    for slab in results.slabs\n])\n\n\n\n","type":"content","url":"/ocpapi#viewing-results-in-the-web-ui","position":17},{"hierarchy":{"lvl1":"ocpapi","lvl2":"Advanced usage"},"type":"lvl2","url":"/ocpapi#advanced-usage","position":18},{"hierarchy":{"lvl1":"ocpapi","lvl2":"Advanced usage"},"content":"","type":"content","url":"/ocpapi#advanced-usage","position":19},{"hierarchy":{"lvl1":"ocpapi","lvl3":"Changing the model type","lvl2":"Advanced usage"},"type":"lvl3","url":"/ocpapi#changing-the-model-type","position":20},{"hierarchy":{"lvl1":"ocpapi","lvl3":"Changing the model type","lvl2":"Advanced usage"},"content":"The API currently supports two models:\n\nequiformer_v2_31M_s2ef_all_md (default): \n\nhttps://​arxiv​.org​/abs​/2306​.12059\n\ngemnet_oc_base_s2ef_all_md: \n\nhttps://​arxiv​.org​/abs​/2204​.02782\n\nA specific model type can be requested with:\n\nfrom fairchem.demo.ocpapi import find_adsorbate_binding_sites\n\nresults = await find_adsorbate_binding_sites(\n    adsorbate=\"*OH\",\n    bulk=\"mp-126\",\n    model=\"gemnet_oc_base_s2ef_all_md\",\n    adslab_filter=keep_slabs_with_miller_indices([(1, 1, 1)]),\n\n)\nprint([\n    slab.ui_url\n    for slab in results.slabs\n])\n\n\n\n","type":"content","url":"/ocpapi#changing-the-model-type","position":21},{"hierarchy":{"lvl1":"ocpapi","lvl3":"Converting to ase.Atoms objects","lvl2":"Advanced usage"},"type":"lvl3","url":"/ocpapi#converting-to-ase-atoms-objects","position":22},{"hierarchy":{"lvl1":"ocpapi","lvl3":"Converting to ase.Atoms objects","lvl2":"Advanced usage"},"content":"Important! The to_ase_atoms() method described below will fail with an import error if \n\nase is not installed.\n\nTwo classes have support for generating \n\nase.Atoms objects:\n\nocpapi.Atoms.to_ase_atoms(): Adds unit cell, atomic positions, and other structural information to the returned ase.Atoms object.\n\nocpapi.AdsorbateSlabRelaxationResult.to_ase_atoms(): Adds the same structure information to the ase.Atoms object. Also adds the predicted forces and energy of the relaxed structure, which can be accessed with the ase.Atoms.get_potential_energy() and ase.Atoms.get_forces() methods.\n\nFor example, the following would generate an ase.Atoms object for the first relaxed adsorbate configuration on the first slab generated for *OH binding on Pt:\n\nfrom fairchem.demo.ocpapi import find_adsorbate_binding_sites\n\nresults = await find_adsorbate_binding_sites(\n    adsorbate=\"*OH\",\n    bulk=\"mp-126\",\n    adslab_filter=keep_slabs_with_miller_indices([(1, 1, 1)]),\n)\n\nase_atoms = results.slabs[0].configs[0].to_ase_atoms()\nprint(ase_atoms)\n\n\n\n","type":"content","url":"/ocpapi#converting-to-ase-atoms-objects","position":23},{"hierarchy":{"lvl1":"ocpapi","lvl3":"Converting to other structure formats","lvl2":"Advanced usage"},"type":"lvl3","url":"/ocpapi#converting-to-other-structure-formats","position":24},{"hierarchy":{"lvl1":"ocpapi","lvl3":"Converting to other structure formats","lvl2":"Advanced usage"},"content":"From an ase.Atoms object (see previous section), is is possible to \n\nwrite to other structure formats. Extending the example above, the ase_atoms object could be written to a \n\nVASP POSCAR file with:\n\nfrom ase.io import write\n\nwrite(\"POSCAR\", ase_atoms, \"vasp\")\n\n\n\n","type":"content","url":"/ocpapi#converting-to-other-structure-formats","position":25},{"hierarchy":{"lvl1":"ocpapi","lvl2":"License"},"type":"lvl2","url":"/ocpapi#license","position":26},{"hierarchy":{"lvl1":"ocpapi","lvl2":"License"},"content":"ocpapi is released under the \n\nMIT License.","type":"content","url":"/ocpapi#license","position":27},{"hierarchy":{"lvl1":"ocpapi","lvl2":"Citing ocpapi"},"type":"lvl2","url":"/ocpapi#citing-ocpapi","position":28},{"hierarchy":{"lvl1":"ocpapi","lvl2":"Citing ocpapi"},"content":"If you use ocpapi in your research, please consider citing the \n\nAdsorbML paper (in addition to the relevant datasets / models used):@article{lan2023adsorbml,\n  title={{AdsorbML}: a leap in efficiency for adsorption energy calculations using generalizable machine learning potentials},\n  author={Lan*, Janice and Palizhati*, Aini and Shuaibi*, Muhammed and Wood*, Brandon M and Wander, Brook and Das, Abhishek and Uyttendaele, Matt and Zitnick, C Lawrence and Ulissi, Zachary W},\n  journal={npj Computational Materials},\n  year={2023},\n}","type":"content","url":"/ocpapi#citing-ocpapi","position":29},{"hierarchy":{"lvl1":"Examples & Tutorials"},"type":"lvl1","url":"/summary-4","position":0},{"hierarchy":{"lvl1":"Examples & Tutorials"},"content":"\n\nThis section provides hands-on tutorials for using FAIRChem models in catalysis research. From basic adsorption energy calculations to advanced transition state searches, these tutorials will help you get started with computational catalysis.\n\nTip\n\nNew to FAIRChem? Start with the \n\nIntro to Adsorption Energies tutorial to learn the basics.\n\nIntro to Adsorption Energies\n\nLearn the fundamentals of calculating adsorption energies using UMA models and compare trends across different metals.\n\nDifficulty: Beginner\n\nExpert Adsorption Energies\n\nAdvanced tutorial on reproducing literature results for NRR/HER selectivity using automated adsorbate placement.\n\nDifficulty: Advanced\n\nAdsorbML Walkthrough\n\nUse the AdsorbML workflow to automatically find optimal adsorption sites with ML-accelerated relaxations.\n\nDifficulty: Intermediate\n\nTransition State Search (NEBs)\n\nFind reaction transition states using CatTsunami tools for NEB calculations on catalyst surfaces.\n\nDifficulty: Advanced\n\nOCP API\n\nProgrammatically access the Open Catalyst Demo for adsorbate binding site searches.\n\nDifficulty: Intermediate","type":"content","url":"/summary-4","position":1},{"hierarchy":{"lvl1":"Pretrained Models"},"type":"lvl1","url":"/models-1","position":0},{"hierarchy":{"lvl1":"Pretrained Models"},"content":"\n\nTip\n\n2025 Recommendation: We now suggest using the \n\nUMA model, trained on all of the FAIR chemistry datasets before using one of the checkpoints below.\n\nWhy UMA?\n\nState-of-the-art accuracy in out-of-domain prediction\n\nTotal energy predictions which are helpful for properties beyond adsorption energies and removes ambiguity when catalyst surfaces may reconstruct\n\nEnergy conserving and smooth (UMA small model) - works much better for vibrational calculations, molecular dynamics, etc.\n\nMost likely to be updated in the future","type":"content","url":"/models-1","position":1},{"hierarchy":{"lvl1":"Pretrained Models","lvl2":"Legacy FAIRChemV1 Models Trained on Open Catalyst 2020 (OC20)"},"type":"lvl2","url":"/models-1#legacy-fairchemv1-models-trained-on-open-catalyst-2020-oc20","position":2},{"hierarchy":{"lvl1":"Pretrained Models","lvl2":"Legacy FAIRChemV1 Models Trained on Open Catalyst 2020 (OC20)"},"content":"Warning\n\nThese models are only available if you install fairchem<=2.0. For new projects, we recommend using the UMA model instead.\n\nThis page summarizes all the pretrained models released as part of the \n\nOpen Catalyst Project.\n\nAll configurations for these models are available in the \n\nconfigs/ directory.\n\nAll of these models are trained on various splits of the OC20 S2EF / IS2RE datasets. For details, see \n\nhttps://​arxiv​.org​/abs​/2010​.09990 and \n\nDATASET.md.\n\nAll OC20 models are trained on adsorption energies, i.e. the DFT total energies minus the clean surface and gas phase adsorbate energies. For details on how to train models on OC20 total energies, please read the \n\nreferencing section here.","type":"content","url":"/models-1#legacy-fairchemv1-models-trained-on-open-catalyst-2020-oc20","position":3},{"hierarchy":{"lvl1":"Pretrained Models","lvl3":"S2EF models: optimized for EFwT","lvl2":"Legacy FAIRChemV1 Models Trained on Open Catalyst 2020 (OC20)"},"type":"lvl3","url":"/models-1#s2ef-models-optimized-for-efwt","position":4},{"hierarchy":{"lvl1":"Pretrained Models","lvl3":"S2EF models: optimized for EFwT","lvl2":"Legacy FAIRChemV1 Models Trained on Open Catalyst 2020 (OC20)"},"content":"Model Name\n\nModel\n\nSplit\n\nDownload\n\nval ID force MAE (eV / Å)\n\nval ID EFwT\n\nCGCNN-S2EF-OC20-200k\n\nCGCNN\n\n200k\n\ncheckpoint | \n\nconfig\n\n0.08\n\n0%\n\nCGCNN-S2EF-OC20-2M\n\nCGCNN\n\n2M\n\ncheckpoint | \n\nconfig\n\n0.0673\n\n0.01%\n\nCGCNN-S2EF-OC20-20M\n\nCGCNN\n\n20M\n\ncheckpoint | \n\nconfig\n\n0.065\n\n0%\n\nCGCNN-S2EF-OC20-All\n\nCGCNN\n\nAll\n\ncheckpoint | \n\nconfig\n\n0.0684\n\n0.01%\n\nDimeNet-S2EF-OC20-200k\n\nDimeNet\n\n200k\n\ncheckpoint\n\n0.0693\n\n0.01%\n\nDimeNet-S2EF-OC20-2M\n\nDimeNet\n\n2M\n\ncheckpoint\n\n0.0576\n\n0.02%\n\nSchNet-S2EF-OC20-200k\n\nSchNet\n\n200k\n\ncheckpoint | \n\nconfig\n\n0.0743\n\n0%\n\nSchNet-S2EF-OC20-2M\n\nSchNet\n\n2M\n\ncheckpoint | \n\nconfig\n\n0.0737\n\n0%\n\nSchNet-S2EF-OC20-20M\n\nSchNet\n\n20M\n\ncheckpoint | \n\nconfig\n\n0.0568\n\n0.03%\n\nSchNet-S2EF-OC20-All\n\nSchNet\n\nAll\n\ncheckpoint | \n\nconfig\n\n0.0494\n\n0.12%\n\nDimeNet++-S2EF-OC20-200k\n\nDimeNet++\n\n200k\n\ncheckpoint | \n\nconfig\n\n0.0741\n\n0%\n\nDimeNet++-S2EF-OC20-2M\n\nDimeNet++\n\n2M\n\ncheckpoint | \n\nconfig\n\n0.0595\n\n0.01%\n\nDimeNet++-S2EF-OC20-20M\n\nDimeNet++\n\n20M\n\ncheckpoint | \n\nconfig\n\n0.0511\n\n0.06%\n\nDimeNet++-S2EF-OC20-All\n\nDimeNet++\n\nAll\n\ncheckpoint | \n\nconfig\n\n0.0444\n\n0.12%\n\nSpinConv-S2EF-OC20-2M\n\nSpinConv\n\n2M\n\ncheckpoint | \n\nconfig\n\n0.0329\n\n0.18%\n\nSpinConv-S2EF-OC20-All\n\nSpinConv\n\nAll\n\ncheckpoint | \n\nconfig\n\n0.0267\n\n1.02%\n\nGemNet-dT-S2EF-OC20-2M\n\nGemNet-dT\n\n2M\n\ncheckpoint | \n\nconfig\n\n0.0257\n\n1.10%\n\nGemNet-dT-S2EF-OC20-All\n\nGemNet-dT\n\nAll\n\ncheckpoint | \n\nconfig\n\n0.0211\n\n2.21%\n\nPaiNN-S2EF-OC20-All\n\nPaiNN\n\nAll\n\ncheckpoint | \n\nconfig | \n\nscale file\n\n0.0294\n\n0.91%\n\nGemNet-OC-S2EF-OC20-2M\n\nGemNet-OC\n\n2M\n\ncheckpoint | \n\nconfig | \n\nscale file\n\n0.0225\n\n2.12%\n\nGemNet-OC-S2EF-OC20-All\n\nGemNet-OC\n\nAll\n\ncheckpoint | \n\nconfig | \n\nscale file\n\n0.0179\n\n4.56%\n\nGemNet-OC-S2EF-OC20-All+MD\n\nGemNet-OC\n\nAll+MD\n\ncheckpoint | \n\nconfig | \n\nscale file\n\n0.0173\n\n4.72%\n\nGemNet-OC-Large-S2EF-OC20-All+MD\n\nGemNet-OC-Large\n\nAll+MD\n\ncheckpoint | \n\nconfig | \n\nscale file\n\n0.0164\n\n5.34%\n\nSCN-S2EF-OC20-2M\n\nSCN\n\n2M\n\ncheckpoint | \n\nconfig\n\n0.0216\n\n1.68%\n\nSCN-t4-b2-S2EF-OC20-2M\n\nSCN-t4-b2\n\n2M\n\ncheckpoint | \n\nconfig\n\n0.0193\n\n2.68%\n\nSCN-S2EF-OC20-All+MD\n\nSCN\n\nAll+MD\n\ncheckpoint | \n\nconfig\n\n0.0160\n\n5.08%\n\neSCN-L4-M2-Lay12-S2EF-OC20-2M\n\neSCN-L4-M2-Lay12\n\n2M\n\ncheckpoint | \n\nconfig\n\n0.0191\n\n2.55%\n\neSCN-L6-M2-Lay12-S2EF-OC20-2M\n\neSCN-L6-M2-Lay12\n\n2M\n\ncheckpoint | \n\nconfig | \n\nexported\n\n0.0186\n\n2.66%\n\neSCN-L6-M2-Lay12-S2EF-OC20-All+MD\n\neSCN-L6-M2-Lay12\n\nAll+MD\n\ncheckpoint | \n\nconfig\n\n0.0161\n\n4.28%\n\neSCN-L6-M3-Lay20-S2EF-OC20-All+MD\n\neSCN-L6-M3-Lay20\n\nAll+MD\n\ncheckpoint | \n\nconfig\n\n0.0139\n\n6.64%\n\nEquiformerV2-83M-S2EF-OC20-2M\n\nEquiformerV2 (83M)\n\n2M\n\ncheckpoint | \n\nconfig\n\n0.0167\n\n4.26%\n\nEquiformerV2-31M-S2EF-OC20-All+MD\n\nEquiformerV2 (31M)\n\nAll+MD\n\ncheckpoint | \n\nconfig\n\n0.0142\n\n6.20%\n\nEquiformerV2-153M-S2EF-OC20-All+MD\n\nEquiformerV2 (153M)\n\nAll+MD\n\ncheckpoint | \n\nconfig\n\n0.0126\n\n8.90%","type":"content","url":"/models-1#s2ef-models-optimized-for-efwt","position":5},{"hierarchy":{"lvl1":"Pretrained Models","lvl3":"S2EF models: optimized for force only","lvl2":"Legacy FAIRChemV1 Models Trained on Open Catalyst 2020 (OC20)"},"type":"lvl3","url":"/models-1#s2ef-models-optimized-for-force-only","position":6},{"hierarchy":{"lvl1":"Pretrained Models","lvl3":"S2EF models: optimized for force only","lvl2":"Legacy FAIRChemV1 Models Trained on Open Catalyst 2020 (OC20)"},"content":"Model Name\n\nModel\n\nSplit\n\nDownload\n\nval ID force MAE\n\nSchNet-S2EF-force-only-OC20-All\n\nSchNet\n\nAll\n\ncheckpoint\n\n0.0443\n\nDimeNet++-force-only-OC20-All\n\nDimeNet++\n\nAll\n\ncheckpoint | \n\nconfig\n\n0.0334\n\nDimeNet++-Large-S2EF-force-only-OC20-All\n\nDimeNet++-Large\n\nAll\n\ncheckpoint | \n\nconfig\n\n0.02825\n\nDimeNet++-S2EF-force-only-OC20-20M+Rattled\n\nDimeNet++\n\n20M+Rattled\n\ncheckpoint\n\n0.0614\n\nDimeNet++-S2EF-force-only-OC20-20M+MD\n\nDimeNet++\n\n20M+MD\n\ncheckpoint\n\n0.0594","type":"content","url":"/models-1#s2ef-models-optimized-for-force-only","position":7},{"hierarchy":{"lvl1":"Pretrained Models","lvl3":"IS2RE models","lvl2":"Legacy FAIRChemV1 Models Trained on Open Catalyst 2020 (OC20)"},"type":"lvl3","url":"/models-1#is2re-models","position":8},{"hierarchy":{"lvl1":"Pretrained Models","lvl3":"IS2RE models","lvl2":"Legacy FAIRChemV1 Models Trained on Open Catalyst 2020 (OC20)"},"content":"Model Name\n\nModel\n\nSplit\n\nDownload\n\nval ID energy MAE\n\nCGCNN-IS2RE-OC20-10k\n\nCGCNN\n\n10k\n\ncheckpoint | \n\nconfig\n\n0.9881\n\nCGCNN-IS2RE-OC20-100k\n\nCGCNN\n\n100k\n\ncheckpoint | \n\nconfig\n\n0.682\n\nCGCNN-IS2RE-OC20-All\n\nCGCNN\n\nAll\n\ncheckpoint | \n\nconfig\n\n0.6199\n\nDimeNet-IS2RE-OC20-10k\n\nDimeNet\n\n10k\n\ncheckpoint\n\n1.0117\n\nDimeNet-IS2RE-OC20-100k\n\nDimeNet\n\n100k\n\ncheckpoint\n\n0.6658\n\nDimeNet-IS2RE-OC20-all\n\nDimeNet\n\nAll\n\ncheckpoint\n\n0.5999\n\nSchNet-IS2RE-OC20-10k\n\nSchNet\n\n10k\n\ncheckpoint | \n\nconfig\n\n1.059\n\nSchNet-IS2RE-OC20-100k\n\nSchNet\n\n100k\n\ncheckpoint | \n\nconfig\n\n0.7137\n\nSchNet-IS2RE-OC20-All\n\nSchNet\n\nAll\n\ncheckpoint | \n\nconfig\n\n0.6458\n\nDimeNet++-IS2RE-OC20-10k\n\nDimeNet++\n\n10k\n\ncheckpoint | \n\nconfig\n\n0.8837\n\nDimeNet++-IS2RE-OC20-100k\n\nDimeNet++\n\n100k\n\ncheckpoint | \n\nconfig\n\n0.6388\n\nDimeNet++-IS2RE-OC20-All\n\nDimeNet++\n\nAll\n\ncheckpoint | \n\nconfig\n\n0.5639\n\nPaiNN-IS2RE-OC20-All\n\nPaiNN\n\nAll\n\ncheckpoint | \n\nconfig | \n\nscale file\n\n0.5728\n\nThe Open Catalyst 2020 (OC20) dataset is licensed under a \n\nCreative Commons Attribution 4.0 License.\n\nPlease consider citing the following paper in any research manuscript using the\nOC20 dataset or pretrained models, as well as the original paper for each model:@article{ocp_dataset,\n    author = {Chanussot*, Lowik and Das*, Abhishek and Goyal*, Siddharth and Lavril*, Thibaut and Shuaibi*, Muhammed and Riviere, Morgane and Tran, Kevin and Heras-Domingo, Javier and Ho, Caleb and Hu, Weihua and Palizhati, Aini and Sriram, Anuroop and Wood, Brandon and Yoon, Junwoong and Parikh, Devi and Zitnick, C. Lawrence and Ulissi, Zachary},\n    title = {Open Catalyst 2020 (OC20) Dataset and Community Challenges},\n    journal = {ACS Catalysis},\n    year = {2021},\n    doi = {10.1021/acscatal.0c04525},\n}","type":"content","url":"/models-1#is2re-models","position":9},{"hierarchy":{"lvl1":"Pretrained Models","lvl2":"Open Catalyst 2022 (OC22)"},"type":"lvl2","url":"/models-1#open-catalyst-2022-oc22","position":10},{"hierarchy":{"lvl1":"Pretrained Models","lvl2":"Open Catalyst 2022 (OC22)"},"content":"All configurations for these models are available in the \n\nconfigs/oc22 directory.\n\nAll of these models are trained on various splits of the OC22 S2EF / IS2RE datasets. For details, see \n\nhttps://​arxiv​.org​/abs​/2206​.08917 and \n\nDATASET.md.\n\nAll OC22 models released here are trained on DFT total energies, in contrast to the OC20 models listed above, which are trained on adsorption energies.","type":"content","url":"/models-1#open-catalyst-2022-oc22","position":11},{"hierarchy":{"lvl1":"Pretrained Models","lvl3":"S2EF-Total models","lvl2":"Open Catalyst 2022 (OC22)"},"type":"lvl3","url":"/models-1#s2ef-total-models","position":12},{"hierarchy":{"lvl1":"Pretrained Models","lvl3":"S2EF-Total models","lvl2":"Open Catalyst 2022 (OC22)"},"content":"Model Name\n\nModel\n\nTraining\n\nDownload\n\nval ID force MAE\n\nval ID energy MAE\n\nGemNet-dT-S2EFS-OC22\n\nGemNet-dT\n\nOC22\n\ncheckpoint | \n\nconfig\n\n0.032\n\n1.127\n\nGemNet-OC-S2EFS-OC22\n\nGemNet-OC\n\nOC22\n\ncheckpoint | \n\nconfig\n\n0.030\n\n0.563\n\nGemNet-OC-S2EFS-OC20+OC22\n\nGemNet-OC\n\nOC20+OC22\n\ncheckpoint | \n\nconfig\n\n0.027\n\n0.483\n\nGemNet-OC-S2EFS-nsn-OC20+OC22\n\nGemNet-OC (trained with enforce_max_neighbors_strictly=False , \n\n#467 )\n\nOC20+OC22\n\ncheckpoint | \n\nconfig\n\n0.027\n\n0.458\n\nGemNet-OC-S2EFS-OC20->OC22\n\nGemNet-OC\n\nOC20->OC22\n\ncheckpoint | \n\nconfig\n\n0.030\n\n0.417\n\nEquiformerV2-lE4-lF100-S2EFS-OC22\n\nEquiformerV2 (\\lambda_E=4, \\lambda_F=100)\n\nOC22\n\ncheckpoint | \n\nconfig\n\n0.023\n\n0.447\n\nThe Open Catalyst 2022 (OC22) dataset is licensed under a \n\nCreative Commons Attribution 4.0 License.\n\nPlease consider citing the following paper in any research manuscript using the\nOC22 dataset or pretrained models, as well as the original paper for each model:@article{oc22_dataset,\n    author = {Tran*, Richard and Lan*, Janice and Shuaibi*, Muhammed and Wood*, Brandon and Goyal*, Siddharth and Das, Abhishek and Heras-Domingo, Javier and Kolluru, Adeesh and Rizvi, Ammar and Shoghi, Nima and Sriram, Anuroop and Ulissi, Zachary and Zitnick, C. Lawrence},\n    title = {The Open Catalyst 2022 (OC22) dataset and challenges for oxide electrocatalysts},\n    journal = {ACS Catalysis},\n    year={2023},\n}","type":"content","url":"/models-1#s2ef-total-models","position":13},{"hierarchy":{"lvl1":"Inference using ASE and Predictor Interface"},"type":"lvl1","url":"/ase-calculator","position":0},{"hierarchy":{"lvl1":"Inference using ASE and Predictor Interface"},"content":"Inference is done using \n\nMLIPPredictUnit. The \n\nFairchemCalculator (an ASE calculator) is simply a convenience wrapper around the MLIPPredictUnit.\n\nTip\n\nFor simple cases such as demos or education, the ASE calculator is very easy to use. For more complex cases such as running MD or batched inference, we recommend using the predictor directly for better performance.\n\nfrom __future__ import annotations\n\nfrom fairchem.core import FAIRChemCalculator, pretrained_mlip\n\npredictor = pretrained_mlip.get_predict_unit(\"uma-s-1p1\", device=\"cuda\")\ncalc = FAIRChemCalculator(predictor, task_name=\"oc20\")\n\n\n\n\n\n\n\nNeed to install fairchem-core or get UMA access or getting permissions/401 errors?\n\nInstall the necessary packages using pip, uv etc\n\n! pip install fairchem-core fairchem-data-oc fairchem-applications-cattsunami\n\n\n\nGet access to any necessary huggingface gated models\n\nGet and login to your Huggingface account\n\nRequest access to \n\nhttps://​huggingface​.co​/facebook​/UMA\n\nCreate a Huggingface token at \n\nhttps://​huggingface​.co​/settings​/tokens/ with the permission “Permissions: Read access to contents of all public gated repos you can access”\n\nAdd the token as an environment variable using huggingface-cli login or by setting the HF_TOKEN environment variable.\n\n# Login using the huggingface-cli utility\n! huggingface-cli login\n\n# alternatively,\nimport os\nos.environ['HF_TOKEN'] = 'MY_TOKEN'\n\n","type":"content","url":"/ase-calculator","position":1},{"hierarchy":{"lvl1":"Inference using ASE and Predictor Interface","lvl2":"Default mode"},"type":"lvl2","url":"/ase-calculator#default-mode","position":2},{"hierarchy":{"lvl1":"Inference using ASE and Predictor Interface","lvl2":"Default mode"},"content":"UMA is designed for both general-purpose usage (single or batched systems) and single-system long rollout (MD simulations, relaxations, etc.). For general-purpose use, we suggest using the \n\ndefault settings. This is a good trade-off between accuracy, speed, and memory consumption and should suffice for most applications. In this setting, on a single 80GB H100 GPU, we expect a user should be able to compute on systems as large as 50k-100k neighbors (depending on their atomic density). Batching is also supported in this mode.","type":"content","url":"/ase-calculator#default-mode","position":3},{"hierarchy":{"lvl1":"Inference using ASE and Predictor Interface","lvl2":"Turbo mode"},"type":"lvl2","url":"/ase-calculator#turbo-mode","position":4},{"hierarchy":{"lvl1":"Inference using ASE and Predictor Interface","lvl2":"Turbo mode"},"content":"For long rollout trajectory use-cases, such as molecular dynamics (MD) or relaxations, we provide a special mode called turbo, which optimizes for speed but restricts the user to using a single system where the atomic composition is held constant. Turbo mode is approximately 1.5-2x faster than default mode, depending on the situation. However, batching is not supported in this mode. It can be easily activated as shown below.\n\npredictor = pretrained_mlip.get_predict_unit(\n    \"uma-s-1p1\", device=\"cuda\", inference_settings=\"turbo\"\n)\n\n\n\n","type":"content","url":"/ase-calculator#turbo-mode","position":5},{"hierarchy":{"lvl1":"Inference using ASE and Predictor Interface","lvl2":"Custom modes for advanced users"},"type":"lvl2","url":"/ase-calculator#custom-modes-for-advanced-users","position":6},{"hierarchy":{"lvl1":"Inference using ASE and Predictor Interface","lvl2":"Custom modes for advanced users"},"content":"The advanced user might quickly see that default mode and turbo mode are special cases of our \n\ninference settings api. You can customize it for your application if you understand what you are doing. The following table provides more information.\n\nSetting Flag\n\nDescription\n\ntf32\n\nenables torch \n\ntf32 format for matrix multiplication. This will speed up inference at a slight trade-off for precision. In our tests, it makes minimal difference to most applications. It is able to preserve equivariance, energy conservation for long rollouts. However, if you are computing higher order derivatives such as Hessians or other calculations that requires strict numerical precision, we recommend turning this off\n\nactivation_checkpointing\n\nthis uses a custom chunked activation checkpointing algorithm and allows significant savings in memory for a small inference speed penalty. If you are predicting on systems >1000 atoms, we recommend keeping this on. However, if you want the absolute fastest inference possible for small systems, you can turn this off\n\nmerge_mole\n\nThis is useful in long rollout applications where the system composition stays constant. By pre-merge the MoLE weights, we can save both memory and compute.\n\ncompile\n\nThis uses torch.compile to significantly speed up computation. Due to the way pytorch traces the internal graph, it requires a long compile time during the first iteration and can even recompile anytime it detected a significant change in input dimensions. It is not recommended if you are computing frequently on very different atomic systems.\n\nexternal_graph_gen\n\nOnly use this if you want to use an external graph generator. This should be rarely used except for development\n\nFor example, for an MD simulation use-case for a system of ~500 atoms, we can choose to use a custom mode like the following:\n\nfrom fairchem.core.units.mlip_unit.api.inference import InferenceSettings\n\nsettings = InferenceSettings(\n    tf32=True,\n    activation_checkpointing=False,\n    merge_mole=True,\n    compile=True,\n    external_graph_gen=False,\n    internal_graph_gen_version=2,\n)\n\npredictor = pretrained_mlip.get_predict_unit(\n    \"uma-s-1p1\", device=\"cuda\", inference_settings=settings\n)\n\n\n\n","type":"content","url":"/ase-calculator#custom-modes-for-advanced-users","position":7},{"hierarchy":{"lvl1":"Inference using ASE and Predictor Interface","lvl2":"Multi-GPU Inference"},"type":"lvl2","url":"/ase-calculator#multi-gpu-inference","position":8},{"hierarchy":{"lvl1":"Inference using ASE and Predictor Interface","lvl2":"Multi-GPU Inference"},"content":"UMA supports Graph Parallel inference natively. The graph is chunked into each rank and both the forward and backwards communication is handled by the built-in graph parallel algorithm with torch distributed. Because Multi-GPU inference requires special setup of communication protocols within a node and across nodes, we leverage \n\nray to launch Ray Actors for each GPU-rank under the hood. This allows us to seamlessly scale to any infrastructure that can run Ray.\n\nTo make things simple for the user that wants to run multi-gpu inference locally, we provide a drop-in replacement for MLIPPredictUnit, called \n\nParallelMLIPPredictUnit\n\nNote\n\nTo enable multi-GPU inference, you need to install Ray manually or through the fairchem extra dependencies option.pip install fairchem-core[extras]\n\nFor example, we can create a predictor with 8 GPU workers in a very similar way to MLIPPredictUnit and perform an MD calculation with the ASE calculator. This mode of operation is also compatible with our LAMMPS integration.from ase import units\nfrom ase.md.langevin import Langevin\nfrom fairchem.core import pretrained_mlip, FAIRChemCalculator\nimport time\n\nfrom fairchem.core.datasets.common_structures import get_fcc_crystal_by_num_atoms\n\npredictor = pretrained_mlip.get_predict_unit(\n    \"uma-s-1p1\", inference_settings=\"turbo\", device=\"cuda\", workers=1\n)\ncalc = FAIRChemCalculator(predictor, task_name=\"omat\")\n\natoms = get_fcc_crystal_by_num_atoms(8000)\natoms.calc = calc\n\ndyn = Langevin(\n    atoms,\n    timestep=0.1 * units.fs,\n    temperature_K=400,\n    friction=0.001 / units.fs,\n)\n# warmup 10 steps\ndyn.run(steps=10)\nstart_time = time.time()\ndyn.attach(\n    lambda: print(\n        f\"Step: {dyn.get_number_of_steps()}, E: {atoms.get_potential_energy():.3f} eV, \"\n        f\"QPS: {dyn.get_number_of_steps()/(time.time()-start_time):.2f}\"\n    ),\n    interval=1,\n)\ndyn.run(steps=1000)\n\nTip\n\nThis will automatically create a Ray server on your local machine and use a local client to connect to it. If you have set up a Ray cluster, you can leverage it to run parallel inference on as many nodes as you like.","type":"content","url":"/ase-calculator#multi-gpu-inference","position":9},{"hierarchy":{"lvl1":"FAIRChem and Custom Datasets"},"type":"lvl1","url":"/ase-dataset-creation","position":0},{"hierarchy":{"lvl1":"FAIRChem and Custom Datasets"},"content":"","type":"content","url":"/ase-dataset-creation","position":1},{"hierarchy":{"lvl1":"FAIRChem and Custom Datasets","lvl2":"Datasets in FAIRChem"},"type":"lvl2","url":"/ase-dataset-creation#datasets-in-fairchem","position":2},{"hierarchy":{"lvl1":"FAIRChem and Custom Datasets","lvl2":"Datasets in FAIRChem"},"content":"fairchem provides training and evaluation code for tasks and models that take arbitrary chemical structures as input to predict energies, forces, positions, and stresses. It can be used as a base scaffold for research projects. For an overview of tasks, data, and metrics, please read the documentation and respective papers:\n\nOC20\n\nOC22\n\nODAC23\n\nOC20Dense\n\nOC20NEB\n\nOMat24\n\nOMol25\n\nOMC25\n\nNote\n\nThere are multiple ways to train and evaluate FAIRChem models on data other than OC20 and OC22. Writing an LMDB is the most performant option. However, ASE-based dataset formats are also included as a convenience for people with existing data who simply want to try fairchem tools without needing to learn about LMDBs.","type":"content","url":"/ase-dataset-creation#datasets-in-fairchem","position":3},{"hierarchy":{"lvl1":"FAIRChem and Custom Datasets","lvl2":"Custom ASE Databases"},"type":"lvl2","url":"/ase-dataset-creation#custom-ase-databases","position":4},{"hierarchy":{"lvl1":"FAIRChem and Custom Datasets","lvl2":"Custom ASE Databases"},"content":"If your data is already in an \n\nASE Database, no additional preprocessing is necessary before running training/prediction!\n\nTip\n\nAlthough the ASE DB backends may not be sufficiently high throughput for all use cases, they are generally considered “fast enough” to train on a reasonably-sized dataset with 1-2 GPUs or predict with a single GPU. If you want to effectively utilize more resources than this, consider writing your data to an LMDB.\n\nPerformance Tip\n\nIf your dataset is small enough to fit in CPU memory, use the keep_in_memory: True option to avoid I/O bottlenecks and significantly speed up training.\n\nTo use this dataset, we will just have to change our config files to use the ASE DB Dataset rather than the LMDB Dataset:dataset:\n  format: ase_db\n  train:\n    src: # The path/address to your ASE DB\n    connect_args:\n      # Keyword arguments for ase.db.connect()\n    select_args:\n      # Keyword arguments for ase.db.select()\n      # These can be used to query/filter the ASE DB\n    a2g_args:\n      r_energy: True\n      r_forces: True\n      # Set these if you want to train on energy/forces\n      # Energy/force information must be in the ASE DB!\n    keep_in_memory: False # Keeping the dataset in memory reduces random reads and is extremely fast, but this is only feasible for relatively small datasets!\n    include_relaxed_energy: False # Read the last structure's energy and save as \"y_relaxed\" for IS2RE-Direct training\n  val:\n    src:\n    a2g_args:\n      r_energy: True\n      r_forces: True\n  test:\n    src:\n    a2g_args:\n      r_energy: False\n      r_forces: False\n      # It is not necessary to have energy or forces if you are just making predictions.","type":"content","url":"/ase-dataset-creation#custom-ase-databases","position":5},{"hierarchy":{"lvl1":"FAIRChem and Custom Datasets","lvl2":"Using ASE-Readable Files"},"type":"lvl2","url":"/ase-dataset-creation#using-ase-readable-files","position":6},{"hierarchy":{"lvl1":"FAIRChem and Custom Datasets","lvl2":"Using ASE-Readable Files"},"content":"It is possible to train/predict directly on ASE-readable files.\n\nWarning\n\nThis is only recommended for smaller datasets, as directories of many small files do not scale efficiently on all computing infrastructures.\n\nThere are two options for loading data with the ASE reader:","type":"content","url":"/ase-dataset-creation#using-ase-readable-files","position":7},{"hierarchy":{"lvl1":"FAIRChem and Custom Datasets","lvl3":"Single-Structure Files","lvl2":"Using ASE-Readable Files"},"type":"lvl3","url":"/ase-dataset-creation#single-structure-files","position":8},{"hierarchy":{"lvl1":"FAIRChem and Custom Datasets","lvl3":"Single-Structure Files","lvl2":"Using ASE-Readable Files"},"content":"This dataset assumes a single structure will be obtained from each file:dataset:\n  format: ase_read\n  train:\n    src: # The folder that contains ASE-readable files\n    pattern: # Pattern matching each file you want to read (e.g. \"*/POSCAR\"). Search recursively with two wildcards: \"**/*.cif\".\n    include_relaxed_energy: False # Read the last structure's energy and save as \"y_relaxed\" for IS2RE-Direct training\n\n    ase_read_args:\n      # Keyword arguments for ase.io.read()\n    a2g_args:\n      # Include energy and forces for training purposes\n      # If True, the energy/forces must be readable from the file (ex. OUTCAR)\n      r_energy: True\n      r_forces: True\n    keep_in_memory: False","type":"content","url":"/ase-dataset-creation#single-structure-files","position":9},{"hierarchy":{"lvl1":"FAIRChem and Custom Datasets","lvl3":"Multi-structure Files","lvl2":"Using ASE-Readable Files"},"type":"lvl3","url":"/ase-dataset-creation#multi-structure-files","position":10},{"hierarchy":{"lvl1":"FAIRChem and Custom Datasets","lvl3":"Multi-structure Files","lvl2":"Using ASE-Readable Files"},"content":"This dataset supports reading files that each contain multiple structures (for example, an ASE .traj file).\n\nTip\n\nUsing an index file, which tells the dataset how many structures each file contains, is recommended. Otherwise, the dataset is forced to load every file at startup and count the number of structures!dataset:\n  format: ase_read_multi\n  train:\n    index_file: Filepath to an index file which contains each filename and the number of structures in each file. e.g.:\n            /path/to/relaxation1.traj 200\n            /path/to/relaxation2.traj 150\n            ...\n\n    # If using an index file, the src and pattern are not necessary\n    src: # The folder that contains ASE-readable files\n    pattern: # Pattern matching each file you want to read (e.g. \"*.traj\"). Search recursively with two wildcards: \"**/*.xyz\".\n\n    ase_read_args:\n      # Keyword arguments for ase.io.read()\n    a2g_args:\n      # Include energy and forces for training purposes\n      r_energy: True\n      r_forces: True\n    keep_in_memory: False","type":"content","url":"/ase-dataset-creation#multi-structure-files","position":11},{"hierarchy":{"lvl1":"Batch Inference with UMA Models"},"type":"lvl1","url":"/batch-inference","position":0},{"hierarchy":{"lvl1":"Batch Inference with UMA Models"},"content":"Need to install fairchem-core or get UMA access or getting permissions/401 errors?\n\nInstall the necessary packages using pip, uv etc\n\n! pip install fairchem-core fairchem-data-oc fairchem-applications-cattsunami\n\n\n\nGet access to any necessary huggingface gated models\n\nGet and login to your Huggingface account\n\nRequest access to \n\nhttps://​huggingface​.co​/facebook​/UMA\n\nCreate a Huggingface token at \n\nhttps://​huggingface​.co​/settings​/tokens/ with the permission “Permissions: Read access to contents of all public gated repos you can access”\n\nAdd the token as an environment variable using huggingface-cli login or by setting the HF_TOKEN environment variable.\n\n# Login using the huggingface-cli utility\n! huggingface-cli login\n\n# alternatively,\nimport os\nos.environ['HF_TOKEN'] = 'MY_TOKEN'\n\n\n\nIf your application requires predictions over many systems, you can run batch inference using UMA models to use compute more efficiently and improve GPU utilization.\n\nTip\n\nTo learn more about the different inference settings supported, see the \n\nPrediction interface documentation.","type":"content","url":"/batch-inference","position":1},{"hierarchy":{"lvl1":"Batch Inference with UMA Models","lvl2":"Generate Batches at Runtime"},"type":"lvl2","url":"/batch-inference#generate-batches-at-runtime","position":2},{"hierarchy":{"lvl1":"Batch Inference with UMA Models","lvl2":"Generate Batches at Runtime"},"content":"The recommended way to create batches at runtime is to convert ASE Atoms objects into AtomicData\nas follows,from ase.build import bulk, molecule\nfrom fairchem.core import pretrained_mlip\nfrom fairchem.core.datasets.atomic_data import AtomicData, atomicdata_list_to_batch\n\natoms_list = [bulk(\"Pt\"), bulk(\"Cu\"), bulk(\"NaCl\", crystalstructure=\"rocksalt\", a=2.0)]\n\n# you need to assign the task_name desired\natomic_data_list = [\n    AtomicData.from_ase(atoms, task_name=\"omat\") for atoms in atoms_list\n]\nbatch = atomicdata_list_to_batch(atomic_data_list)\n\npredictor = pretrained_mlip.get_predict_unit(\"uma-s-1p1\", device=\"cuda\")\npreds = predictor.predict(batch)\n\nThe predictions are returned in a dictionary with single torch.Tensor value for each property predicted.\nsystem level properties can be accessed using the same index for the system in the atomic_data_list, atom level\nproperties like forces can be obtained for a single system in the batch using the batch.batch attribute,# energy of the first system in the batch\npreds[\"energy\"][0]\n\n# forces of the first system in the batch\npreds[\"forces\"][batch.batch == 0]","type":"content","url":"/batch-inference#generate-batches-at-runtime","position":3},{"hierarchy":{"lvl1":"Batch Inference with UMA Models","lvl2":"Batch Inference Using a Dataset and DataLoader"},"type":"lvl2","url":"/batch-inference#batch-inference-using-a-dataset-and-dataloader","position":4},{"hierarchy":{"lvl1":"Batch Inference with UMA Models","lvl2":"Batch Inference Using a Dataset and DataLoader"},"content":"If you are running predictions over more structures than you can fit in memory, you can run inference using a torch DataLoader:from torch.utils.data import DataLoader\nfrom fairchem.core.datasets import AseDBDataset\nfrom fairchem.core.datasets.atomic_data import atomicdata_list_to_batch\n\ndataset = AseDBDataset(\n    config=dict(src=\"path/to/your/dataset.aselmdb\", a2g_args=dict(task_name=\"omol\"))\n)\nloader = DataLoader(dataset, batch_size=200, collate_fn=atomicdata_list_to_batch)\npredictor = pretrained_mlip.get_predict_unit(\"uma-s-1p1\", device=\"cuda\")\n\nfor batch in loader:\n    preds = predictor.predict(batch)","type":"content","url":"/batch-inference#batch-inference-using-a-dataset-and-dataloader","position":5},{"hierarchy":{"lvl1":"Batch Inference with UMA Models","lvl2":"Inference over Heterogeneous Batches"},"type":"lvl2","url":"/batch-inference#inference-over-heterogeneous-batches","position":6},{"hierarchy":{"lvl1":"Batch Inference with UMA Models","lvl2":"Inference over Heterogeneous Batches"},"content":"Note\n\nFor cases where you want to batch systems to be computed with different task predictions (e.g., molecules and materials), you can take advantage of UMA models and do it in a single batch.from ase.build import bulk, molecule\nfrom fairchem.core import pretrained_mlip\nfrom fairchem.core.datasets.atomic_data import AtomicData, atomicdata_list_to_batch\n\n# a molecule\nh2o = molecule(\"H2O\")\nh2o.info.update({\"charge\": 0, \"spin\": 1})\n\n# a bulk\npt = bulk(\"Pt\")\n\n# a catalytic surface\nslab = fcc100(\"Cu\", (3, 3, 3), vacuum=8, periodic=True)\nadsorbate = molecule(\"CO\")\nadd_adsorbate(slab, adsorbate, 2.0, \"bridge\")\n\natomic_data_list = [\n    # note that we put the molecule in a large box\n    AtomicData.from_ase(\n        h2o, task_name=\"omol\", r_data_keys=[\"spin\", \"charge\"], molecule_cell_size=12\n    ),\n    AtomicData.from_ase(pt, task_name=\"omat\"),\n    AtomicData.from_ase(slab, task_name=\"oc20\"),\n]\nbatch = atomicdata_list_to_batch(atomic_data_list)\n\npredictions = predictor.predict(batch)","type":"content","url":"/batch-inference#inference-over-heterogeneous-batches","position":7},{"hierarchy":{"lvl1":"Evaluating Pretrained Models"},"type":"lvl1","url":"/evaluation","position":0},{"hierarchy":{"lvl1":"Evaluating Pretrained Models"},"content":"FAIRChem v2 provides a number of methods used to benchmark and evaluate the UMA models that will be helpful for apples-to-apples comparisons with the paper results.","type":"content","url":"/evaluation","position":1},{"hierarchy":{"lvl1":"Evaluating Pretrained Models","lvl2":"Running Model Evaluations"},"type":"lvl2","url":"/evaluation#running-model-evaluations","position":2},{"hierarchy":{"lvl1":"Evaluating Pretrained Models","lvl2":"Running Model Evaluations"},"content":"To evaluate a UMA model using a pre-existing configuration file, follow these steps. Example configuration files used to evaluate UMA models are stored in configs/uma/evaluate.\n\nRun the evaluation script:fairchem --config evaluation_config.yaml\n\nReplace evaluation_config.yaml with the desired config file. For example, configs/uma/evaluate/uma_conserving.yaml\n\nTip\n\nResults will be logged according to the specified logger. We currently only support Weights and Biases.","type":"content","url":"/evaluation#running-model-evaluations","position":3},{"hierarchy":{"lvl1":"Evaluating Pretrained Models","lvl2":"Evaluation Configuration File Format"},"type":"lvl2","url":"/evaluation#evaluation-configuration-file-format","position":4},{"hierarchy":{"lvl1":"Evaluating Pretrained Models","lvl2":"Evaluation Configuration File Format"},"content":"Evaluation configuration files are written in Hydra YAML format and specify how a model evaluation should be run. UMA evaluation configuration files, which can be used as templates to evaluate other models if needed, are located in configs/uma/evaluate/.","type":"content","url":"/evaluation#evaluation-configuration-file-format","position":5},{"hierarchy":{"lvl1":"Evaluating Pretrained Models","lvl3":"Top-Level Keys","lvl2":"Evaluation Configuration File Format"},"type":"lvl3","url":"/evaluation#top-level-keys","position":6},{"hierarchy":{"lvl1":"Evaluating Pretrained Models","lvl3":"Top-Level Keys","lvl2":"Evaluation Configuration File Format"},"content":"Similar to training configuration files, the only allowed top-level keys are the job and runner keys as well interpolation keys that are resolved at runtime.\n\njob: Contains all settings related to the evaluation job itself, including model, data, and logger configuration.\n\nrunner: Contains settings for the evaluation runner, such as which script to use and runtime options.\n\nImportant configuration options are nested under these keys as follows:","type":"content","url":"/evaluation#top-level-keys","position":7},{"hierarchy":{"lvl1":"Evaluating Pretrained Models","lvl3":"Under job:","lvl2":"Evaluation Configuration File Format"},"type":"lvl3","url":"/evaluation#under-job","position":8},{"hierarchy":{"lvl1":"Evaluating Pretrained Models","lvl3":"Under job:","lvl2":"Evaluation Configuration File Format"},"content":"Specifications of how to run the actual job. The configuration options are the same here as those in a training job. Some notable flags are detailed below:\n\ndevice_type: The device to run model inference on (e.g., CUDA or CPU)\n\nscheduler: The compute scheduler specifications\n\nlogger: Configuration for logging results\n\ntype: Logger type (e.g., wandb)\n\nproject: Logging project name\n\nentity: (Optional) Logger entity/user\n\nrun_dir: Directory where results and logs will be saved","type":"content","url":"/evaluation#under-job","position":9},{"hierarchy":{"lvl1":"Evaluating Pretrained Models","lvl3":"Under runner:","lvl2":"Evaluation Configuration File Format"},"type":"lvl3","url":"/evaluation#under-runner","position":10},{"hierarchy":{"lvl1":"Evaluating Pretrained Models","lvl3":"Under runner:","lvl2":"Evaluation Configuration File Format"},"content":"The actual benchmark details such as model checkpoint and the dataset are specified under the runner flag. An evaluation run should use the EvalRunner class which relies on an MLIPEvalUnit to run inference using a pretrained model.\n\ndataloader: Dataloader specification for the evaluation dataset\n\neval_unit: The specification of the MLIPEvalUnit to be used\n\ntasks: The prediction task configuration. In almost all cases, these should be loaded from a model checkpoint using the fairchem.core.units.mlip_unit.utils.load_tasks function\n\nmodel: Defines how to load a pretrained model. We recommend using the fairchem.core.units.mlip_unit.mlip_unit.load_inference_model function","type":"content","url":"/evaluation#under-runner","position":11},{"hierarchy":{"lvl1":"Evaluating Pretrained Models","lvl3":"Using the defaults Key to Define Config Groups","lvl2":"Evaluation Configuration File Format"},"type":"lvl3","url":"/evaluation#using-the-defaults-key-to-define-config-groups","position":12},{"hierarchy":{"lvl1":"Evaluating Pretrained Models","lvl3":"Using the defaults Key to Define Config Groups","lvl2":"Evaluation Configuration File Format"},"content":"The defaults key is a Hydra feature that allows you to compose configuration files from modular config groups. Each entry under defaults refers to a config group (such as model, data, or other reusable components) that is merged into the final configuration at runtime. This makes it easy to swap out models, datasets, or other settings without duplicating configuration code.\n\nExample Config Groups\n\nFor example, in the UMA evaluation configs we have set up the following config groups and defaults:defaults:\n  - _self_\n  - model: omc_conserving\n  - data: my_eval_data\n\nThis will include the configuration from configs/uma/evaluate/model/omc_conserving.yaml and configs/uma/evaluate/data/my_eval_data.yaml into the main config. The _self_ entry ensures the current file’s contents are included.\n\nYou can create new config groups or override existing ones by changing the entries under defaults:defaults:\n  - cluster: Configuration settings for a particular compute cluster\n  - dataset: Configuration settings for the evaluation dataset\n  - checkpoint: Configuration settings of the pretrained model checkpoint\n  - _self_\n\nUsing config groups allows you to easily override defaults in the CLI. For example:fairchem --config evaluation_config.yaml cluster=cluster_config checkpoint=checkpoint_config\n\nWhere cluster_config and checkpoint_config are cluster and checkpoint configuration files written to directories under cluster and checkpoint respectively. See the files in configs/uma/evaluate as a full example.","type":"content","url":"/evaluation#using-the-defaults-key-to-define-config-groups","position":13},{"hierarchy":{"lvl1":"Fine-tuning"},"type":"lvl1","url":"/fine-tuning","position":0},{"hierarchy":{"lvl1":"Fine-tuning"},"content":"This repo provides a number of scripts to quickly fine-tune a model using a custom ASE LMDB dataset. These scripts are merely for convenience and fine-tuning uses the exact same tooling and infrastructure as our standard training (see Training section). Training in the fairchem repo uses the fairchem CLI tool and configs are in \n\nHydra yaml format.\n\nNote\n\nTraining datasets must be in the \n\nASE-lmdb format. For UMA models, we provide a simple script to help generate ASE-lmdb datasets from a variety of input formats (CIFs, traj, extxyz, etc.) as well as a fine-tuning YAML config that can be directly used for fine-tuning.","type":"content","url":"/fine-tuning","position":1},{"hierarchy":{"lvl1":"Fine-tuning","lvl2":"Generating Training/Fine-tuning Datasets"},"type":"lvl2","url":"/fine-tuning#generating-training-fine-tuning-datasets","position":2},{"hierarchy":{"lvl1":"Fine-tuning","lvl2":"Generating Training/Fine-tuning Datasets"},"content":"First we need to generate a dataset in the aselmdb format for fine-tuning.\n\nTip\n\nThe only requirement is that you have input files that can be read as ASE atoms objects by the ase.io.read routine and that they contain energy (forces, stress) in the correct format. For concrete examples, refer to the test at tests/core/scripts/test_create_finetune_dataset.py.\n\nFirst you should checkout the fairchem repo and install it to access the scripts\n\ngit clone git@github.com:facebookresearch/fairchem.git\n\npip install -e fairchem/src/packages/fairchem-core[dev]\n\n\n\nRun this script to create the aselmdbs as well as a set of templated yamls for finetuning, we will use a few dummy structures for demonstration purposes\n\nimport os\nos.chdir('../../../../fairchem')\n! python src/fairchem/core/scripts/create_uma_finetune_dataset.py --train-dir docs/core/common_tasks/finetune_assets/train/ --val-dir docs/core/common_tasks/finetune_assets/val --output-dir /tmp/bulk --uma-task=omat --regression-task e\n\n\n\n\n\n\n\n\n\nWarning\n\nTask Selection: The uma-task can be one of: omol, odac, oc20, omat, omc. While UMA was trained in a multi-task fashion, we ONLY support fine-tuning on a single UMA task at a time. Multi-task training can become very complicated! Feel free to contact us on GitHub if you have a special use-case for multi-task fine-tuning, or refer to the training configs in /training_release to mimic the original UMA training configs.\n\nRegression Task Options\n\nThe regression-task can be one of:\n\ne: Energy only\n\nef: Energy + forces\n\nefs: Energy + forces + stress\n\nChoose based on the data you have available in the ASE db. For example, some aperiodic DFT codes only support energy/forces and not gradients, and some very fancy codes like QMC only produce energies.\n\nNote: Even if you train on just energy or energy/forces, all gradients (forces/stresses) will be computable via the model gradients.\n\nThis will generate a folder of LMDBs and a uma_sm_finetune_template.yaml that you can run directly with the fairchem CLI to start training.\n\nTip\n\nIf you want to only create the ASE LMDBs, you can use src/fairchem/core/scripts/create_finetune_dataset.py which is called by create_uma_finetune_dataset.py.","type":"content","url":"/fine-tuning#generating-training-fine-tuning-datasets","position":3},{"hierarchy":{"lvl1":"Fine-tuning","lvl2":"Model Fine-tuning (Default Settings)"},"type":"lvl2","url":"/fine-tuning#model-fine-tuning-default-settings","position":4},{"hierarchy":{"lvl1":"Fine-tuning","lvl2":"Model Fine-tuning (Default Settings)"},"content":"The previous step should have generated some YAML files to get you started on fine-tuning. You can simply run this with the fairchem CLI. The default is configured to run locally on 1 GPU.\n\n! fairchem -c /tmp/bulk/uma_sm_finetune_template.yaml\n\n\n\n","type":"content","url":"/fine-tuning#model-fine-tuning-default-settings","position":5},{"hierarchy":{"lvl1":"Fine-tuning","lvl2":"Advanced Configuration"},"type":"lvl2","url":"/fine-tuning#advanced-configuration","position":6},{"hierarchy":{"lvl1":"Fine-tuning","lvl2":"Advanced Configuration"},"content":"The scripts provide a simple way to get started on fine-tuning, but likely for your own use cases you will need to modify the parameters. The configuration uses \n\nHydra-style YAMLs.\n\nTip\n\nTo modify the generated YAMLs, you can either edit the files directly or use \n\nHydra override notation. Changing parameters on the command line is very simple:\n\n! fairchem -c /tmp/bulk/uma_sm_finetune_template.yaml epochs=2 lr=2e-4 job.run_dir=/tmp/finetune_dir +job.timestamp_id=some_id\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe basic YAML configuration looks like the following:job:\n  device_type: CUDA\n  scheduler:\n    mode: LOCAL\n    ranks_per_node: 1\n    num_nodes: 1\n  debug: True\n  run_dir: /tmp/uma_finetune_runs/\n  run_name: uma_finetune\n  logger:\n    _target_: fairchem.core.common.logger.WandBSingletonLogger.init_wandb\n    _partial_: true\n    entity: example\n    project: uma_finetune\n\n\nbase_model_name: uma-s-1p1\nmax_neighbors: 300\nepochs: 1\nsteps: null\nbatch_size: 2\nlr: 4e-4\n\ntrain_dataloader ...\neval_dataloader ...\nrunner ...\n\nConfiguration Parameters\n\nbase_model_name: Refers to a model name that can be retrieved from \n\nHuggingFace. If you want to use your custom UMA checkpoint, provide the path directly in the runner:model:\n  _target_: fairchem.core.units.mlip_unit.mlip_unit.initialize_finetuning_model\n  checkpoint_location: /path/to/your/checkpoint.pt\n\nmax_neighbors: The number of neighbors used for the equivariant SO2 convolutions. 300 is the default used in UMA training, but if you don’t have a lot of memory, 100 is usually fine to ensure smoothness of the potential (see the \n\nESEN paper).\n\nepochs, steps: Choose to either run for an integer number of epochs or steps. Only 1 can be specified; the other must be null.\n\nbatch_size: In this configuration we use the batch sampler. Start with the largest batch size that can fit on your system without running out of memory. However, don’t use a batch size so large that you complete training in very few steps. The optimal batch size is usually the one that minimizes the final validation loss for a fixed compute budget.\n\nlr, weight_decay: These are standard learning parameters. The recommended values we use are the defaults.","type":"content","url":"/fine-tuning#advanced-configuration","position":7},{"hierarchy":{"lvl1":"Fine-tuning","lvl3":"Logging and Artifacts","lvl2":"Advanced Configuration"},"type":"lvl3","url":"/fine-tuning#logging-and-artifacts","position":8},{"hierarchy":{"lvl1":"Fine-tuning","lvl3":"Logging and Artifacts","lvl2":"Advanced Configuration"},"content":"For logging and checkpoints, all artifacts are stored in the location specified in job.run_dir. The visual logger we support is \n\nWeights and Biases.\n\nWarning\n\nTensorboard is no longer supported. You must set up your W&B account separately and job.debug must be set to False for W&B logging to work.","type":"content","url":"/fine-tuning#logging-and-artifacts","position":9},{"hierarchy":{"lvl1":"Fine-tuning","lvl3":"Distributed Training","lvl2":"Advanced Configuration"},"type":"lvl3","url":"/fine-tuning#distributed-training","position":10},{"hierarchy":{"lvl1":"Fine-tuning","lvl3":"Distributed Training","lvl2":"Advanced Configuration"},"content":"We support multi-GPU distributed training without additional infrastructure and multi-node distributed training on \n\nSLURM only.\n\nMulti-GPU locally: Simply set job.scheduler.ranks_per_node=N where N is the number of GPUs you want to train on.\n\nMulti-node on SLURM: Change job.scheduler.mode=SLURM and set both job.scheduler.ranks_per_node and job.scheduler.num_nodes to the desired values.\n\nNote\n\nThe run_dir must be in a shared network accessible mount for multi-node training to work.","type":"content","url":"/fine-tuning#distributed-training","position":11},{"hierarchy":{"lvl1":"Fine-tuning","lvl3":"Resuming Runs","lvl2":"Advanced Configuration"},"type":"lvl3","url":"/fine-tuning#resuming-runs","position":12},{"hierarchy":{"lvl1":"Fine-tuning","lvl3":"Resuming Runs","lvl2":"Advanced Configuration"},"content":"To resume from a checkpoint in the middle of a run, find the checkpoint folder at the step you want and use the same fairchem command:\n\n! fairchem -c /tmp/finetune_dir/some_id/checkpoints/final/resume.yaml\n\n\n\n","type":"content","url":"/fine-tuning#resuming-runs","position":13},{"hierarchy":{"lvl1":"Fine-tuning","lvl3":"Running Inference on the Fine-tuned Model","lvl2":"Advanced Configuration"},"type":"lvl3","url":"/fine-tuning#running-inference-on-the-fine-tuned-model","position":14},{"hierarchy":{"lvl1":"Fine-tuning","lvl3":"Running Inference on the Fine-tuned Model","lvl2":"Advanced Configuration"},"content":"Inference is run in the same way as the UMA models, except you need to load the checkpoint from a local path.\n\nWarning\n\nYou must use the same task that you used for fine-tuning!\n\nfrom fairchem.core.units.mlip_unit import load_predict_unit\nfrom fairchem.core import FAIRChemCalculator\n\npredictor = load_predict_unit(\"/tmp/finetune_dir/some_id/checkpoints/final/inference_ckpt.pt\")\ncalc = FAIRChemCalculator(predictor, task_name=\"omat\")\n\n","type":"content","url":"/fine-tuning#running-inference-on-the-fine-tuned-model","position":15},{"hierarchy":{"lvl1":"Batched Atomic Simulations with InferenceBatcher"},"type":"lvl1","url":"/inference-batcher","position":0},{"hierarchy":{"lvl1":"Batched Atomic Simulations with InferenceBatcher"},"content":"Need to install fairchem-core or get UMA access or getting permissions/401 errors?\n\nInstall the necessary packages using pip, uv etc\n\n! pip install fairchem-core fairchem-data-oc fairchem-applications-cattsunami\n\n\n\nGet access to any necessary huggingface gated models\n\nGet and login to your Huggingface account\n\nRequest access to \n\nhttps://​huggingface​.co​/facebook​/UMA\n\nCreate a Huggingface token at \n\nhttps://​huggingface​.co​/settings​/tokens/ with the permission “Permissions: Read access to contents of all public gated repos you can access”\n\nAdd the token as an environment variable using huggingface-cli login or by setting the HF_TOKEN environment variable.\n\n# Login using the huggingface-cli utility\n! huggingface-cli login\n\n# alternatively,\nimport os\nos.environ['HF_TOKEN'] = 'MY_TOKEN'\n\n\n\nWarning\n\nThe InferenceBatcher class and underlying concurrent batching implementations are experimental and under current development. The API may change. If you have suggestions for improvements, please open an issue or submit a pull request.\n\nWhen running many independent ASE calculations (relaxations, molecular dynamics, etc.) on small to medium-sized systems, you can significantly improve GPU utilization by batching model inference calls together. The InferenceBatcher class provides a high-level API to do this with minimal code changes.\n\nThe key idea is simple: instead of running each simulation sequentially, InferenceBatcher collects inference requests from multiple concurrent simulations and batches them together for more efficient GPU computation.","type":"content","url":"/inference-batcher","position":1},{"hierarchy":{"lvl1":"Batched Atomic Simulations with InferenceBatcher","lvl2":"Basic Setup"},"type":"lvl2","url":"/inference-batcher#basic-setup","position":2},{"hierarchy":{"lvl1":"Batched Atomic Simulations with InferenceBatcher","lvl2":"Basic Setup"},"content":"To use InferenceBatcher, you need to:\n\nCreate a predict unit as usual\n\nWrap it with InferenceBatcher\n\nUse batcher.batch_predict_unit instead of the original predict unit in your simulation functionsfrom fairchem.core import pretrained_mlip\nfrom fairchem.core.calculate import FAIRChemCalculator, InferenceBatcher\n\n# Create a predict unit\npredict_unit = pretrained_mlip.get_predict_unit(\"uma-s-1p1\")\n\n# Wrap it with InferenceBatcher\nbatcher = InferenceBatcher(\n    predict_unit, concurrency_backend_options=dict(max_workers=32)\n)\n\nTip\n\nThe max_workers parameter controls how many concurrent simulations can run concurrently. Adjust this based on your system’s memory and the size of your structures.","type":"content","url":"/inference-batcher#basic-setup","position":3},{"hierarchy":{"lvl1":"Batched Atomic Simulations with InferenceBatcher","lvl2":"Writing Simulation Functions"},"type":"lvl2","url":"/inference-batcher#writing-simulation-functions","position":4},{"hierarchy":{"lvl1":"Batched Atomic Simulations with InferenceBatcher","lvl2":"Writing Simulation Functions"},"content":"The only requirement for using InferenceBatcher is to write your simulation logic as a function that takes an Atoms object and a predict unit as arguments:from ase.build import bulk\nfrom ase.filters import FrechetCellFilter\nfrom ase.optimize import LBFGS\n\n\ndef run_relaxation(atoms, predict_unit):\n    \"\"\"Run a structure relaxation and return the final energy.\"\"\"\n    calc = FAIRChemCalculator(predict_unit, task_name=\"omat\")\n    atoms.calc = calc\n    opt = LBFGS(FrechetCellFilter(atoms), logfile=None)\n    opt.run(fmax=0.02, steps=100)\n    return atoms.get_potential_energy()","type":"content","url":"/inference-batcher#writing-simulation-functions","position":5},{"hierarchy":{"lvl1":"Batched Atomic Simulations with InferenceBatcher","lvl2":"Running Batched Relaxations"},"type":"lvl2","url":"/inference-batcher#running-batched-relaxations","position":6},{"hierarchy":{"lvl1":"Batched Atomic Simulations with InferenceBatcher","lvl2":"Running Batched Relaxations"},"content":"Once you have your simulation function, you can run it in batched mode using the executor’s map or submit methods:","type":"content","url":"/inference-batcher#running-batched-relaxations","position":7},{"hierarchy":{"lvl1":"Batched Atomic Simulations with InferenceBatcher","lvl3":"Using executor.map","lvl2":"Running Batched Relaxations"},"type":"lvl3","url":"/inference-batcher#using-executor-map","position":8},{"hierarchy":{"lvl1":"Batched Atomic Simulations with InferenceBatcher","lvl3":"Using executor.map","lvl2":"Running Batched Relaxations"},"content":"from functools import partial\n\n# Create a list of structures to relax\nprim_atoms = [\n    bulk(\"Cu\"),\n    bulk(\"MgO\", \"rocksalt\", a=4.2),\n    bulk(\"Si\", \"diamond\", a=5.43),\n    bulk(\"NaCl\", \"rocksalt\", a=3.8),\n]\n\natoms_list = [make_supercell(atoms, 3 * np.identity(3)) for atoms in prim_atoms]\n\nfor atoms in atoms_list:\n    atoms.rattle(0.1)\n\n# Create a partial function with the batch predict unit\nrun_relaxation_batched = partial(\n    run_relaxation, predict_unit=batcher.batch_predict_unit\n)\n\n# Run all relaxations in parallel with batched inference\nrelaxed_energies = list(batcher.executor.map(run_relaxation_batched, atoms_list))","type":"content","url":"/inference-batcher#using-executor-map","position":9},{"hierarchy":{"lvl1":"Batched Atomic Simulations with InferenceBatcher","lvl3":"Using executor.submit for more control","lvl2":"Running Batched Relaxations"},"type":"lvl3","url":"/inference-batcher#using-executor-submit-for-more-control","position":10},{"hierarchy":{"lvl1":"Batched Atomic Simulations with InferenceBatcher","lvl3":"Using executor.submit for more control","lvl2":"Running Batched Relaxations"},"content":"If you need more control over the execution or want to process results as they complete:# Create a new list of structures to relax\natoms_list = [make_supercell(atoms, 3 * np.identity(3)) for atoms in prim_atoms]\n\nfor atoms in atoms_list:\n    atoms.rattle(0.1)\n\n# Submit all jobs\nfutures = [\n    batcher.executor.submit(run_relaxation, atoms, batcher.batch_predict_unit)\n    for atoms in atoms_list\n]\n\n# Collect results\nrelaxed_energies = [future.result() for future in futures]","type":"content","url":"/inference-batcher#using-executor-submit-for-more-control","position":11},{"hierarchy":{"lvl1":"Batched Atomic Simulations with InferenceBatcher","lvl2":"Running Batched Molecular Dynamics"},"type":"lvl2","url":"/inference-batcher#running-batched-molecular-dynamics","position":12},{"hierarchy":{"lvl1":"Batched Atomic Simulations with InferenceBatcher","lvl2":"Running Batched Molecular Dynamics"},"content":"The same pattern works for molecular dynamics simulations:from ase import units\nfrom ase.md.langevin import Langevin\nfrom ase.md.velocitydistribution import MaxwellBoltzmannDistribution\n\n\ndef run_nvt_md(atoms, predict_unit, temperature, traj_fname):\n    \"\"\"Run NVT molecular dynamics simulation.\"\"\"\n    calc = FAIRChemCalculator(predict_unit, task_name=\"omat\")\n    atoms.calc = calc\n    MaxwellBoltzmannDistribution(atoms, temperature, force_temp=True)\n    dyn = Langevin(\n        atoms,\n        timestep=2 * units.fs,\n        temperature_K=temperature,\n        friction=0.1,\n        trajectory=traj_fname,\n        loginterval=5,\n    )\n    dyn.run(100)\n\n\n# Run batched MD simulations\nrun_md_batched = partial(\n    run_nvt_md, predict_unit=batcher.batch_predict_unit, temperature=300\n)\n\nfutures = [\n    batcher.executor.submit(run_md_batched, atoms, traj_fname=f\"traj_{i}.traj\")\n    for i, atoms in enumerate(atoms_list)\n]\n\n# Wait for all simulations to complete\n[future.result() for future in futures]","type":"content","url":"/inference-batcher#running-batched-molecular-dynamics","position":13},{"hierarchy":{"lvl1":"Batched Atomic Simulations with InferenceBatcher","lvl2":"When to Use InferenceBatcher"},"type":"lvl2","url":"/inference-batcher#when-to-use-inferencebatcher","position":14},{"hierarchy":{"lvl1":"Batched Atomic Simulations with InferenceBatcher","lvl2":"When to Use InferenceBatcher"},"content":"InferenceBatcher is most beneficial when:\n\nRunning many independent simulations on small to medium-sized systems\n\nGPU utilization is low with serial execution\n\nEach individual simulation has many inference steps (relaxations, MD)\n\nNote\n\nWhen running batch inference over static structures, consider using the \n\nbatch inference approach with AtomicData directly instead. For single large systems, consider using the MLIPParallelPredictUnit for graph parallel inference.","type":"content","url":"/inference-batcher#when-to-use-inferencebatcher","position":15},{"hierarchy":{"lvl1":"LAMMPS Integration"},"type":"lvl1","url":"/lammps","position":0},{"hierarchy":{"lvl1":"LAMMPS Integration"},"content":"We provide an integration with the \n\nLAMMPS Molecular Simulator through the \n\nfix external command. This simple integration hands control of the neighborlist (graph) generation, parallelism, energy, force, and stress calculations all to UMA.\n\nTip\n\nThe main advantage is that we can optimize UMA for distributed parallel inference directly without modifying LAMMPS. The user would also not need to deal with building LAMMPS from source (see conda install option below) nor \n\nKokkos, which is notoriously difficult to build correctly.\n\nThere is some Python overhead, but for very fast empirical force fields where Python would be a limiting factor, this is negligible at the speeds of current MLIPs (10s - 100s of ms per step). This is the same reason nearly all modern LLM inference uses Python engines. Additionally, to easily scale to multi-node parallelism regimes, we designed the architecture using a client-server interface so LAMMPS would only see the client and the server code running inference can be optimized completely independently later.\n\nSince the fix external integration simply wraps the UMA predictor interface, the way inference is run is identical to using the \n\nMLIPPredictUnit, ASE Calculator or ParallelMLIPPredictUnit for Multi-GPU inference.","type":"content","url":"/lammps","position":1},{"hierarchy":{"lvl1":"LAMMPS Integration","lvl2":"Usage Notes"},"type":"lvl2","url":"/lammps#usage-notes","position":2},{"hierarchy":{"lvl1":"LAMMPS Integration","lvl2":"Usage Notes"},"content":"Warning\n\nPlease note the following differences from regular LAMMPS workflows:\n\nWe currently only support metal \n\nunits, i.e., energy in eV and forces in eV/A\n\nUsers can write LAMMPS scripts in the usual way (see lammps_in_example.file)\n\nUsers should NOT define other types of forces such as “pair_style”, “bond_style” in their scripts. These forces will get added together with UMA forces and most likely produce false results\n\nUMA uses atomic numbers so we try to guess the atomic number from the provided atomic masses in your LAMMPS scripts. Just make sure you provide the right masses for your atom types - this makes it easy so that you don’t need to redefine atomic element mappings with LAMMPS\n\nNote\n\nThis assumption fails if you use isotopes or non-standard atomic masses, but we don’t expect our models to work in those cases anyway.","type":"content","url":"/lammps#usage-notes","position":3},{"hierarchy":{"lvl1":"LAMMPS Integration","lvl2":"Install and Run"},"type":"lvl2","url":"/lammps#install-and-run","position":4},{"hierarchy":{"lvl1":"LAMMPS Integration","lvl2":"Install and Run"},"content":"Users can install LAMMPS however they like, but the simplest is to install via conda (\n\nhttps://​docs​.lammps​.org​/Install​_conda​.html) if you don’t need any bells and whistles.\n\nFor conda install, activate the conda env with LAMMPS and install fairchem into it. For manual LAMMPS installs, you need to provide python paths so LAMMPS can find fairchem.\n\nNote\n\nWe separate the LAMMPS integration code into a standalone package (fairchem-lammps). Please note fairchem-lammps uses the GnuV2 License as is required by any code that uses LAMMPS, instead of the MIT License used by the FAIRChem repository. The “extras” is required for multi-GPU inference.# first install conda and lammps following the instructions above\n# then activate the environment and install fairchem\nconda activate lammps-env\npip install fairchem-core[extras]\npip install fairchem-lammps\n\nAssuming you have a classic LAMMPS .in script, make the following changes:\n\nRemove all other forces from your LAMMPS script (e.g., pair_style, etc.)\n\nMake sure the units are in “metal”\n\nMake sure there is only 1 run command at the bottom of the script\n\nTo run, use the Python entrypoint lmp_fc (shortcut name for the \n\npython lammps_fc.py script):lmp_fc lmp_in=\"lammps_in_example.file\" task_name=\"omol\"","type":"content","url":"/lammps#install-and-run","position":5},{"hierarchy":{"lvl1":"LAMMPS Integration","lvl2":"Multi-GPU Parallelism"},"type":"lvl2","url":"/lammps#multi-gpu-parallelism","position":6},{"hierarchy":{"lvl1":"LAMMPS Integration","lvl2":"Multi-GPU Parallelism"},"content":"Our LAMMPS integration is fully compatible out of the box with our Multi-GPU inference API.\n\nTip\n\nThe only change required is to pass the ParallelMLIPPredictUnit \n\nhere instead of the regular predict unit when initializing the LAMMPS fairchem script. No need to install anything new such as Kokkos or add communication code.\n\nFor example:lmp_fc lmp_in=\"lammps_in_example.file\" task_name=\"omol\" predict_unit='${parallel_predict_unit}'","type":"content","url":"/lammps#multi-gpu-parallelism","position":7},{"hierarchy":{"lvl1":"Common Tasks"},"type":"lvl1","url":"/summary","position":0},{"hierarchy":{"lvl1":"Common Tasks"},"content":"This section provides practical guides for common tasks you will encounter when working with FAIRChem models. Whether you are running inference, training models, or integrating with simulation tools, these guides will help you get started quickly.\n\nASE Calculator\n\nUse FAIRChem models with ASE for single-point calculations, relaxations, and molecular dynamics.\n\nBatch Inference\n\nEfficiently run predictions on many structures using batched inference.\n\nInferenceBatcher\n\nRun many independent ASE simulations with concurrent batched inference for improved GPU utilization.\n\nDataset Creation\n\nCreate custom datasets from ASE databases, CIF files, trajectories, and other formats.\n\nFine-tuning\n\nFine-tune pretrained UMA models on your own datasets for improved accuracy.\n\nTraining\n\nTrain models from scratch using the FAIRChem training framework.\n\nEvaluation\n\nEvaluate pretrained models on standard benchmarks and metrics.\n\nBenchmarks\n\nRun downstream property benchmarks like relaxations, elastic tensors, and phonons.\n\nLAMMPS Integration\n\nUse FAIRChem models with LAMMPS for large-scale molecular dynamics simulations.\n\nWorkflows\n\nIntegrate FAIRChem with QuAcc for complex molecular simulation workflows.","type":"content","url":"/summary","position":1},{"hierarchy":{"lvl1":"Training Models from Scratch"},"type":"lvl1","url":"/training","position":0},{"hierarchy":{"lvl1":"Training Models from Scratch"},"content":"This repo is used to train large state-of-the-art graph neural networks from scratch on datasets like OC20, OMol25, or OMat24, among others.\n\nTip\n\nWe now provide a simple CLI to handle this using your own custom datasets, but we suggest fine-tuning one of the existing checkpoints first before trying a from-scratch training.","type":"content","url":"/training","position":1},{"hierarchy":{"lvl1":"Training Models from Scratch","lvl2":"FAIRChem Training Framework Overview"},"type":"lvl2","url":"/training#fairchem-training-framework-overview","position":2},{"hierarchy":{"lvl1":"Training Models from Scratch","lvl2":"FAIRChem Training Framework Overview"},"content":"The FAIRChem training framework currently uses a simple SPMD (Single Program Multiple Data) paradigm. It is made of several components:\n\nUser CLI and Launcher - The fairchem CLI can run jobs locally using \n\ntorch distributed elastic or on \n\nSLURM. More environments may be supported in the future.\n\nConfiguration - We strictly use \n\nHydra YAMLs for configuration.\n\nRunner Interface - The core program code that is replicated to run on all ranks. An optional Reducer is also available for evaluation jobs. Runners are distinct user functions that run on a single rank (i.e., GPU). They describe separate high-level tasks such as Train, Eval, Predict, Relaxations, MD, etc. Anyone can write a new runner if its functionality is sufficiently different than the ones that already exist.\n\nTrainer - We use \n\nTorchTNT as a light-weight training loop. This allows us to cleanly separate the data loading from the training loop.\n\nNote\n\nTNT is PyTorch’s replacement for PyTorch Lightning - which has become severely bloated and difficult to use over the years; so we opted for the simpler option. Units are concepts in TorchTNT that provide a basic interface for training, evaluation, and prediction. These replace trainers in fairchemv1. You should write a new unit when the model paradigm is significantly different, e.g., training a Multitask-MLIP is one unit, training a diffusion model should be another unit.","type":"content","url":"/training#fairchem-training-framework-overview","position":3},{"hierarchy":{"lvl1":"Training Models from Scratch","lvl2":"FAIRChem v2 CLI"},"type":"lvl2","url":"/training#fairchem-v2-cli","position":4},{"hierarchy":{"lvl1":"Training Models from Scratch","lvl2":"FAIRChem v2 CLI"},"content":"FAIRChem uses a single \n\nCLI for running jobs. It accepts a single argument, the location of the Hydra YAML.\n\nWarning\n\nThis is intentional to make sure all configuration is fully captured and avoid bloating of the command line interface. Because of the flexibility of Hydra YAMLs, you can still provide additional parameters and overrides using the \n\nHydra override syntax.\n\nThe CLI can launch jobs locally using \n\ntorch distributed elastic OR on \n\nSLURM.","type":"content","url":"/training#fairchem-v2-cli","position":5},{"hierarchy":{"lvl1":"Training Models from Scratch","lvl3":"FAIRChem v2 Config Structure","lvl2":"FAIRChem v2 CLI"},"type":"lvl3","url":"/training#fairchem-v2-config-structure","position":6},{"hierarchy":{"lvl1":"Training Models from Scratch","lvl3":"FAIRChem v2 Config Structure","lvl2":"FAIRChem v2 CLI"},"content":"A FAIRChem config is composed of only 2 valid top-level keys: job (Job Config) and runner (Runner Config). Additionally, you can add key/values that are used by the OmegaConf interpolation syntax to replace fields. Other than these, no other top-level keys are permitted.\n\nJobConfig represents configuration parameters that describe the overall job (mostly infra parameters) such as number of nodes, log locations, loggers, etc. This is a structured config and must strictly adhere to the JobConfig class.\n\nRunner Config describes the user code. This part of config is recursively instantiated at the start of a job using Hydra instantiation framework.","type":"content","url":"/training#fairchem-v2-config-structure","position":7},{"hierarchy":{"lvl1":"Training Models from Scratch","lvl3":"Example Configurations","lvl2":"FAIRChem v2 CLI"},"type":"lvl3","url":"/training#example-configurations","position":8},{"hierarchy":{"lvl1":"Training Models from Scratch","lvl3":"Example Configurations","lvl2":"FAIRChem v2 CLI"},"content":"Local run:job:\n  device_type: CUDA\n  scheduler:\n    mode: LOCAL\n    ranks_per_node: 4\n  run_name: local_training_run\n\nSLURM run:job:\n  device_type: CUDA\n  scheduler:\n    mode: SLURM\n    ranks_per_node: 8\n    num_nodes: 4\n    slurm:\n      account: ${cluster.account}\n      qos: ${cluster.qos}\n      mem_gb: ${cluster.mem_gb}\n      cpus_per_task: ${cluster.cpus_per_task}\n  run_dir: /path/to/output\n  run_name: slurm_run_example","type":"content","url":"/training#example-configurations","position":9},{"hierarchy":{"lvl1":"Training Models from Scratch","lvl3":"Config Object Instantiation","lvl2":"FAIRChem v2 CLI"},"type":"lvl3","url":"/training#config-object-instantiation","position":10},{"hierarchy":{"lvl1":"Training Models from Scratch","lvl3":"Config Object Instantiation","lvl2":"FAIRChem v2 CLI"},"content":"To keep our configs explicit (configs should be thought of as an extension of code), we prefer to use the Hydra instantiation framework throughout; the config is always fully described by a corresponding Python class and should never be a standalone dictionary.\n\nGood vs Bad Config Patterns\n\nBad pattern - We have no idea where to find the code that uses runner or where variables x and y are actually used:runner:\n  x: 5\n  y: 6\n\nGood pattern - Now we know which class runner corresponds to and that x, y are just initializer variables of runner. If we need to check the definition or understand the code, we can simply go to runner.py:runner:\n  _target_: fairchem.core.components.runner.Runner\n  x: 5\n  y: 6","type":"content","url":"/training#config-object-instantiation","position":11},{"hierarchy":{"lvl1":"Training Models from Scratch","lvl3":"Runtime Instantiation with Partial Functions","lvl2":"FAIRChem v2 CLI"},"type":"lvl3","url":"/training#runtime-instantiation-with-partial-functions","position":12},{"hierarchy":{"lvl1":"Training Models from Scratch","lvl3":"Runtime Instantiation with Partial Functions","lvl2":"FAIRChem v2 CLI"},"content":"While we want to use static instantiation as much as possible, there will be many cases where certain objects require runtime inputs to create. For example, if we want to create a PyTorch optimizer, we can give it all the arguments except the model parameters (because it’s only known at runtime).optimizer:\n  _target_: torch.optim.AdamW\n  params: ?? # this is only known at runtime\n  lr: 8e-4\n  weight_decay: 1e-3\n\nTip\n\nIn this case we can use a partial function. Instead of creating an optimizer object, we create a Python partial function that can then be used to instantiate the optimizer in code later:optimizer_fn:\n  _target_: torch.optim.AdamW\n  _partial_: true\n  lr: 8e-4\n  weight_decay: 1e-3# later in the runner\noptimizer = optimizer_fn(model.parameters())","type":"content","url":"/training#runtime-instantiation-with-partial-functions","position":13},{"hierarchy":{"lvl1":"Training Models from Scratch","lvl2":"Training UMA"},"type":"lvl2","url":"/training#training-uma","position":14},{"hierarchy":{"lvl1":"Training Models from Scratch","lvl2":"Training UMA"},"content":"The UMA model is completely defined \n\nhere. It is also called “escn_md” during internal development since it was based on the eSEN architecture.\n\nTraining, evaluation, and inference are all defined in the \n\nmlip unit.\n\nTo train a model, we need to initialize a \n\nTrainRunner with a \n\nMLIPTrainEvalUnit.\n\nDue to the complexity of UMA and training a multi-architecture, multi-dataset, multi-task model, we leverage \n\nconfig groups syntax in Hydra to organize UMA training into the \n\nfollowing sections:\n\nbackbone - selects the specific backbone architecture (e.g., uma-sm, uma-md, uma-large)\n\ncluster - quickly switch settings between different SLURM clusters or local environment\n\ndataset - select the dataset to train on\n\nelement_refs - select the element references\n\ntasks - select the task set (e.g., for direct or conservative training)\n\nTip\n\nWe can switch between different combinations of configs easily this way!","type":"content","url":"/training#training-uma","position":15},{"hierarchy":{"lvl1":"Training Models from Scratch","lvl3":"Example Commands","lvl2":"Training UMA"},"type":"lvl3","url":"/training#example-commands","position":16},{"hierarchy":{"lvl1":"Training Models from Scratch","lvl3":"Example Commands","lvl2":"Training UMA"},"content":"Get training started locally using local settings and the debug dataset:fairchem -c configs/uma/training_release/uma_sm_direct_pretrain.yaml cluster=h100_local dataset=uma_debug\n\nTrain UMA conservative with 16 nodes on SLURM:fairchem -c configs/uma/training_release/uma_sm_conserve_finetune.yaml cluster=h100 job.scheduler.num_nodes=16 run_name=\"uma_conserve_train\"","type":"content","url":"/training#example-commands","position":17},{"hierarchy":{"lvl1":"Calculation Workflows with FAIRChem Models"},"type":"lvl1","url":"/workflows","position":0},{"hierarchy":{"lvl1":"Calculation Workflows with FAIRChem Models"},"content":"This repo is integrated with workflow tools like \n\nQuAcc to make complex molecular simulation workflows easy. You can use any MLP recipe (relaxations, single-points, elastic calculations, etc.) and simply specify the fairchem model type.\n\nTip\n\nOne of the nice things about QuAcc is that you can use plugins for whatever your favorite workflow engine is (Fireworks, Parsl, Prefect, etc.). Some of these methods can scale to hundreds of thousands of parallel calculations and are used by the FAIR chemistry team regularly!\n\nBelow is an example that uses the default elastic_tensor_flow flow:\n\nfrom __future__ import annotations\n\nfrom ase.build import bulk\nfrom quacc.recipes.mlp.elastic import elastic_tensor_flow\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Run an elastic property calculation with our favorite MLP potential\nresult = elastic_tensor_flow(\n    atoms,\n    job_params={\n        \"all\": dict(\n            method=\"fairchem\",\n            name_or_path=\"uma-s-1p1\",\n            task_name=\"omat\",\n        ),\n    },\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/workflows","position":1},{"hierarchy":{"lvl1":"FAIR Chemistry Papers"},"type":"lvl1","url":"/fair-chemistry-papers","position":0},{"hierarchy":{"lvl1":"FAIR Chemistry Papers"},"content":"Research publications from the FAIR Chemistry team at Meta, advancing machine learning for atomic simulations across molecules, materials, and catalysts.\n\nTip\n\nClick on any paper card to expand and see the full abstract and author list.","type":"content","url":"/fair-chemistry-papers","position":1},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl2":"Universal Models & Architectures"},"type":"lvl2","url":"/fair-chemistry-papers#universal-models-architectures","position":2},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl2":"Universal Models & Architectures"},"content":"State-of-the-art neural network architectures for atomic property prediction.\n\nUMA: A Family of Universal Models for Atoms\n\n2025 — Trained on 500M+ structures with 1.4B parameters but only ~50M active per structure using mixture of linear experts\n\neSEN: Learning Smooth and Expressive Interatomic Potentials\n\n2025 — Passes energy conservation tests; SOTA on thermal conductivity, phonons, and materials stability prediction\n\nEquiformerV2: Improved Equivariant Transformer\n\n2023 — Up to 9% improvement on forces, 4% on energies; 2x reduction in DFT calculations for adsorption energies\n\neSCN: Reducing SO(3) Convolutions to SO(2)\n\n2023 — Reduces equivariant convolution complexity from O(L⁶) to O(L³); SOTA on OC-20 and OC-22\n\nMore Architecture Papers","type":"content","url":"/fair-chemistry-papers#universal-models-architectures","position":3},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"GemNet-OC: Graph Neural Networks for Large Datasets","lvl2":"Universal Models & Architectures"},"type":"lvl3","url":"/fair-chemistry-papers#gemnet-oc-graph-neural-networks-for-large-datasets","position":4},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"GemNet-OC: Graph Neural Networks for Large Datasets","lvl2":"Universal Models & Architectures"},"content":"arXiv: \n\n2204.02782 (2022)\n\nAuthors: Johannes Gasteiger, Muhammed Shuaibi, Anuroop Sriram, Stephan Günnemann, Zachary Ulissi, C. Lawrence Zitnick, Abhishek Das\n\nAbstract: Recent years have seen the advent of molecular simulation datasets that are orders of magnitude larger and more diverse. These new datasets differ substantially in four aspects of complexity: 1. Chemical diversity, 2. system size, 3. dataset size, and 4. domain shift. We develop GemNet-OC which outperforms the previous state-of-the-art on OC20 by 16% while reducing training time by a factor of 10.","type":"content","url":"/fair-chemistry-papers#gemnet-oc-graph-neural-networks-for-large-datasets","position":5},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Spherical Channels for Modeling Atomic Interactions","lvl2":"Universal Models & Architectures"},"type":"lvl3","url":"/fair-chemistry-papers#spherical-channels-for-modeling-atomic-interactions","position":6},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Spherical Channels for Modeling Atomic Interactions","lvl2":"Universal Models & Architectures"},"content":"arXiv: \n\n2206.14331 (2022)\n\nAuthors: C. Lawrence Zitnick, Abhishek Das, Adeesh Kolluru, Janice Lan, Muhammed Shuaibi, Anuroop Sriram, Zachary Ulissi, Brandon Wood\n\nAbstract: We propose the Spherical Channel Network (SCN) to model atomic energies and forces. The SCN is a graph neural network where atom embeddings are spherical functions represented using spherical harmonics. We demonstrate state-of-the-art results on the large-scale Open Catalyst dataset.","type":"content","url":"/fair-chemistry-papers#spherical-channels-for-modeling-atomic-interactions","position":7},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"ForceNet: A Graph Neural Network for Large-Scale Quantum Calculations","lvl2":"Universal Models & Architectures"},"type":"lvl3","url":"/fair-chemistry-papers#forcenet-a-graph-neural-network-for-large-scale-quantum-calculations","position":8},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"ForceNet: A Graph Neural Network for Large-Scale Quantum Calculations","lvl2":"Universal Models & Architectures"},"content":"arXiv: \n\n2103.01436 (2021)\n\nAuthors: Weihua Hu, Muhammed Shuaibi, Abhishek Das, Siddharth Goyal, Anuroop Sriram, Jure Leskovec, Devi Parikh, C. Lawrence Zitnick\n\nAbstract: By not imposing explicit physical constraints, we can flexibly design expressive models while maintaining computational efficiency. Physical constraints are implicitly imposed through physics-based data augmentation. ForceNet predicts atomic forces more accurately than state-of-the-art physics-based GNNs while being faster.","type":"content","url":"/fair-chemistry-papers#forcenet-a-graph-neural-network-for-large-scale-quantum-calculations","position":9},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Rotation Invariant Graph Neural Networks using Spin Convolutions","lvl2":"Universal Models & Architectures"},"type":"lvl3","url":"/fair-chemistry-papers#rotation-invariant-graph-neural-networks-using-spin-convolutions","position":10},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Rotation Invariant Graph Neural Networks using Spin Convolutions","lvl2":"Universal Models & Architectures"},"content":"arXiv: \n\n2106.09575 (2021)\n\nAuthors: Muhammed Shuaibi, Adeesh Kolluru, Abhishek Das, Aditya Grover, Anuroop Sriram, Zachary Ulissi, C. Lawrence Zitnick\n\nAbstract: We introduce a novel approach to modeling angular information between atoms using per-edge local coordinate frames and spin convolutions. State-of-the-art results are demonstrated on the large-scale Open Catalyst 2020 dataset.","type":"content","url":"/fair-chemistry-papers#rotation-invariant-graph-neural-networks-using-spin-convolutions","position":11},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Towards Training Billion Parameter Graph Neural Networks","lvl2":"Universal Models & Architectures"},"type":"lvl3","url":"/fair-chemistry-papers#towards-training-billion-parameter-graph-neural-networks","position":12},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Towards Training Billion Parameter Graph Neural Networks","lvl2":"Universal Models & Architectures"},"content":"arXiv: \n\n2203.09697 (2022)\n\nAuthors: Anuroop Sriram, Abhishek Das, Brandon M. Wood, Siddharth Goyal, C. Lawrence Zitnick\n\nAbstract: We introduce Graph Parallelism, a method to distribute input graphs across multiple GPUs, enabling training of very large GNNs with billions of parameters. On OC20, graph-parallelized models achieve 15% relative improvement on force MAE.","type":"content","url":"/fair-chemistry-papers#towards-training-billion-parameter-graph-neural-networks","position":13},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl2":"Datasets"},"type":"lvl2","url":"/fair-chemistry-papers#datasets","position":14},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl2":"Datasets"},"content":"Large-scale open datasets powering the next generation of ML models for chemistry.\n\nOMol25: Open Molecules 2025\n\n2025 — 100M+ DFT calculations, 83 elements, molecules up to 350 atoms\n\nOMat24: Open Materials 2024\n\n2024 — 110M+ DFT calculations for inorganic materials\n\nOMC25: Open Molecular Crystals 2025\n\n2025 — 27M+ molecular crystal structures with DFT labels\n\nODAC25: Open DAC 2025\n\n2025 — 60M DFT calculations for MOF sorbent discovery\n\nAll Dataset Papers","type":"content","url":"/fair-chemistry-papers#datasets","position":15},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"The Open Polymers 2026 (OPoly26) Dataset","lvl2":"Datasets"},"type":"lvl3","url":"/fair-chemistry-papers#the-open-polymers-2026-opoly26-dataset","position":16},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"The Open Polymers 2026 (OPoly26) Dataset","lvl2":"Datasets"},"content":"arXiv: \n\n2512.23117 (2025)\n\nAuthors: Daniel S. Levine, Nicholas Liesen, Lauren Chua, James Diffenderfer, et al.\n\nAbstract: We create the Open Polymers 2026 (OPoly26) dataset containing more than 6.57 million DFT calculations on polymer clusters comprising over 1.2 billion total atoms. OPoly26 captures chemical diversity including variations in monomer composition, degree of polymerization, chain architectures, and solvation environments.","type":"content","url":"/fair-chemistry-papers#the-open-polymers-2026-opoly26-dataset","position":17},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"The Open Catalyst 2025 (OC25) Dataset for Solid-Liquid Interfaces","lvl2":"Datasets"},"type":"lvl3","url":"/fair-chemistry-papers#the-open-catalyst-2025-oc25-dataset-for-solid-liquid-interfaces","position":18},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"The Open Catalyst 2025 (OC25) Dataset for Solid-Liquid Interfaces","lvl2":"Datasets"},"content":"arXiv: \n\n2509.17862 (2025)\n\nAuthors: Sushree Jagriti Sahoo, Mikael Maraschin, Daniel S. Levine, Zachary Ulissi, et al.\n\nAbstract: We introduce OC25, consisting of 7,801,261 calculations across 1,511,270 unique explicit solvent environments. OC25 is the largest solid-liquid interface dataset available, spanning 88 elements with commonly used solvents/ions.","type":"content","url":"/fair-chemistry-papers#the-open-catalyst-2025-oc25-dataset-for-solid-liquid-interfaces","position":19},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"The Open Molecules 2025 (OMol25) Dataset","lvl2":"Datasets"},"type":"lvl3","url":"/fair-chemistry-papers#the-open-molecules-2025-omol25-dataset","position":20},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"The Open Molecules 2025 (OMol25) Dataset","lvl2":"Datasets"},"content":"arXiv: \n\n2505.08762 (2025)\n\nAuthors: Daniel S. Levine, Muhammed Shuaibi, Evan Walter Clark Spotte-Smith, et al.\n\nAbstract: OMol25 is composed of more than 100 million DFT calculations at the ωB97M-V/def2-TZVPD level. It uniquely blends 83 elements, diverse intra- and intermolecular interactions, explicit solvation, variable charge/spin, conformers, and reactive structures across ~83M unique molecular systems.","type":"content","url":"/fair-chemistry-papers#the-open-molecules-2025-omol25-dataset","position":21},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Open Molecular Crystals 2025 (OMC25) Dataset","lvl2":"Datasets"},"type":"lvl3","url":"/fair-chemistry-papers#open-molecular-crystals-2025-omc25-dataset","position":22},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Open Molecular Crystals 2025 (OMC25) Dataset","lvl2":"Datasets"},"content":"arXiv: \n\n2508.02651 (2025)\n\nAuthors: Vahe Gharakhanyan, Luis Barroso-Luque, Yi Yang, Muhammed Shuaibi, et al.\n\nAbstract: OMC25 contains over 27 million molecular crystal structures with 12 elements and up to 300 atoms per unit cell, generated from dispersion-inclusive DFT relaxation trajectories of over 230,000 structures.","type":"content","url":"/fair-chemistry-papers#open-molecular-crystals-2025-omc25-dataset","position":23},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"The Open DAC 2025 (ODAC25) Dataset","lvl2":"Datasets"},"type":"lvl3","url":"/fair-chemistry-papers#the-open-dac-2025-odac25-dataset","position":24},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"The Open DAC 2025 (ODAC25) Dataset","lvl2":"Datasets"},"content":"arXiv: \n\n2508.03162 (2025)\n\nAuthors: Anuroop Sriram, Logan M. Brabson, Xiaohan Yu, Sihoon Choi, et al.\n\nAbstract: ODAC25 comprises nearly 60 million DFT calculations for CO₂, H₂O, N₂, and O₂ adsorption in 15,000 MOFs. It introduces chemical diversity through functionalized MOFs, GCMC-derived placements, and synthetically generated frameworks.","type":"content","url":"/fair-chemistry-papers#the-open-dac-2025-odac25-dataset","position":25},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Open Materials 2024 (OMat24) Dataset","lvl2":"Datasets"},"type":"lvl3","url":"/fair-chemistry-papers#open-materials-2024-omat24-dataset","position":26},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Open Materials 2024 (OMat24) Dataset","lvl2":"Datasets"},"content":"arXiv: \n\n2410.12771 (2024)\n\nAuthors: Luis Barroso-Luque, Muhammed Shuaibi, Xiang Fu, Brandon M. Wood, et al.\n\nAbstract: OMat24 contains over 110 million DFT calculations focused on structural and compositional diversity. EquiformerV2 models achieve state-of-the-art on Matbench Discovery with F1 score above 0.9.","type":"content","url":"/fair-chemistry-papers#open-materials-2024-omat24-dataset","position":27},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Open Catalyst Experiments 2024 (OCx24)","lvl2":"Datasets"},"type":"lvl3","url":"/fair-chemistry-papers#open-catalyst-experiments-2024-ocx24","position":28},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Open Catalyst Experiments 2024 (OCx24)","lvl2":"Datasets"},"content":"arXiv: \n\n2411.11783 (2024)\n\nAuthors: Jehad Abed, Jiheon Kim, Muhammed Shuaibi, Brook Wander, et al.\n\nAbstract: OCX24 bridges experiments and computational models with 572 synthesized samples and 441 gas diffusion electrodes evaluated for CO₂RR and HER. DFT-verified adsorption energies were calculated on ~20,000 materials requiring 685 million AI-accelerated relaxations.","type":"content","url":"/fair-chemistry-papers#open-catalyst-experiments-2024-ocx24","position":29},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"The Open Catalyst 2022 (OC22) Dataset","lvl2":"Datasets"},"type":"lvl3","url":"/fair-chemistry-papers#the-open-catalyst-2022-oc22-dataset","position":30},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"The Open Catalyst 2022 (OC22) Dataset","lvl2":"Datasets"},"content":"arXiv: \n\n2206.08917 (2022)\n\nAuthors: Richard Tran, Janice Lan, Muhammed Shuaibi, Brandon M. Wood, et al.\n\nAbstract: OC22 consists of 62,331 DFT relaxations (~9,854,504 single point calculations) across oxide materials, coverages, and adsorbates, critical for OER catalyst development.","type":"content","url":"/fair-chemistry-papers#the-open-catalyst-2022-oc22-dataset","position":31},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"The Open DAC 2023 (ODAC23) Dataset","lvl2":"Datasets"},"type":"lvl3","url":"/fair-chemistry-papers#the-open-dac-2023-odac23-dataset","position":32},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"The Open DAC 2023 (ODAC23) Dataset","lvl2":"Datasets"},"content":"arXiv: \n\n2311.00341 (2023)\n\nAuthors: Anuroop Sriram, Sihoon Choi, Xiaohan Yu, Logan M. Brabson, et al.\n\nAbstract: ODAC23 consists of more than 38M DFT calculations on more than 8,400 MOF materials containing adsorbed CO₂ and/or H₂O for direct air capture applications.","type":"content","url":"/fair-chemistry-papers#the-open-dac-2023-odac23-dataset","position":33},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"The Open Catalyst 2020 (OC20) Dataset","lvl2":"Datasets"},"type":"lvl3","url":"/fair-chemistry-papers#the-open-catalyst-2020-oc20-dataset","position":34},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"The Open Catalyst 2020 (OC20) Dataset","lvl2":"Datasets"},"content":"arXiv: \n\n2010.09990 (2020)\n\nAuthors: Lowik Chanussot, Abhishek Das, Siddharth Goyal, Thibaut Lavril, et al.\n\nAbstract: OC20 consists of 1,281,040 DFT relaxations (~264,890,000 single point evaluations) across materials, surfaces, and adsorbates. The foundational dataset for the Open Catalyst Project.","type":"content","url":"/fair-chemistry-papers#the-open-catalyst-2020-oc20-dataset","position":35},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl2":"Generative Models"},"type":"lvl2","url":"/fair-chemistry-papers#generative-models","position":36},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl2":"Generative Models"},"content":"Generating novel molecules, materials, and crystal structures.\n\nADiT: All-atom Diffusion Transformers\n\n2025 — Unified generative model for molecules and materials\n\nFlowMM: Riemannian Flow Matching for Materials\n\n2024 — 3x more efficient at finding stable materials\n\nFlowLLM: LLMs + Flow Matching for Crystals\n\n2024 — 3x higher generation rate of stable materials\n\nSpace Group Conditional Flow Matching\n\n2025 — Symmetry-aware crystal generation\n\nMore Generative Model Papers","type":"content","url":"/fair-chemistry-papers#generative-models","position":37},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"All-atom Diffusion Transformers (ADiT)","lvl2":"Generative Models"},"type":"lvl3","url":"/fair-chemistry-papers#all-atom-diffusion-transformers-adit","position":38},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"All-atom Diffusion Transformers (ADiT)","lvl2":"Generative Models"},"content":"arXiv: \n\n2503.03965 (2025)\n\nAuthors: Chaitanya K. Joshi, Xiang Fu, Yi-Lun Liao, Vahe Gharakhanyan, Benjamin Kurt Miller, Anuroop Sriram, Zachary W. Ulissi\n\nAbstract: We introduce ADiT, a unified latent diffusion framework for jointly generating both periodic materials and non-periodic molecular systems. An autoencoder maps molecules and materials to a shared latent space, then diffusion generates new embeddings. ADiT achieves state-of-the-art results on MP20, QM9, and GEOM-DRUGS with significant speedups over equivariant diffusion models.","type":"content","url":"/fair-chemistry-papers#all-atom-diffusion-transformers-adit","position":39},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Space Group Conditional Flow Matching","lvl2":"Generative Models"},"type":"lvl3","url":"/fair-chemistry-papers#space-group-conditional-flow-matching","position":40},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Space Group Conditional Flow Matching","lvl2":"Generative Models"},"content":"arXiv: \n\n2509.23822 (2025)\n\nAuthors: Omri Puny, Yaron Lipman, Benjamin Kurt Miller\n\nAbstract: We introduce a generative framework that samples highly-symmetric, stable crystals by conditioning on space groups and Wyckoff positions. Using efficient group averaging, we achieve state-of-the-art on crystal structure prediction and de novo generation benchmarks.","type":"content","url":"/fair-chemistry-papers#space-group-conditional-flow-matching","position":41},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"FlowLLM: LLMs and Riemannian Flow Matching for Materials","lvl2":"Generative Models"},"type":"lvl3","url":"/fair-chemistry-papers#flowllm-llms-and-riemannian-flow-matching-for-materials","position":42},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"FlowLLM: LLMs and Riemannian Flow Matching for Materials","lvl2":"Generative Models"},"content":"arXiv: \n\n2410.23405 (2024)\n\nAuthors: Anuroop Sriram, Benjamin Kurt Miller, Ricky T. Q. Chen, Brandon M. Wood\n\nAbstract: FlowLLM combines fine-tuned LLMs with Riemannian flow matching. It outperforms state-of-the-art by 3x on stable material generation rate and ~50% on stable, unique, and novel crystals.","type":"content","url":"/fair-chemistry-papers#flowllm-llms-and-riemannian-flow-matching-for-materials","position":43},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"FlowMM: Riemannian Flow Matching for Materials","lvl2":"Generative Models"},"type":"lvl3","url":"/fair-chemistry-papers#flowmm-riemannian-flow-matching-for-materials","position":44},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"FlowMM: Riemannian Flow Matching for Materials","lvl2":"Generative Models"},"content":"arXiv: \n\n2406.04713 (2024)\n\nAuthors: Benjamin Kurt Miller, Ricky T. Q. Chen, Anuroop Sriram, Brandon M Wood\n\nAbstract: We generalize Riemannian Flow Matching to crystals with translation, rotation, permutation, and periodic boundary conditions. FlowMM is ~3x more efficient at finding stable materials compared to previous methods.","type":"content","url":"/fair-chemistry-papers#flowmm-riemannian-flow-matching-for-materials","position":45},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Fine-Tuned Language Models Generate Stable Inorganic Materials","lvl2":"Generative Models"},"type":"lvl3","url":"/fair-chemistry-papers#fine-tuned-language-models-generate-stable-inorganic-materials","position":46},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Fine-Tuned Language Models Generate Stable Inorganic Materials","lvl2":"Generative Models"},"content":"arXiv: \n\n2402.04379 (2024)\n\nAuthors: Nate Gruver, Anuroop Sriram, Andrea Madotto, Andrew Gordon Wilson, C. Lawrence Zitnick, Zachary Ulissi\n\nAbstract: Fine-tuned LLaMA-2 70B generates materials predicted to be metastable at about twice the rate (49% vs 28%) of CDVAE. Around 90% of sampled structures obey physical constraints, demonstrating LLMs’ surprising suitability for atomistic data.","type":"content","url":"/fair-chemistry-papers#fine-tuned-language-models-generate-stable-inorganic-materials","position":47},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"FastCSP: Accelerated Molecular Crystal Structure Prediction","lvl2":"Generative Models"},"type":"lvl3","url":"/fair-chemistry-papers#fastcsp-accelerated-molecular-crystal-structure-prediction","position":48},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"FastCSP: Accelerated Molecular Crystal Structure Prediction","lvl2":"Generative Models"},"content":"arXiv: \n\n2508.02641 (2025)\n\nAuthors: Vahe Gharakhanyan, Yi Yang, Luis Barroso-Luque, Muhammed Shuaibi, et al.\n\nAbstract: FastCSP combines random structure generation with UMA-powered relaxation and free energy calculations. Results for a single system can be obtained within hours on tens of GPUs, making high-throughput crystal structure prediction feasible.","type":"content","url":"/fair-chemistry-papers#fastcsp-accelerated-molecular-crystal-structure-prediction","position":49},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl2":"Sampling & Molecular Dynamics"},"type":"lvl2","url":"/fair-chemistry-papers#sampling-molecular-dynamics","position":50},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl2":"Sampling & Molecular Dynamics"},"content":"Advanced methods for sampling molecular configurations and running simulations.\n\nAdjoint Sampling: Highly Scalable Diffusion Samplers\n\n2025 — First on-policy approach that scales to large problems\n\nAdjoint Schrödinger Bridge Sampler\n\n2025 — Kinetic-optimal transportation for molecular sampling\n\nEnhancing Diffusion Sampling with Collective Variables\n\n2025 — First reactive sampling with diffusion-based samplers\n\nSampling Paper Details","type":"content","url":"/fair-chemistry-papers#sampling-molecular-dynamics","position":51},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Adjoint Sampling","lvl2":"Sampling & Molecular Dynamics"},"type":"lvl3","url":"/fair-chemistry-papers#adjoint-sampling","position":52},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Adjoint Sampling","lvl2":"Sampling & Molecular Dynamics"},"content":"arXiv: \n\n2504.11713 (2025)\n\nAuthors: Aaron Havens, Benjamin Kurt Miller, Bing Yan, Carles Domingo-Enrich, Anuroop Sriram, Brandon Wood, Daniel Levine, et al.\n\nAbstract: We introduce Adjoint Sampling, a highly scalable algorithm for learning diffusion processes that sample from unnormalized densities. It’s the first on-policy approach allowing significantly more gradient updates than energy evaluations. We demonstrate amortized conformer generation across many molecular systems.","type":"content","url":"/fair-chemistry-papers#adjoint-sampling","position":53},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Adjoint Schrödinger Bridge Sampler (ASBS)","lvl2":"Sampling & Molecular Dynamics"},"type":"lvl3","url":"/fair-chemistry-papers#adjoint-schr-dinger-bridge-sampler-asbs","position":54},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Adjoint Schrödinger Bridge Sampler (ASBS)","lvl2":"Sampling & Molecular Dynamics"},"content":"arXiv: \n\n2506.22565 (2025)\n\nAuthors: Guan-Horng Liu, Jaemoo Choi, Yongxin Chen, Benjamin Kurt Miller, Ricky T. Q. Chen\n\nAbstract: ASBS employs simple matching-based objectives without needing target samples during training. Grounded in the Schrödinger Bridge for kinetic-optimal transportation, ASBS generalizes to arbitrary source distributions for sampling from molecular Boltzmann distributions.","type":"content","url":"/fair-chemistry-papers#adjoint-schr-dinger-bridge-sampler-asbs","position":55},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Enhancing Diffusion-Based Sampling with Molecular Collective Variables","lvl2":"Sampling & Molecular Dynamics"},"type":"lvl3","url":"/fair-chemistry-papers#enhancing-diffusion-based-sampling-with-molecular-collective-variables","position":56},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Enhancing Diffusion-Based Sampling with Molecular Collective Variables","lvl2":"Sampling & Molecular Dynamics"},"content":"arXiv: \n\n2510.11923 (2025)\n\nAuthors: Juno Nam, Bálint Máté, Artur P. Toshev, Manasa Kaniselvan, Rafael Gómez-Bombarelli, et al.\n\nAbstract: We introduce a sequential bias along collective variables to improve mode discovery and enable free energy estimation. We are the first to demonstrate reactive sampling using a diffusion-based sampler, capturing bond breaking and formation with universal interatomic potentials.","type":"content","url":"/fair-chemistry-papers#enhancing-diffusion-based-sampling-with-molecular-collective-variables","position":57},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl2":"Applications & Discovery"},"type":"lvl2","url":"/fair-chemistry-papers#applications-discovery","position":58},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl2":"Applications & Discovery"},"content":"Practical applications accelerating catalyst and materials discovery.\n\nCatTSunami: Accelerating Transition State Calculations\n\n2024 — 1500x speedup for reaction network enumeration\n\nAdsorbML: Efficient Adsorption Energy Calculations\n\n2022 — 2000x speedup with 87% accuracy\n\nCatlas: Automated Catalyst Discovery Framework\n\n2022 — High-throughput screening for syngas conversion\n\nGA-Accelerated Liquid Crystal Polymer Discovery\n\n2025 — Genetic algorithms + first-principles for VR/AR materials\n\nApplication Paper Details","type":"content","url":"/fair-chemistry-papers#applications-discovery","position":59},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"CatTSunami: Accelerating Transition State Energy Calculations","lvl2":"Applications & Discovery"},"type":"lvl3","url":"/fair-chemistry-papers#cattsunami-accelerating-transition-state-energy-calculations","position":60},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"CatTSunami: Accelerating Transition State Energy Calculations","lvl2":"Applications & Discovery"},"content":"arXiv: \n\n2405.02078 (2024)\n\nAuthors: Brook Wander, Muhammed Shuaibi, John R. Kitchin, Zachary W. Ulissi, C. Lawrence Zitnick\n\nAbstract: We show GNN potentials trained on OC20 find transition states within 0.1 eV of DFT 91% of the time with 28x speedup. We replicated a reaction network with 61 intermediates and 174 reactions at DFT resolution using just 12 GPU days (vs 52 GPU years), a 1500x speedup.","type":"content","url":"/fair-chemistry-papers#cattsunami-accelerating-transition-state-energy-calculations","position":61},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"AdsorbML: A Leap in Efficiency for Adsorption Energy Calculations","lvl2":"Applications & Discovery"},"type":"lvl3","url":"/fair-chemistry-papers#adsorbml-a-leap-in-efficiency-for-adsorption-energy-calculations","position":62},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"AdsorbML: A Leap in Efficiency for Adsorption Energy Calculations","lvl2":"Applications & Discovery"},"content":"arXiv: \n\n2211.16486 (2022)\n\nAuthors: Janice Lan, Aini Palizhati, Muhammed Shuaibi, Brandon M. Wood, et al.\n\nAbstract: We demonstrate ML potentials can identify low energy adsorbate-surface configurations with 87.36% accuracy while achieving a 2000x speedup. We introduce the Open Catalyst Dense dataset with ~1,000 surfaces and 100,000 configurations.","type":"content","url":"/fair-chemistry-papers#adsorbml-a-leap-in-efficiency-for-adsorption-energy-calculations","position":63},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Catlas: Automated Framework for Catalyst Discovery","lvl2":"Applications & Discovery"},"type":"lvl3","url":"/fair-chemistry-papers#catlas-automated-framework-for-catalyst-discovery","position":64},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Catlas: Automated Framework for Catalyst Discovery","lvl2":"Applications & Discovery"},"content":"arXiv: \n\n2208.12717 (2022)\n\nAuthors: Brook Wander, Kirby Broderick, Zachary W. Ulissi\n\nAbstract: Catlas explores large design spaces using pre-trained ML models without upfront training. For syngas-to-oxygenates conversion, we explored 947 binary intermetallics, identifying 144 candidate materials including Pt-Ti, Pd-V, Ni-Nb, and Ti-Zn.","type":"content","url":"/fair-chemistry-papers#catlas-automated-framework-for-catalyst-discovery","position":65},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Genetic Algorithm-Accelerated Discovery of Liquid Crystal Polymers","lvl2":"Applications & Discovery"},"type":"lvl3","url":"/fair-chemistry-papers#genetic-algorithm-accelerated-discovery-of-liquid-crystal-polymers","position":66},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Genetic Algorithm-Accelerated Discovery of Liquid Crystal Polymers","lvl2":"Applications & Discovery"},"content":"arXiv: \n\n2505.13477 (2025)\n\nAuthors: Jianing Zhou, Yuge Huang, Arman Boromand, Keian Noori, et al.\n\nAbstract: We integrate first-principles calculations with genetic algorithms to discover liquid crystal polymers with low visible absorption and high refractive index for VR/AR/MR technologies.","type":"content","url":"/fair-chemistry-papers#genetic-algorithm-accelerated-discovery-of-liquid-crystal-polymers","position":67},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Adapting OC20-trained EquiformerV2 for High-Entropy Materials","lvl2":"Applications & Discovery"},"type":"lvl3","url":"/fair-chemistry-papers#adapting-oc20-trained-equiformerv2-for-high-entropy-materials","position":68},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Adapting OC20-trained EquiformerV2 for High-Entropy Materials","lvl2":"Applications & Discovery"},"content":"arXiv: \n\n2403.09811 (2024)\n\nAuthors: Christian M. Clausen, Jan Rossmeisl, Zachary W. Ulissi\n\nAbstract: We show that through energy filtering and few-shot fine-tuning, EquiformerV2 achieves state-of-the-art accuracy on high-entropy alloys (Ag-Ir-Pd-Pt-Ru), demonstrating that foundational knowledge from ordered structures extrapolates to disordered solid-solutions.","type":"content","url":"/fair-chemistry-papers#adapting-oc20-trained-equiformerv2-for-high-entropy-materials","position":69},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl2":"Training Methods & Techniques"},"type":"lvl2","url":"/fair-chemistry-papers#training-methods-techniques","position":70},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl2":"Training Methods & Techniques"},"content":"Innovations in model training, active learning, and pre-training strategies.\n\nDeNS: Generalizing Denoising to Non-Equilibrium Structures\n\n2024 — New SOTA on OC20 and OC22\n\nJMP: Joint Multi-domain Pre-training\n\n2023 — 59% average improvement over training from scratch\n\nFINETUNA: Fine-tuning Accelerated Simulations\n\n2022 — 91% reduction in DFT calculations\n\nTraining Methods Paper Details","type":"content","url":"/fair-chemistry-papers#training-methods-techniques","position":71},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Generalizing Denoising to Non-Equilibrium Structures (DeNS)","lvl2":"Training Methods & Techniques"},"type":"lvl3","url":"/fair-chemistry-papers#generalizing-denoising-to-non-equilibrium-structures-dens","position":72},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Generalizing Denoising to Non-Equilibrium Structures (DeNS)","lvl2":"Training Methods & Techniques"},"content":"arXiv: \n\n2403.09549 (2024)\n\nAuthors: Yi-Lun Liao, Tess Smidt, Muhammed Shuaibi, Abhishek Das\n\nAbstract: We propose denoising non-equilibrium structures as an auxiliary training task. By encoding forces to specify which structure we’re denoising, DeNS achieves new state-of-the-art on OC20 and OC22 while significantly improving training efficiency on MD17.","type":"content","url":"/fair-chemistry-papers#generalizing-denoising-to-non-equilibrium-structures-dens","position":73},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"From Molecules to Materials: Joint Multi-domain Pre-training (JMP)","lvl2":"Training Methods & Techniques"},"type":"lvl3","url":"/fair-chemistry-papers#from-molecules-to-materials-joint-multi-domain-pre-training-jmp","position":74},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"From Molecules to Materials: Joint Multi-domain Pre-training (JMP)","lvl2":"Training Methods & Techniques"},"content":"arXiv: \n\n2310.16802 (2023)\n\nAuthors: Nima Shoghi, Adeesh Kolluru, John R. Kitchin, Zachary W. Ulissi, C. Lawrence Zitnick, Brandon M. Wood\n\nAbstract: JMP simultaneously trains on multiple datasets (~120M systems from OC20, OC22, ANI-1x, Transition-1x) within a multi-task framework. It demonstrates 59% average improvement over training from scratch, matching or setting SOTA on 34 of 40 tasks.","type":"content","url":"/fair-chemistry-papers#from-molecules-to-materials-joint-multi-domain-pre-training-jmp","position":75},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"FINETUNA: Fine-tuning Accelerated Molecular Simulations","lvl2":"Training Methods & Techniques"},"type":"lvl3","url":"/fair-chemistry-papers#finetuna-fine-tuning-accelerated-molecular-simulations","position":76},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"FINETUNA: Fine-tuning Accelerated Molecular Simulations","lvl2":"Training Methods & Techniques"},"content":"arXiv: \n\n2205.01223 (2022)\n\nAuthors: Joseph Musielewicz, Xiaoxiao Wang, Tian Tian, Zachary Ulissi\n\nAbstract: An online active learning framework that incorporates prior information from pre-trained models. It accelerates simulations by reducing DFT calculations by 91% while meeting accuracy thresholds 93% of the time.","type":"content","url":"/fair-chemistry-papers#finetuna-fine-tuning-accelerated-molecular-simulations","position":77},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Robust and Scalable Uncertainty Estimation with Conformal Prediction","lvl2":"Training Methods & Techniques"},"type":"lvl3","url":"/fair-chemistry-papers#robust-and-scalable-uncertainty-estimation-with-conformal-prediction","position":78},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Robust and Scalable Uncertainty Estimation with Conformal Prediction","lvl2":"Training Methods & Techniques"},"content":"arXiv: \n\n2208.08337 (2022)\n\nAuthors: Yuge Hu, Joseph Musielewicz, Zachary Ulissi, Andrew J. Medford\n\nAbstract: We combine conformal prediction with latent space distances to estimate uncertainty of neural network force fields. The method is calibrated, sharp, and scalable to training datasets of 1 million images.","type":"content","url":"/fair-chemistry-papers#robust-and-scalable-uncertainty-estimation-with-conformal-prediction","position":79},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Generalization of Graph-Based Active Learning Relaxation Strategies","lvl2":"Training Methods & Techniques"},"type":"lvl3","url":"/fair-chemistry-papers#generalization-of-graph-based-active-learning-relaxation-strategies","position":80},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Generalization of Graph-Based Active Learning Relaxation Strategies","lvl2":"Training Methods & Techniques"},"content":"arXiv: \n\n2311.01987 (2023)\n\nAuthors: Xiaoxiao Wang, Joseph Musielewicz, Richard Tran, et al.\n\nAbstract: We investigate Finetuna on out-of-domain systems: larger adsorbates, metal-oxides with spin polarization, and 3D structures like zeolites and MOFs. The framework reduces DFT calculations by 80% for alcohols/3D structures and 42% for oxides.","type":"content","url":"/fair-chemistry-papers#generalization-of-graph-based-active-learning-relaxation-strategies","position":81},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Enabling Robust Offline Active Learning for ML Potentials","lvl2":"Training Methods & Techniques"},"type":"lvl3","url":"/fair-chemistry-papers#enabling-robust-offline-active-learning-for-ml-potentials","position":82},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Enabling Robust Offline Active Learning for ML Potentials","lvl2":"Training Methods & Techniques"},"content":"arXiv: \n\n2008.10773 (2020)\n\nAuthors: Muhammed Shuaibi, Saurabh Sivakumar, Rui Qi Chen, Zachary W. Ulissi\n\nAbstract: We demonstrate a Δ-machine learning approach enabling stable convergence in offline active learning by avoiding unphysical configurations, reducing first-principles calculations by 70-90%.","type":"content","url":"/fair-chemistry-papers#enabling-robust-offline-active-learning-for-ml-potentials","position":83},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl2":"Electronic Structure & Properties"},"type":"lvl2","url":"/fair-chemistry-papers#electronic-structure-properties","position":84},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl2":"Electronic Structure & Properties"},"content":"Predicting electronic structure and chemical properties beyond energies and forces.\n\nHELM: Hamiltonian-trained Electronic-structure Learning\n\n2025 — Hamiltonian prediction for 100+ atom structures\n\nChemical Properties from GNN-Predicted Electron Densities\n\n2023 — Atomic charges and dipole moments from electron density\n\nXRD Loss Landscape Analysis\n\n2025 — Insights for crystal structure from powder diffraction\n\nElectronic Structure Paper Details","type":"content","url":"/fair-chemistry-papers#electronic-structure-properties","position":85},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"HELM: Learning from Electronic Structure Across the Periodic Table","lvl2":"Electronic Structure & Properties"},"type":"lvl3","url":"/fair-chemistry-papers#helm-learning-from-electronic-structure-across-the-periodic-table","position":86},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"HELM: Learning from Electronic Structure Across the Periodic Table","lvl2":"Electronic Structure & Properties"},"content":"arXiv: \n\n2510.00224 (2025)\n\nAuthors: Manasa Kaniselvan, Benjamin Kurt Miller, Meng Gao, Juno Nam, Daniel S. Levine\n\nAbstract: We introduce HELM, a state-of-the-art Hamiltonian prediction model scaling to 100+ atom structures with 58 elements and large basis sets. We release the ‘OMol_CSH_58k’ dataset and demonstrate ‘Hamiltonian pretraining’ improves energy-prediction in low-data regimes.","type":"content","url":"/fair-chemistry-papers#helm-learning-from-electronic-structure-across-the-periodic-table","position":87},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Chemical Properties from Graph Neural Network-Predicted Electron Densities","lvl2":"Electronic Structure & Properties"},"type":"lvl3","url":"/fair-chemistry-papers#chemical-properties-from-graph-neural-network-predicted-electron-densities","position":88},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Chemical Properties from Graph Neural Network-Predicted Electron Densities","lvl2":"Electronic Structure & Properties"},"content":"arXiv: \n\n2309.04811 (2023)\n\nAuthors: Ethan M. Sunshine, Muhammed Shuaibi, Zachary W. Ulissi, John R. Kitchin\n\nAbstract: We demonstrate using established physical methods to obtain chemical properties from model-predicted electron densities. Without training to predict charges, the model predicts atomic charges with an order of magnitude lower error than sum of atomic densities.","type":"content","url":"/fair-chemistry-papers#chemical-properties-from-graph-neural-network-predicted-electron-densities","position":89},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"The Loss Landscape of Powder X-Ray Diffraction-Based Structure Optimization","lvl2":"Electronic Structure & Properties"},"type":"lvl3","url":"/fair-chemistry-papers#the-loss-landscape-of-powder-x-ray-diffraction-based-structure-optimization","position":90},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"The Loss Landscape of Powder X-Ray Diffraction-Based Structure Optimization","lvl2":"Electronic Structure & Properties"},"content":"arXiv: \n\n2512.04036 (2025)\n\nAuthors: Nofit Segal, Akshay Subramanian, Mingda Li, Benjamin Kurt Miller, Rafael Gomez-Bombarelli\n\nAbstract: We study the powder XRD-to-structure mapping using gradient descent. Commonly used XRD similarity metrics result in highly non-convex landscapes. Constraining optimization to the ground-truth crystal family significantly improves structure recovery.","type":"content","url":"/fair-chemistry-papers#the-loss-landscape-of-powder-x-ray-diffraction-based-structure-optimization","position":91},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"A Physically-informed Graph-based Order Parameter","lvl2":"Electronic Structure & Properties"},"type":"lvl3","url":"/fair-chemistry-papers#a-physically-informed-graph-based-order-parameter","position":92},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"A Physically-informed Graph-based Order Parameter","lvl2":"Electronic Structure & Properties"},"content":"arXiv: \n\n2106.08215 (2021)\n\nAuthors: James Chapman, Nir Goldman, Brandon Wood\n\nAbstract: A universal, transferable graph-based order parameter for characterizing atomistic structures. Validated on liquid lithium up to 300 GPa, carbon phases including nanotubes, and diverse aluminum configurations. Outperforms all existing crystalline order parameters.","type":"content","url":"/fair-chemistry-papers#a-physically-informed-graph-based-order-parameter","position":93},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl2":"Perspectives & Introductions"},"type":"lvl2","url":"/fair-chemistry-papers#perspectives-introductions","position":94},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl2":"Perspectives & Introductions"},"content":"Overview papers and perspectives on the field.\n\nPerspectives & Introductions","type":"content","url":"/fair-chemistry-papers#perspectives-introductions","position":95},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Open Challenges in Developing Large Scale ML Models for Catalyst Discovery","lvl2":"Perspectives & Introductions"},"type":"lvl3","url":"/fair-chemistry-papers#open-challenges-in-developing-large-scale-ml-models-for-catalyst-discovery","position":96},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Open Challenges in Developing Large Scale ML Models for Catalyst Discovery","lvl2":"Perspectives & Introductions"},"content":"arXiv: \n\n2206.02005 (2022)\n\nAuthors: Adeesh Kolluru, Muhammed Shuaibi, Aini Palizhati, Nima Shoghi, et al.\n\nAbstract: We discuss challenges and findings of developments on OC20, examining performance across materials and adsorbates. We cover energy-conservation, finding local minima, and augmentation of off-equilibrium data.","type":"content","url":"/fair-chemistry-papers#open-challenges-in-developing-large-scale-ml-models-for-catalyst-discovery","position":97},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"An Introduction to Electrocatalyst Design using Machine Learning","lvl2":"Perspectives & Introductions"},"type":"lvl3","url":"/fair-chemistry-papers#an-introduction-to-electrocatalyst-design-using-machine-learning","position":98},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"An Introduction to Electrocatalyst Design using Machine Learning","lvl2":"Perspectives & Introductions"},"content":"arXiv: \n\n2010.09435 (2020)\n\nAuthors: C. Lawrence Zitnick, Lowik Chanussot, Abhishek Das, Siddharth Goyal, et al.\n\nAbstract: An introduction to challenges in finding electrocatalysts for renewable energy storage, how machine learning may be applied, and the use of the Open Catalyst Project OC20 dataset for model training.","type":"content","url":"/fair-chemistry-papers#an-introduction-to-electrocatalyst-design-using-machine-learning","position":99},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Computational Catalyst Discovery: Active Classification through Myopic Multiscale Sampling","lvl2":"Perspectives & Introductions"},"type":"lvl3","url":"/fair-chemistry-papers#computational-catalyst-discovery-active-classification-through-myopic-multiscale-sampling","position":100},{"hierarchy":{"lvl1":"FAIR Chemistry Papers","lvl3":"Computational Catalyst Discovery: Active Classification through Myopic Multiscale Sampling","lvl2":"Perspectives & Introductions"},"content":"arXiv: \n\n2102.01528 (2021)\n\nAuthors: Kevin Tran, Willie Neiswanger, Kirby Broderick, Eric Xing, Jeff Schneider, Zachary W. Ulissi\n\nAbstract: We present myopic multiscale sampling, which combines multiscale modeling with automated DFT selection. This active classification strategy achieves ~7-16x speedup in catalyst classification relative to random sampling.","type":"content","url":"/fair-chemistry-papers#computational-catalyst-discovery-active-classification-through-myopic-multiscale-sampling","position":101},{"hierarchy":{"lvl1":"fairchem>=2.0"},"type":"lvl1","url":"/fairchemv1-v2","position":0},{"hierarchy":{"lvl1":"fairchem>=2.0"},"content":"Warning\n\nfairchem>=2.0 is a major upgrade with completely rewritten trainer, fine-tuning, models, and calculators. The old OCPCalculator and trainer code will NOT be revived.\n\nWe plan to bring back the following models compatible with Fairchem V2 soon:\n\nGemnet-OC\n\nEquiformerV2\n\neSEN\n\nTip\n\nWe will be releasing more detailed documentation on how to use Fairchem V2. Stay tuned!","type":"content","url":"/fairchemv1-v2","position":1},{"hierarchy":{"lvl1":"fairchem>=2.0","lvl2":"Using Fairchem V1"},"type":"lvl2","url":"/fairchemv1-v2#using-fairchem-v1","position":2},{"hierarchy":{"lvl1":"fairchem>=2.0","lvl2":"Using Fairchem V1"},"content":"If you need to use models from fairchem version 1, you can still do so by installing version 1:pip install fairchem-core==1.10\n\nAnd using the OCPCalculator:from fairchem.core import OCPCalculator\n\ncalc = OCPCalculator(\n    model_name=\"EquiformerV2-31M-S2EF-OC20-All+MD\",\n    local_cache=\"pretrained_models\",\n    cpu=False,\n)","type":"content","url":"/fairchemv1-v2#using-fairchem-v1","position":3},{"hierarchy":{"lvl1":"fairchem>=2.0","lvl2":"Projects and models built on fairchem version v2"},"type":"lvl2","url":"/fairchemv1-v2#projects-and-models-built-on-fairchem-version-v2","position":4},{"hierarchy":{"lvl1":"fairchem>=2.0","lvl2":"Projects and models built on fairchem version v2"},"content":"UMA (Universal Model for Atoms)\n\nThe latest universal model for atomistic simulations.\n\n[arXiv] | \n\n[code]","type":"content","url":"/fairchemv1-v2#projects-and-models-built-on-fairchem-version-v2","position":5},{"hierarchy":{"lvl1":"fairchem>=2.0","lvl2":"Projects and models built on fairchem version v1"},"type":"lvl2","url":"/fairchemv1-v2#projects-and-models-built-on-fairchem-version-v1","position":6},{"hierarchy":{"lvl1":"fairchem>=2.0","lvl2":"Projects and models built on fairchem version v1"},"content":"Note\n\nYou can still find these in the v1 version of fairchem github. However, many of these implementations are no longer actively supported.\n\nGemNet-dT\n\n[arXiv] | \n\n[code]\n\nPaiNN\n\n[arXiv] | \n\n[code]\n\nGraph Parallelism\n\n[arXiv] | \n\n[code]\n\nGemNet-OC\n\n[arXiv] | \n\n[code]\n\nSCN\n\n[arXiv] | \n\n[code]\n\nAdsorbML\n\n[arXiv] | \n\n[code]\n\neSCN\n\n[arXiv] | \n\n[code]\n\nEquiformerV2\n\n[arXiv] | \n\n[code]\n\nSchNet\n\n[arXiv]\n\nDimeNet++\n\n[arXiv]\n\nCGCNN\n\n[arXiv] | \n\n[code]\n\nDimeNet\n\n[arXiv] | \n\n[code]\n\nSpinConv\n\n[arXiv] | \n\n[code]\n\nForceNet\n\n[arXiv] | \n\n[code]","type":"content","url":"/fairchemv1-v2#projects-and-models-built-on-fairchem-version-v1","position":7},{"hierarchy":{"lvl1":"Generative Models"},"type":"lvl1","url":"/generative-models","position":0},{"hierarchy":{"lvl1":"Generative Models"},"content":"The FAIR chemistry team has released and published four generative models for inorganic materials and molecules. Close collaborators have also released generative models for catalysts. These releases currently live outside of the main FAIR chemistry repo (noted where appropriate). Much of this work has been driven by an incredible group of Meta/FAIR summer PhD interns!\n\nTip\n\nGenerative models can create novel materials and molecules by learning patterns from training data, enabling rapid exploration of chemical space.\n\nAll-atom Diffusion Transformers (ADiT)\n\nCore Idea: Generative models for molecules and generative models for materials tended to be two separate tasks in the AI/ML community, and we developed a transformer-based latent diffusion approach that was able to encode both in the same latent space, leading to synergistic learning.\n\nPaper: \n\nhttps://​arxiv​.org​/abs​/2503​.03965\n\nCode: \n\nhttps://​github​.com​/facebookresearch​/all​-atom​-diffusion​-transformer\n\nFlowLLM\n\nCore Idea: We noticed that the Crystal-text-llm did much better at generating compositions than the actual crystal structures, so we took a best-of-both-worlds approach using an LLM to generate compositions we should study, and Flow Matching to generate the actual crystal structures.\n\nPaper: \n\nhttps://​arxiv​.org​/abs​/2410​.23405\n\nCode: \n\nhttps://​github​.com​/facebookresearch​/flowmm/\n\nFlowMM\n\nCore Idea: Flow Matching, an emerging method in the broader AI/ML generative model space, could be used to more quickly and efficiently generate inorganic crystal structures than some prior diffusion-based methods.\n\nPaper: \n\nhttps://​openreview​.net​/forum​?id​=​W4pB7VbzZI\n\nCode: \n\nhttps://​github​.com​/facebookresearch​/flowmm/\n\nCrystal-text-llm\n\nCore Idea: Building on others in the community who had suggested LLMs could generate molecules or materials as text, we showed that fine-tuned LLaMA models could work quite well for this task, and enable text conditioning.\n\nPaper: \n\nhttps://​arxiv​.org​/abs​/2402​.04379\n\nCode: \n\nhttps://​github​.com​/facebookresearch​/crystal​-text​-llm","type":"content","url":"/generative-models","position":1},{"hierarchy":{"lvl1":"Installation & License"},"type":"lvl1","url":"/install","position":0},{"hierarchy":{"lvl1":"Installation & License"},"content":"","type":"content","url":"/install","position":1},{"hierarchy":{"lvl1":"Installation & License","lvl2":"Installation"},"type":"lvl2","url":"/install#installation","position":2},{"hierarchy":{"lvl1":"Installation & License","lvl2":"Installation"},"content":"Warning\n\nFAIRChem V2 is a major breaking change from V1 and is not compatible with previous pretrained models. If you need the old V1 code, install version 1 with pip install fairchem-core==1.10.\n\nTo install fairchem-core you will need to setup the fairchem-core environment. We support either pip or uv. Conda is no longer supported and has also been dropped by pytorch itself. Note you can still create environments with conda and use pip to install the packages.\n\nTip\n\nWe recommend installing fairchem inside a virtual environment instead of directly onto your system.","type":"content","url":"/install#installation","position":3},{"hierarchy":{"lvl1":"Installation & License","lvl3":"Step 1: Create a virtual environment","lvl2":"Installation"},"type":"lvl3","url":"/install#step-1-create-a-virtual-environment","position":4},{"hierarchy":{"lvl1":"Installation & License","lvl3":"Step 1: Create a virtual environment","lvl2":"Installation"},"content":"virtualenv -p python3.12 fairchem\nsource fairchem/bin/activate","type":"content","url":"/install#step-1-create-a-virtual-environment","position":5},{"hierarchy":{"lvl1":"Installation & License","lvl3":"Step 2: Install the package","lvl2":"Installation"},"type":"lvl3","url":"/install#step-2-install-the-package","position":6},{"hierarchy":{"lvl1":"Installation & License","lvl3":"Step 2: Install the package","lvl2":"Installation"},"content":"pip install fairchem-core\n\nFor developers contributing to fairchem\n\nClone the repo and install in editable mode:git clone git@github.com:facebookresearch/fairchem.git\ncd fairchem\npip install -e src/packages/fairchem-core[dev]\n\nNote\n\nIn V2, we removed all dependencies on 3rd party libraries such as torch-geometric, pyg, torch-scatter, torch-sparse etc that made installation difficult. So no additional steps are required!","type":"content","url":"/install#step-2-install-the-package","position":7},{"hierarchy":{"lvl1":"Installation & License","lvl2":"Subpackages"},"type":"lvl2","url":"/install#subpackages","position":8},{"hierarchy":{"lvl1":"Installation & License","lvl2":"Subpackages"},"content":"In addition to fairchem-core, there are related packages for specialized tasks or applications. Each can be installed with pip or uv just like fairchem-core:","type":"content","url":"/install#subpackages","position":9},{"hierarchy":{"lvl1":"Installation & License","lvl3":"Data Packages","lvl2":"Subpackages"},"type":"lvl3","url":"/install#data-packages","position":10},{"hierarchy":{"lvl1":"Installation & License","lvl3":"Data Packages","lvl2":"Subpackages"},"content":"Utilities for generating input configurations and working with specific datasets:\n\nfairchem-data-oc\n\nCode for generating adsorbate-catalyst input configurations\n\nfairchem-data-omat\n\nCode for generating OMat24 input configurations and VASP input sets\n\nfairchem-data-omc\n\nCode for generating OMC (Molecular Crystals) VASP inputs\n\nfairchem-data-omol\n\nCode for generating OMOL input configurations\n\nfairchem-data-odac\n\nCode for ODAC MOF configurations and VASP input sets for direct air capture","type":"content","url":"/install#data-packages","position":11},{"hierarchy":{"lvl1":"Installation & License","lvl3":"Application Packages","lvl2":"Subpackages"},"type":"lvl3","url":"/install#application-packages","position":12},{"hierarchy":{"lvl1":"Installation & License","lvl3":"Application Packages","lvl2":"Subpackages"},"content":"Higher-level applications built on top of FAIRChem models:\n\nfairchem-applications-adsorbml\n\nModule for calculating minimum adsorption energies\n\nfairchem-applications-cattsunami\n\nAccelerating transition state energy calculations with pre-trained GNNs\n\nfairchem-applications-fastcsp\n\nAccelerated molecular crystal structure prediction with UMA\n\nfairchem-applications-ocx\n\nBridging experiments to computational models","type":"content","url":"/install#application-packages","position":13},{"hierarchy":{"lvl1":"Installation & License","lvl3":"Integration & Demo Packages","lvl2":"Subpackages"},"type":"lvl3","url":"/install#integration-demo-packages","position":14},{"hierarchy":{"lvl1":"Installation & License","lvl3":"Integration & Demo Packages","lvl2":"Subpackages"},"content":"Tools for integrating with other software or demo APIs:\n\nfairchem-lammps\n\nUse FAIRChem models with LAMMPS for large-scale MD simulations\n\nfairchem-demo-ocpapi\n\nPython client library for the Open Catalyst Demo API","type":"content","url":"/install#integration-demo-packages","position":15},{"hierarchy":{"lvl1":"Installation & License","lvl2":"Access to gated models on HuggingFace"},"type":"lvl2","url":"/install#access-to-gated-models-on-huggingface","position":16},{"hierarchy":{"lvl1":"Installation & License","lvl2":"Access to gated models on HuggingFace"},"content":"To access gated models like UMA, you need to get a HuggingFace account and request access to the UMA models.\n\nHuggingFace Setup Steps\n\nGet and login to your HuggingFace account\n\nRequest access to \n\nhttps://​huggingface​.co​/facebook​/UMA\n\nCreate a HuggingFace token at \n\nhttps://​huggingface​.co​/settings​/tokens/ with the permission “Read access to contents of all public gated repos you can access”\n\nAdd the token as an environment variable using huggingface-cli login or by setting the HF_TOKEN environment variable","type":"content","url":"/install#access-to-gated-models-on-huggingface","position":17},{"hierarchy":{"lvl1":"Installation & License","lvl2":"License"},"type":"lvl2","url":"/install#license","position":18},{"hierarchy":{"lvl1":"Installation & License","lvl2":"License"},"content":"","type":"content","url":"/install#license","position":19},{"hierarchy":{"lvl1":"Installation & License","lvl3":"Repository software","lvl2":"License"},"type":"lvl3","url":"/install#repository-software","position":20},{"hierarchy":{"lvl1":"Installation & License","lvl3":"Repository software","lvl2":"License"},"content":"The software in this repo is licensed under an MIT license unless otherwise specified.\n\nMIT LicenseMIT License\n\nCopyright (c) Meta, Inc. and its affiliates.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.","type":"content","url":"/install#repository-software","position":21},{"hierarchy":{"lvl1":"Installation & License","lvl3":"Terms of use & privacy policy","lvl2":"License"},"type":"lvl3","url":"/install#terms-of-use-privacy-policy","position":22},{"hierarchy":{"lvl1":"Installation & License","lvl3":"Terms of use & privacy policy","lvl2":"License"},"content":"Please read the following \n\nTerms of Use and\n\n\nPrivacy Policy covering usage of fairchem software and models.","type":"content","url":"/install#terms-of-use-privacy-policy","position":23},{"hierarchy":{"lvl1":"Installation & License","lvl3":"Model checkpoints and datasets","lvl2":"License"},"type":"lvl3","url":"/install#model-checkpoints-and-datasets","position":24},{"hierarchy":{"lvl1":"Installation & License","lvl3":"Model checkpoints and datasets","lvl2":"License"},"content":"Please check each dataset and model for their own licenses.","type":"content","url":"/install#model-checkpoints-and-datasets","position":25},{"hierarchy":{"lvl1":"GNNs for Chemistry"},"type":"lvl1","url":"/intro","position":0},{"hierarchy":{"lvl1":"GNNs for Chemistry"},"content":"The most recent, state of the art machine learned potentials in atomistic simulations are based on graph models that are trained on large (1M+) datasets. These models can be downloaded and used in a wide array of applications ranging from catalysis to materials properties. These pre-trained models can be used on their own, to accelerate DFT calculation, and they can also be used as a starting point to fine-tune new models for specific tasks.","type":"content","url":"/intro","position":1},{"hierarchy":{"lvl1":"GNNs for Chemistry","lvl2":"Background on DFT and machine learning potentials"},"type":"lvl2","url":"/intro#background-on-dft-and-machine-learning-potentials","position":2},{"hierarchy":{"lvl1":"GNNs for Chemistry","lvl2":"Background on DFT and machine learning potentials"},"content":"Density functional theory (DFT) has been a mainstay in molecular simulation, but its high computational cost limits the number and size of simulations that are practical. Over the past two decades machine learning has increasingly been used to build surrogate models to supplement DFT. We call these models machine learned potentials (MLP). In the early days, neural networks were trained using the cartesian coordinates of atomistic systems as features with some success. These features lack important physical properties, notably they lack invariance to rotations, translations and permutations, and they are extensive features, which limit them to the specific system being investigated. About 15 years ago, a new set of features called symmetry functions were developed that were intensive, and which had these invariances. These functions enabled substantial progress in MLP, but they had a few important limitations. First, the size of the feature vector scaled quadratically with the number of elements, practically limiting the MLP to 4-5 elements. Second, composition was usually implicit in the functions, which limited the transferability of the MLP to new systems. Finally, these functions were “hand-crafted”, with limited or no adaptability to the systems being explored, thus one needed to use judgement and experience to select them. While progress has been made in mitigating these limitations, a new approach has overtaken these methods.\n\nToday, the state of the art in machine learned potentials uses graph convolutions to generate the feature vectors. In this approach, atomistic systems are represented as graphs where each node is an atom, and the edges connect the nodes (atoms) and roughly represent interactions or bonds between atoms. Then, there are machine learnable convolution functions that operate on the graph to generate feature vectors. These operators can work on pairs, triplets and quadruplets of nodes to compute “messages” that are passed to the central node (atom) and accumulated into the feature vector. This feature generate method can be constructed with all the desired invariances, the functions are machine learnable, and adapt to the systems being studied, and it scales well to high numbers of elements (the current models handle 50+ elements). These kind of MLPs began appearing regularly in the literature around 2016.\n\nNote\n\nToday an MLP consists of three things:\n\nA model that takes an atomistic system, generates features and relates those features to some output.\n\nA dataset that provides the atomistic systems and the desired output labels. This label could be energy, forces, or other atomistic properties.\n\nA checkpoint that stores the trained model for use in predictions.","type":"content","url":"/intro#background-on-dft-and-machine-learning-potentials","position":3},{"hierarchy":{"lvl1":"GNNs for Chemistry","lvl2":"FAIR Chemistry models"},"type":"lvl2","url":"/intro#fair-chemistry-models","position":4},{"hierarchy":{"lvl1":"GNNs for Chemistry","lvl2":"FAIR Chemistry models"},"content":"FAIRChem provides a number of GNNs in this repository. Each model represents a different approach to featurization, and a different machine learning architecture. The models can be used for different tasks, and you will find different checkpoints associated with different datasets and tasks. Read the papers for details, but we try to highlight here the core ideas and advancements from one model to the next.\n\nWarning\n\nSince Fairchem version 2.0.0, we are currently only supporting the UMA model code. For all other models please checkout fairchem version 1 of the repo while we bring them back to the new repo.\n\nUniversal Model for Atoms (UMA) - Current SOTA\n\nCore Idea: UMA is an equivariant GNN that leverages a novel technique called Mixture of Linear Experts (MoLE) to give it the capacity to learn the largest multi-modal dataset to date (500M examples and 50B atoms), while preserving energy conservation and inference speed. Even a 6M active parameter (145M total) UMA model is able to achieve SOTA accuracy on a wide range of domains such as materials, molecules and catalysis.\n\nPaper: \n\nhttps://​ai​.meta​.com​/research​/publications​/uma​-a​-family​-of​-universal​-models​-for​-atoms/\n\nequivariant Smooth Energy Network (eSEN)\n\nCore Idea: Scaling GNNs to train on hundreds of millions of structures required a number of engineering decisions that led to SOTA models for some tasks, but led to challenges in other tasks. eSEN started with the eSCN network, carefully analyzed which decisions were necessary to build smooth and energy conserving models, and used those learnings to train a new model that is SOTA (as of early 2025) across many domains.\n\nPaper: \n\nhttps://​arxiv​.org​/abs​/2502​.12147\n\nEquivariant Transformer V2 (EquiformerV2)\n\nCore Idea: We adapted and scaled the Equiformer model to larger datasets using a number of small tweaks/tricks to accelerate training and inference, and incorporating the eSCN convolution operation. This model was also the first shown to be SOTA on OC20 without requiring the underlying structures to be tagged as surface/subsurface atoms, a major improvement in usability.\n\nPaper: \n\nhttps://​arxiv​.org​/abs​/2306​.12059\n\nEquivariant Spherical Channel Network (eSCN)\n\nCore Idea: The SCN network was high performance, but the approach broke equivariance in the resulting models. eSCN enabled equivariance in these models, and introduced an SO(2) convolution operation that allowed the approach to scale to even higher order spherical harmonics. The model was shown to be equivariant in the limit of infinitely fine grid for the convolution operation.\n\nPaper: \n\nhttps://​proceedings​.mlr​.press​/v202​/passaro23a​.html\n\nSpherical Channel Network (SCN)\n\nCore Idea: We developed a message convolution operation, inspired by the vision AI/ML community, that led to more scalable networks and allowed for higher-order spherical harmonics. This model was SOTA on OC20 on release, but introduced some limitations in equivariance addressed later by eSCN.\n\nPaper: \n\nhttps://​proceedings​.neurips​.cc​/paper​_files​/paper​/2022​/hash​/3501bea1ac61fedbaaff2f88e5fa9447​-Abstract​-Conference​.html\n\nGemNet-OC\n\nCore Idea: GemNet-OC is a faster and more scalable version of GemNet, a model that incorporated some clever features like triplet/quadruplet information into GNNs, and provided SOTA performance when released on OC20.\n\nPaper: \n\nhttps://​arxiv​.org​/abs​/2204​.02782","type":"content","url":"/intro#fair-chemistry-models","position":5},{"hierarchy":{"lvl1":"Why model atoms for climate?"},"type":"lvl1","url":"/intro-series","position":0},{"hierarchy":{"lvl1":"Why model atoms for climate?"},"content":"New to chemistry but excited to know how ML can help? \n\nLarry Zitnick has made a few intro videos for audiences without a computational chemistry background!\n\nNote\n\nThis video series covers the basics of how machine learning can accelerate chemistry research for climate applications, starting from fundamental concepts.","type":"content","url":"/intro-series","position":1},{"hierarchy":{"lvl1":"UMA Quick Start w/ ASE"},"type":"lvl1","url":"/quickstart","position":0},{"hierarchy":{"lvl1":"UMA Quick Start w/ ASE"},"content":"The easiest way to use pretrained models is via the \n\nASE FAIRChemCalculator.\nA single UMA model can be used for a wide range of applications in chemistry and materials science by picking the\nappropriate task name for domain specific prediction.\n\nTip\n\nMake sure you have a Hugging Face account, have already applied for model access to the\n\n\nUMA model repository, and have logged in to Hugging Face using an access token.","type":"content","url":"/quickstart","position":1},{"hierarchy":{"lvl1":"UMA Quick Start w/ ASE","lvl2":"Available Tasks"},"type":"lvl2","url":"/quickstart#available-tasks","position":2},{"hierarchy":{"lvl1":"UMA Quick Start w/ ASE","lvl2":"Available Tasks"},"content":"Choose the task that matches your application domain:\n\noc20\n\nHeterogeneous Catalysis\n\nLearn more →\n\nomat\n\nInorganic Materials\n\nLearn more →\n\nomol\n\nMolecules & Polymers\n\nLearn more →\n\nomc\n\nMolecular Crystals\n\nLearn more →\n\nodac\n\nMOFs for Direct Air Capture\n\nLearn more →\n\nNeed to install fairchem-core or get UMA access or getting permissions/401 errors?\n\nInstall the necessary packages using pip, uv etc\n\n! pip install fairchem-core fairchem-data-oc fairchem-applications-cattsunami\n\n\n\nGet access to any necessary huggingface gated models\n\nGet and login to your Huggingface account\n\nRequest access to \n\nhttps://​huggingface​.co​/facebook​/UMA\n\nCreate a Huggingface token at \n\nhttps://​huggingface​.co​/settings​/tokens/ with the permission “Permissions: Read access to contents of all public gated repos you can access”\n\nAdd the token as an environment variable using huggingface-cli login or by setting the HF_TOKEN environment variable.\n\n# Login using the huggingface-cli utility\n! huggingface-cli login\n\n# alternatively,\nimport os\nos.environ['HF_TOKEN'] = 'MY_TOKEN'\n\n","type":"content","url":"/quickstart#available-tasks","position":3},{"hierarchy":{"lvl1":"UMA Quick Start w/ ASE","lvl2":"Relax an adsorbate on a catalytic surface"},"type":"lvl2","url":"/quickstart#relax-an-adsorbate-on-a-catalytic-surface","position":4},{"hierarchy":{"lvl1":"UMA Quick Start w/ ASE","lvl2":"Relax an adsorbate on a catalytic surface"},"content":"from ase.build import fcc100, add_adsorbate, molecule\nfrom ase.optimize import LBFGS\nfrom fairchem.core import pretrained_mlip, FAIRChemCalculator\n\npredictor = pretrained_mlip.get_predict_unit(\"uma-s-1p1\", device=\"cuda\")\ncalc = FAIRChemCalculator(predictor, task_name=\"oc20\")\n\n# Set up your system as an ASE atoms object\nslab = fcc100(\"Cu\", (3, 3, 3), vacuum=8, periodic=True)\nadsorbate = molecule(\"CO\")\nadd_adsorbate(slab, adsorbate, 2.0, \"bridge\")\n\nslab.calc = calc\n\n# Set up LBFGS dynamics object\nopt = LBFGS(slab)\nopt.run(0.05, 100)","type":"content","url":"/quickstart#relax-an-adsorbate-on-a-catalytic-surface","position":5},{"hierarchy":{"lvl1":"UMA Quick Start w/ ASE","lvl2":"Relax an inorganic crystal"},"type":"lvl2","url":"/quickstart#relax-an-inorganic-crystal","position":6},{"hierarchy":{"lvl1":"UMA Quick Start w/ ASE","lvl2":"Relax an inorganic crystal"},"content":"from ase.build import bulk\nfrom ase.optimize import FIRE\nfrom ase.filters import FrechetCellFilter\nfrom fairchem.core import pretrained_mlip, FAIRChemCalculator\n\npredictor = pretrained_mlip.get_predict_unit(\"uma-s-1p1\", device=\"cuda\")\ncalc = FAIRChemCalculator(predictor, task_name=\"omat\")\n\natoms = bulk(\"Fe\")\natoms.calc = calc\n\nopt = LBFGS(FrechetCellFilter(atoms))\nopt.run(0.05, 100)","type":"content","url":"/quickstart#relax-an-inorganic-crystal","position":7},{"hierarchy":{"lvl1":"UMA Quick Start w/ ASE","lvl2":"Run molecular MD"},"type":"lvl2","url":"/quickstart#run-molecular-md","position":8},{"hierarchy":{"lvl1":"UMA Quick Start w/ ASE","lvl2":"Run molecular MD"},"content":"from ase import units\nfrom ase.io import Trajectory\nfrom ase.md.langevin import Langevin\nfrom ase.build import molecule\nfrom fairchem.core import pretrained_mlip, FAIRChemCalculator\n\npredictor = pretrained_mlip.get_predict_unit(\"uma-s-1p1\", device=\"cuda\")\ncalc = FAIRChemCalculator(predictor, task_name=\"omol\")\n\natoms = molecule(\"H2O\")\natoms.calc = calc\n\ndyn = Langevin(\n    atoms,\n    timestep=0.1 * units.fs,\n    temperature_K=400,\n    friction=0.001 / units.fs,\n)\ntrajectory = Trajectory(\"my_md.traj\", \"w\", atoms)\ndyn.attach(trajectory.write, interval=1)\ndyn.run(steps=1000)","type":"content","url":"/quickstart#run-molecular-md","position":9},{"hierarchy":{"lvl1":"UMA Quick Start w/ ASE","lvl2":"Calculate a spin gap"},"type":"lvl2","url":"/quickstart#calculate-a-spin-gap","position":10},{"hierarchy":{"lvl1":"UMA Quick Start w/ ASE","lvl2":"Calculate a spin gap"},"content":"Note\n\nFor molecular systems using the omol task, you can specify charge and spin multiplicity via the atoms.info dictionary. This is important for modeling charged or open-shell systems.from ase.build import molecule\nfrom fairchem.core import pretrained_mlip, FAIRChemCalculator\n\npredictor = pretrained_mlip.get_predict_unit(\"uma-s-1p1\", device=\"cuda\")\n\n#  singlet CH2\nsinglet = molecule(\"CH2_s1A1d\")\nsinglet.info.update({\"spin\": 1, \"charge\": 0})\nsinglet.calc = FAIRChemCalculator(predictor, task_name=\"omol\")\n\n#  triplet CH2\ntriplet = molecule(\"CH2_s3B1d\")\ntriplet.info.update({\"spin\": 3, \"charge\": 0})\ntriplet.calc = FAIRChemCalculator(predictor, task_name=\"omol\")\n\ntriplet.get_potential_energy() - singlet.get_potential_energy()","type":"content","url":"/quickstart#calculate-a-spin-gap","position":11},{"hierarchy":{"lvl1":"UMA Models"},"type":"lvl1","url":"/uma","position":0},{"hierarchy":{"lvl1":"UMA Models"},"content":"UMA is an equivariant GNN that leverages a novel technique called Mixture of Linear Experts (MoLE) to give it the capacity to learn the largest multi-modal dataset to date (500M DFT examples), while preserving energy conservation and inference speed. Even a 6M active parameter (145M total) UMA model is able to achieve SOTA accuracy on a wide range of domains such as materials, molecules and catalysis. \n\narXiv Paper","type":"content","url":"/uma","position":1},{"hierarchy":{"lvl1":"UMA Models","lvl2":"The UMA Mixture-of-Linear-Experts routing function"},"type":"lvl2","url":"/uma#the-uma-mixture-of-linear-experts-routing-function","position":2},{"hierarchy":{"lvl1":"UMA Models","lvl2":"The UMA Mixture-of-Linear-Experts routing function"},"content":"Note\n\nThe Mixture-of-Linear-Expert (MoLE) architecture is key to UMA’s performance. It enables very high parameter count with fast inference speeds by using a single output head with dynamic routing.\n\nThe UMA model uses a Mixture-of-Linear-Expert (MoLE) architecture to achieve very high parameter count with fast inference speeds with a single output head. In order to route the model to the correct set parameters, the model must be given a set of inputs. The following information is required for the input to the model:\n\nTask\n\nThe task specifies the level of theory/DFT calculations to emulate: omol, oc20, omat, odac, omc\n\nCharge\n\nTotal known charge of the system (only used for omol task, defaults to 0)\n\nSpin\n\nTotal spin multiplicity of the system (only used for omol task, defaults to 1)\n\nElemental Composition\n\nThe unordered total elemental composition. Each element has an atom embedding and the composition embedding is the mean over all atom embeddings.","type":"content","url":"/uma#the-uma-mixture-of-linear-experts-routing-function","position":3},{"hierarchy":{"lvl1":"UMA Models","lvl3":"The UMA task","lvl2":"The UMA Mixture-of-Linear-Experts routing function"},"type":"lvl3","url":"/uma#the-uma-task","position":4},{"hierarchy":{"lvl1":"UMA Models","lvl3":"The UMA task","lvl2":"The UMA Mixture-of-Linear-Experts routing function"},"content":"UMA is trained on 5 different DFT datasets with different levels of theory. An UMA task refers to a specific level of theory associated with that DFT dataset. UMA learns an embedding for the given task. Thus at inference time, the user must specify which one of the 5 embeddings they want to use to produce an output with the DFT level of theory they want.\n\nTip\n\nChoose your task based on the application domain. Each task corresponds to a specific DFT level of theory optimized for that domain.\n\nTask\n\nDataset\n\nDFT Level of Theory\n\nRelevant Applications\n\nUsage Notes\n\nomol\n\nOMol25\n\nwB97M-V/def2-TZVPD as implemented in ORCA6, including non-local dispersion. All solvation should be explicit.\n\nBiology, organic chemistry, protein folding, small-molecule pharmaceuticals, organic liquid properties, homogeneous catalysis\n\nRequires total charge and spin multiplicity. If you don’t know what these are, you should be very careful if modeling charged or open-shell systems. This can be used to study radical chemistry or understand the impact of magnetic states on the structure of a molecule. All training data is aperiodic, so any periodic systems should be treated with some caution. Probably won’t work well for inorganic materials.\n\nomc\n\nOMC25\n\nPBE+D3 as implemented in VASP.\n\nPharmaceutical packaging, bio-inspired materials, organic electronics, organic LEDs\n\nUMA has not seen varying charge or spin multiplicity for the OMC task, and expects total_charge=0 and spin multiplicity=0 as model inputs.\n\nomat\n\nOMat24\n\nPBE/PBE+U as implemented in VASP using Materials Project suggested settings, except with VASP 54 pseudopotentials. No dispersion.\n\nInorganic materials discovery, solar photovoltaics, advanced alloys, superconductors, electronic materials, optical materials\n\nUMA has not seen varying charge or spin multiplicity for the OMat task, and expects total_charge=0 and spin multiplicity=0 as model inputs. Spin polarization effects are included, but you can’t select the magnetic state. Further, OMat24 did not fully sample possible spin states in the training data.\n\noc20\n\nOC20*\n\nRPBE as implemented in VASP, with VASP5.4 pseudopotentials. No dispersion.\n\nRenewable energy, catalysis, fuel cells, energy conversion, sustainable fertilizer production, chemical refining, plastics synthesis/upcycling\n\nUMA has not seen varying charge or spin multiplicity for the OC20 task, and expects total_charge=0 and spin multiplicity=0 as model inputs. No oxides or explicit solvents are included in OC20. The model works surprisingly well for transition state searches given the nature of the training data, but you should be careful. RPBE works well for small molecules, but dispersion will be important for larger molecules on surfaces.\n\nodac\n\nODAC23\n\nPBE+D3 as implemented in VASP, with VASP5.4 pseudopotentials.\n\nDirect air capture, carbon capture and storage, CO2 conversion, catalysis\n\nUMA has not seen varying charge or spin multiplicity for the ODAC task, and expects total_charge=0 and spin multiplicity=0 as model inputs. The ODAC23 dataset only contains CO2/H2O water absorption, so anything more than might be inaccurate (e.g. hydrocarbons in MOFs). Further, there is a limited number of bare-MOF structures in the training data, so you should be careful if you are using a new MOF structure.\n\nNote\n\n*OC20 was updated from the original OC20 and recomputed to produce total energies instead of adsorption energies.","type":"content","url":"/uma#the-uma-task","position":5},{"hierarchy":{"lvl1":"UMA FAQ"},"type":"lvl1","url":"/uma-faq","position":0},{"hierarchy":{"lvl1":"UMA FAQ"},"content":"This page will be updated with FAQ questions as we get them. Please feel free to add PRs if there are questions/explanations that you think others would find helpful!\n\nHow do I choose the right task?\n\nChoose your task based on your application domain:\n\nomol: For molecules, biology, organic chemistry, pharmaceuticals\n\nomat: For inorganic materials, solar cells, alloys, superconductors\n\noc20: For heterogeneous catalysis, fuel cells, energy conversion\n\nodac: For MOFs and direct air capture applications\n\nomc: For molecular crystals, organic electronics\n\nWhy am I getting a 401 error when loading the model?\n\nYou need to:\n\nCreate a HuggingFace account\n\nRequest access to the \n\nUMA model\n\nCreate a token with read access at \n\nhttps://​huggingface​.co​/settings​/tokens/\n\nLogin with huggingface-cli login or set HF_TOKEN environment variable\n\nCan I use UMA for periodic systems with the omol task?\n\nThe omol task was trained on aperiodic (molecular) data, so periodic systems should be treated with caution. For periodic materials, consider using omat or oc20 depending on your application.\n\nHow do I specify charge and spin for molecules?\n\nFor the omol task, set charge and spin in the atoms.info dictionary:atoms.info.update({\"spin\": 1, \"charge\": 0})\n\nOther tasks (omat, oc20, odac, omc) expect charge=0 and spin=0.","type":"content","url":"/uma-faq","position":1},{"hierarchy":{"lvl1":"Open Direct Air Capture 2023 (ODAC23)"},"type":"lvl1","url":"/odac23","position":0},{"hierarchy":{"lvl1":"Open Direct Air Capture 2023 (ODAC23)"},"content":"Warning\n\nDeprecated: ODAC23 has been superseded by \n\nODAC25, which contains nearly 70 million DFT calculations across 4 adsorbates (CO2, H2O, N2, O2) in nearly 15,000 MOFs. We recommend using ODAC25 for new projects.\n\nDataset Overview\n\nProperty\n\nValue\n\nSize\n\n~1M structures (S2EF), ~10K structures (IS2RE)\n\nDomain\n\nMetal-organic frameworks (MOFs) with CO2\n\nLabels\n\nTotal energy (eV), forces (eV/A)\n\nLevel of Theory\n\nPBE+D3 (VASP)\n\nLicense\n\nCC BY 4.0\n\nStatus\n\nDeprecated - use ODAC25","type":"content","url":"/odac23","position":1},{"hierarchy":{"lvl1":"Open Direct Air Capture 2023 (ODAC23)","lvl2":"Structure to Energy and Forces (S2EF) task"},"type":"lvl2","url":"/odac23#structure-to-energy-and-forces-s2ef-task","position":2},{"hierarchy":{"lvl1":"Open Direct Air Capture 2023 (ODAC23)","lvl2":"Structure to Energy and Forces (S2EF) task"},"content":"We provide precomputed LMDBs for train, validation, and the various test sets that can be used directly with the dataloaders provided in our code. The LMDBs contain input structures from all points in relaxation trajectories along with the energy of the structure and the atomic forces. The dataset contains an in-domain test set and 4 out-of-domain test sets (ood-large, ood-linker, ood-topology, and ood-linker & topology). All LMDbs  are compressed into a single .tar.gz file.\n\nSplits\n\nSize of compressed version (in bytes)\n\nSize of uncompressed version (in bytes)\n\nMD5 checksum (download link)\n\nTrain + Validation + Test (all splits)\n\n172G\n\n476G\n\n162f0660b2f1c9209c5b57f7b9e545a7\n\n\n\n\n\n\n\n\n\nThe train and val splits are also available in extxyz formats. Each trajectory is in stored in a different extxyz file.\n\nSplits\n\nSize of compressed version (in bytes)\n\nSize of uncompressed version (in bytes)\n\nMD5 checksum (download link)\n\nTrain\n\n232G\n\n781G\n\n381e72fd8b9c055065fd3afff6b0945b\n\nVal\n\n5.1G\n\n18G\n\n09913759c6e0f8d649f7ec9dff9e0e8b\n\n\n\n\n\n\n\n","type":"content","url":"/odac23#structure-to-energy-and-forces-s2ef-task","position":3},{"hierarchy":{"lvl1":"Open Direct Air Capture 2023 (ODAC23)","lvl2":"Initial Structure to Relaxed Structure (IS2RS) / Relaxed Energy (IS2RE) tasks"},"type":"lvl2","url":"/odac23#initial-structure-to-relaxed-structure-is2rs-relaxed-energy-is2re-tasks","position":4},{"hierarchy":{"lvl1":"Open Direct Air Capture 2023 (ODAC23)","lvl2":"Initial Structure to Relaxed Structure (IS2RS) / Relaxed Energy (IS2RE) tasks"},"content":"For IS2RE / IS2RS training, validation and test sets, we provide precomputed LMDBs that can be directly used with dataloaders provided in our code. The LMDBs contain input initial structures and the output relaxed structures and energies. The dataset contains an in-domain test set and 4 out-of-domain test sets (ood-large, ood-linker, ood-topology, and ood-linker & topology). All LMDBs are compressed into a single .tar.gz file.\n\nSplits\n\nSize of compressed version (in bytes)\n\nSize of uncompressed version (in bytes)\n\nMD5 checksum (download link)\n\nTrain + Validation + Test (all splits)\n\n809M\n\n2.2G\n\nf7f2f58669a30abae8cb9ba1b7f2bcd2\n\n\n\n\n\n\n\n","type":"content","url":"/odac23#initial-structure-to-relaxed-structure-is2rs-relaxed-energy-is2re-tasks","position":5},{"hierarchy":{"lvl1":"Open Direct Air Capture 2023 (ODAC23)","lvl2":"DDEC Charges"},"type":"lvl2","url":"/odac23#ddec-charges","position":6},{"hierarchy":{"lvl1":"Open Direct Air Capture 2023 (ODAC23)","lvl2":"DDEC Charges"},"content":"We provide DDEC charges computed for all MOFs in the ODAC23 dataset. A small number of MOFs (~2%) are missing these charges because the DDEC calcuations failed for them.\n\nSize of compressed version (in bytes)\n\nSize of uncompressed version (in bytes)\n\nMD5 checksum (download link)\n\n147M\n\n534M\n\n81927b78d9e4184cc3c398e79760126a\n\n\n\n\n\n","type":"content","url":"/odac23#ddec-charges","position":7},{"hierarchy":{"lvl1":"Open Direct Air Capture 2023 (ODAC23)","lvl2":"Citing ODAC23"},"type":"lvl2","url":"/odac23#citing-odac23","position":8},{"hierarchy":{"lvl1":"Open Direct Air Capture 2023 (ODAC23)","lvl2":"Citing ODAC23"},"content":"The OpenDAC 2023 (ODAC23) dataset is licensed under a \n\nCreative Commons Attribution 4.0 License.\n\nPlease consider citing the following paper in any research manuscript using the ODAC23 dataset:@article{odac23_dataset,\n    author = {Anuroop Sriram and Sihoon Choi and Xiaohan Yu and Logan M. Brabson and Abhishek Das and Zachary Ulissi and Matt Uyttendaele and Andrew J. Medford and David S. Sholl},\n    title = {The Open DAC 2023 Dataset and Challenges for Sorbent Discovery in Direct Air Capture},\n    year = {2023},\n    journal={arXiv preprint arXiv:2311.00341},\n}","type":"content","url":"/odac23#citing-odac23","position":9},{"hierarchy":{"lvl1":"ODAC25"},"type":"lvl1","url":"/odac25","position":0},{"hierarchy":{"lvl1":"ODAC25"},"content":"Dataset Overview\n\nProperty\n\nValue\n\nSize\n\n~70 million DFT calculations\n\nDomain\n\nMetal-organic frameworks (MOFs)\n\nAdsorbates\n\nCO2, H2O, N2, O2\n\nMOFs\n\n~15,000 structures\n\nLabels\n\nTotal energy (eV), forces (eV/A)\n\nLevel of Theory\n\nPBE+D3 (VASP)\n\nLicense\n\nCC BY 4.0\n\nDownload\n\nHuggingFace\n\nThe Open DAC 2025 (ODAC25) dataset contains nearly 70 million DFT single-point\ncalculations for CO2, H2O, N2, and O2 adsorption in nearly 15,000 metal-organic frameworks\n(MOFs). This dataset represents a significant expansion upon ODAC23, introducing\ngreater chemical and configurational diversity through functionalized MOFs,\nhigh-energy GCMC-derived placements, and synthetically generated frameworks.\n\nThe dataset enables training of state-of-the-art machine-learned interatomic\npotentials for direct air capture applications. All structures are labeled\nwith total energies (eV) and forces (eV/Å) computed using VASP with the\nPBE+D3 functional.\n\nAll information about the dataset is available at the\n\n\nODAC25 Huggingface site.\nFor questions or issues, please open a GitHub issue in this repository.","type":"content","url":"/odac25","position":1},{"hierarchy":{"lvl1":"ODAC25","lvl2":"Dataset format"},"type":"lvl2","url":"/odac25#dataset-format","position":2},{"hierarchy":{"lvl1":"ODAC25","lvl2":"Dataset format"},"content":"The dataset is provided in ASE DB compatible lmdb files (*.aselmdb).","type":"content","url":"/odac25#dataset-format","position":3},{"hierarchy":{"lvl1":"ODAC25","lvl3":"Citing ODAC25","lvl2":"Dataset format"},"type":"lvl3","url":"/odac25#citing-odac25","position":4},{"hierarchy":{"lvl1":"ODAC25","lvl3":"Citing ODAC25","lvl2":"Dataset format"},"content":"The ODAC25 dataset is licensed under a \n\nCreative Commons Attribution 4.0 License.\n\nPlease consider citing the following paper in any publications that uses this dataset:@misc{sriram2025odac25,\n    title={The Open DAC 2025 Dataset for Sorbent Discovery in Direct Air Capture}, \n    author={Anuroop Sriram and Logan M. Brabson and Xiaohan Yu and Sihoon Choi and Kareem Abdelmaqsoud and Elias Moubarak and Pim de Haan and Sindy Löwe and Johann Brehmer and John R. Kitchin and Max Welling and C. Lawrence Zitnick and Zachary Ulissi and Andrew J. Medford and David S. Sholl},\n    year={2025},\n    eprint={},\n    archivePrefix={arXiv},\n    primaryClass={},\n    url={}, \n}","type":"content","url":"/odac25#citing-odac25","position":5},{"hierarchy":{"lvl1":"Datasets"},"type":"lvl1","url":"/summary-7","position":0},{"hierarchy":{"lvl1":"Datasets"},"content":"\n\nExplore the Direct Air Capture (DAC) datasets for training machine learning models on metal-organic frameworks (MOFs).\n\nODAC25\n\nNearly 70 million DFT calculations for CO2, H2O, N2, and O2 adsorption in nearly 15,000 MOFs.\n\nODAC23 (Deprecated)\n\nThe original Open DAC dataset. Superseded by ODAC25.","type":"content","url":"/summary-7","position":1},{"hierarchy":{"lvl1":"Adsorption Energies in MOFs"},"type":"lvl1","url":"/adsorption-energy","position":0},{"hierarchy":{"lvl1":"Adsorption Energies in MOFs"},"content":"What You Will Learn\n\nCalculate CO2 and H2O adsorption energies in metal-organic frameworks, including accounting for MOF flexibility and deformation.\n\nPre-trained ODAC models are versatile across various MOF-related tasks. To begin, we’ll start with a fundamental application: calculating the adsorption energy for a single CO2 molecule. This serves as an excellent and simple demonstration of what you can achieve with these datasets and models.\n\nFor predicting the adsorption energy of a single CO2 molecule within a MOF structure, the adsorption energy (E_{\\mathrm{ads}}) is defined as:E_{\\mathrm{ads}} = E_{\\mathrm{MOF+CO2}} - E_{\\mathrm{MOF}} - E_{\\mathrm{CO2}} \\tag{1}\n\nEach term on the right-hand side represents the energy of the relaxed state of the indicated chemical system. For a comprehensive understanding of our methodology for computing these adsorption energies, please refer to our \n\npaper.","type":"content","url":"/adsorption-energy","position":1},{"hierarchy":{"lvl1":"Adsorption Energies in MOFs","lvl2":"Loading Pre-trained Models"},"type":"lvl2","url":"/adsorption-energy#loading-pre-trained-models","position":2},{"hierarchy":{"lvl1":"Adsorption Energies in MOFs","lvl2":"Loading Pre-trained Models"},"content":"Need to install fairchem-core or get UMA access or getting permissions/401 errors?\n\nInstall the necessary packages using pip, uv etc\n\n! pip install fairchem-core fairchem-data-oc fairchem-applications-cattsunami\n\n\n\nGet access to any necessary huggingface gated models\n\nGet and login to your Huggingface account\n\nRequest access to \n\nhttps://​huggingface​.co​/facebook​/UMA\n\nCreate a Huggingface token at \n\nhttps://​huggingface​.co​/settings​/tokens/ with the permission “Permissions: Read access to contents of all public gated repos you can access”\n\nAdd the token as an environment variable using huggingface-cli login or by setting the HF_TOKEN environment variable.\n\n# Login using the huggingface-cli utility\n! huggingface-cli login\n\n# alternatively,\nimport os\nos.environ['HF_TOKEN'] = 'MY_TOKEN'\n\n\n\nA pre-trained model can be loaded using FAIRChemCalculator. In this example, we’ll employ UMA to determine the CO2 adsorption energies.\n\nfrom fairchem.core import FAIRChemCalculator, pretrained_mlip\n\npredictor = pretrained_mlip.get_predict_unit(\"uma-s-1p1\")\ncalc = FAIRChemCalculator(predictor, task_name=\"odac\")\n\n\n\n","type":"content","url":"/adsorption-energy#loading-pre-trained-models","position":3},{"hierarchy":{"lvl1":"Adsorption Energies in MOFs","lvl2":"Adsorption in rigid MOFs: CO2 Adsorption Energy in Mg-MOF-74"},"type":"lvl2","url":"/adsorption-energy#adsorption-in-rigid-mofs-co2-adsorption-energy-in-mg-mof-74","position":4},{"hierarchy":{"lvl1":"Adsorption Energies in MOFs","lvl2":"Adsorption in rigid MOFs: CO2 Adsorption Energy in Mg-MOF-74"},"content":"Let’s apply our knowledge to Mg-MOF-74, a widely studied MOF known for its excellent CO2 adsorption properties. Its structure comprises magnesium atomic complexes connected by a carboxylated and oxidized benzene ring, serving as an organic linker. Previous studies consistently report the CO2 adsorption energy for Mg-MOF-74 to be around -0.40 eV \n\n[1] \n\n[2] \n\n[3].\n\nOur goal is to verify if we can achieve a similar value by performing a simple single-point calculation using UMA. In the ODAC23 dataset, all MOF structures are identified by their CSD (Cambridge Structural Database) code. For Mg-MOF-74, this code is OPAGIX. We’ve extracted a specific OPAGIX+CO2 configuration from the dataset, which exhibits the lowest adsorption energy among its counterparts.\n\nimport matplotlib.pyplot as plt\nfrom ase.io import read\nfrom ase.visualize.plot import plot_atoms\n\nmof_co2 = read(\"structures/OPAGIX_w_CO2.cif\")\nmof = read(\"structures/OPAGIX.cif\")\nco2 = read(\"structures/co2.xyz\")\n\nfig, ax = plt.subplots(figsize=(5, 4.5), dpi=250)\nplot_atoms(mof_co2, ax)\nax.set_axis_off()\n\n\n\nThe final step in calculating the adsorption energy involves connecting the FAIRChemCalculator to each relaxed structure: OPAGIX+CO2, OPAGIX, and CO2. The structures used here are already relaxed from ODAC23. For simplicity, we assume here that further relaxations can be neglected. We will show how to go beyond this assumption in the next section.\n\nmof_co2.calc = calc\nmof.calc = calc\nco2.calc = calc\n\nE_ads = (\n    mof_co2.get_potential_energy()\n    - mof.get_potential_energy()\n    - co2.get_potential_energy()\n)\n\nprint(f\"Adsorption energy of CO2 in Mg-MOF-74: {E_ads:.3f} eV\")\n\n\n\n","type":"content","url":"/adsorption-energy#adsorption-in-rigid-mofs-co2-adsorption-energy-in-mg-mof-74","position":5},{"hierarchy":{"lvl1":"Adsorption Energies in MOFs","lvl2":"Adsorption in flexible MOFs"},"type":"lvl2","url":"/adsorption-energy#adsorption-in-flexible-mofs","position":6},{"hierarchy":{"lvl1":"Adsorption Energies in MOFs","lvl2":"Adsorption in flexible MOFs"},"content":"The adsorption energy calculation method outlined above is typically performed with rigid MOFs for simplicity. Both experimental and modeling literature have shown, however, that MOF flexibility can be important in accurately capturing the underlying chemistry of adsorption \n\n[1] \n\n[2] \n\n[3]. In particular, uptake can be improved by treating MOFs as flexible. Two types of MOF flexibility can be considered: intrinsic flexibility and deformation induced by guest molecules. In the Open DAC Project, we consider the latter MOF deformation by allowing the atomic positions of the MOF to relax during geometry optimization \n\n[4]. The addition of additional degrees of freedoms can complicate the computation of the adsorption energy and necessitates an extra step in the calculation procedure.\n\nThe figure below shows water adsorption in the MOF with CSD code WOBHEB with added defects (WOBHEB_0.11_0) from a DFT simulation. A typical adsorption energy calculation would only seek to capture the effects shaded in purple, which include both chemisorption and non-bonded interactions between the host and guest molecule. When allowing the MOF to relax, however, the adsorption energy also includes the energetic effect of the MOF deformation highlighted in green.\n\n\n\nTo account for this deformation, it is vital to use the most energetically favorable MOF geometry for the empty MOF term in Eqn. 1. Including MOF atomic coordinates as degrees of freedom can result in three possible outcomes:\n\nThe MOF does not deform, so the energies of the relaxed empty MOF and the MOF in the adsorbed state are the same\n\nThe MOF deforms to a less energetically favorable geometry than its ground state\n\nThe MOF locates a new energetically favorable geoemtry relative to the empty MOF relaxation\n\nThe first outcome requires no additional computation because the MOF rigidity assumption is valid. The second outcome represents physical and reversible deformation where the MOF returns to its empty ground state upon removal of the guest molecule. The third outcome is often the result of the guest molecule breaking local symmetry. We also found cases in ODAC in which both outcomes 2 and 3 occur within the same MOF.\n\nTo ensure the most energetically favorable empty MOF geometry is found, an addition empty MOF relaxation should be performed after MOF + adsorbate relaxation. The guest molecule should be removed, and the MOF should be relaxed starting from its geometry in the adsorbed state. If all deformation is reversible, the MOF will return to its original empty geometry. Otherwise, the lowest energy (most favorable) MOF geometry should be taken as the reference energy, E_{\\mathrm{MOF}}, in Eqn. 1.","type":"content","url":"/adsorption-energy#adsorption-in-flexible-mofs","position":7},{"hierarchy":{"lvl1":"Adsorption Energies in MOFs","lvl3":"H2O Adsorption Energy in Flexible WOBHEB with UMA","lvl2":"Adsorption in flexible MOFs"},"type":"lvl3","url":"/adsorption-energy#h2o-adsorption-energy-in-flexible-wobheb-with-uma","position":8},{"hierarchy":{"lvl1":"Adsorption Energies in MOFs","lvl3":"H2O Adsorption Energy in Flexible WOBHEB with UMA","lvl2":"Adsorption in flexible MOFs"},"content":"The first part of this tutorial demonstrates how to perform a single point adsorption energy calculation using UMA. To treat MOFs as flexible, we perform all calculations on geometries determined by geometry optimization. The following example corresponds to the figure shown above (H2O adsorption in WOBHEB_0.11_0).\n\nIn this tutorial, E_{x}(r_{y}) corresponds to the energy of x determined from geometry optimization of y.\n\nFirst, we obtain the energy of the empty MOF from relaxation of only the MOF: E_{\\mathrm{MOF}}(r_{\\mathrm{MOF}})\n\nimport ase.io\nfrom ase.optimize import BFGS\n\nmof = ase.io.read(\"structures/WOBHEB_0.11.cif\")\nmof.calc = calc\nrelax = BFGS(mof)\nrelax.run(fmax=0.05)\nE_mof_empty = mof.get_potential_energy()\nprint(f\"Energy of empty MOF: {E_mof_empty:.3f} eV\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNext, we add the H2O guest molecule and relax the MOF + adsorbate to obtain E_{\\mathrm{MOF+H2O}}(r_{\\mathrm{MOF+H2O}}).\n\nmof_h2o = ase.io.read(\"structures/WOBHEB_H2O.cif\")\nmof_h2o.calc = calc\nrelax = BFGS(mof_h2o)\nrelax.run(fmax=0.05)\nE_combo = mof_h2o.get_potential_energy()\nprint(f\"Energy of MOF + H2O: {E_combo:.3f} eV\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can now isolate the MOF atoms from the relaxed MOF + H2O geometry and see that the MOF has adopted a geometry that is less energetically favorable than the empty MOF by ~0.2 eV. The energy of the MOF in the adsorbed state corresponds to E_{\\mathrm{MOF}}(r_{\\mathrm{MOF+H2O}}).\n\nmof_adsorbed_state = mof_h2o[:-3]\nmof_adsorbed_state.calc = calc\nE_mof_adsorbed_state = mof_adsorbed_state.get_potential_energy()\nprint(f\"Energy of MOF in the adsorbed state: {E_mof_adsorbed_state:.3f} eV\")\n\n\n\nH2O adsorption in this MOF appears to correspond to Case #2 as outlined above. We can now perform re-relaxation of the empty MOF starting from the r_{\\mathrm{MOF+H2O}} geometry.\n\nrelax = BFGS(mof_adsorbed_state)\nrelax.run(fmax=0.05)\nE_mof_rerelax = mof_adsorbed_state.get_potential_energy()\nprint(f\"Energy of re-relaxed empty MOF: {E_mof_rerelax:.3f} eV\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe MOF returns to its original empty reference energy upon re-relaxation, confirming that this deformation is physically relevant and is induced by the adsorbate molecule. In Case #3, this re-relaxed energy will be more negative (more favorable) than the original empty MOF relaxation. Thus, we take the reference empty MOF energy (E_{\\mathrm{MOF}} in Eqn. 1) to be the minimum of the original empty MOF energy and the re-relaxed MOf energy:\n\nE_mof = min(E_mof_empty, E_mof_rerelax)\n\n# get adsorbate reference energy\nh2o = mof_h2o[-3:]\nh2o.calc = calc\nE_h2o = h2o.get_potential_energy()\n\n# compute adsorption energy\nE_ads = E_combo - E_mof - E_h2o\nprint(f\"Adsorption energy of H2O in WOBHEB_0.11_0: {E_ads:.3f} eV\")\n\n\n\nThis adsorption energy closely matches that from DFT (–0.699 eV) \n\n[1]. The strong adsorption energy is a consequence of both H2O chemisorption and MOF deformation. We can decompose the adsorption energy into contributions from these two factors. Assuming rigid H2O molecules, we define E_{\\mathrm{int}} and E_{\\mathrm{MOF,deform}}, respectively, asE_{\\mathrm{int}} = E_{\\mathrm{MOF+H2O}}(r_{\\mathrm{MOF+H2O}}) - E_{\\mathrm{MOF}}(r_{\\mathrm{MOF+H2O}}) - E_{\\mathrm{H2O}}(r_{\\mathrm{MOF+H2O}}) \\tag{2}E_{\\mathrm{MOF,deform}} = E_{\\mathrm{MOF}}(r_{\\mathrm{MOF+H2O}}) - E_{\\mathrm{MOF}}(r_{\\mathrm{MOF}}) \\tag{3}\n\nE_{\\mathrm{int}} describes host host–guest interactions for the MOF in the adsorbed state only. E_{\\mathrm{MOF,deform}} quantifies the magnitude of deformation between the MOF in the adsorbed state and the most energetically favorable empty MOF geometry determined from the workflow presented here. It can be shown thatE_{\\mathrm{ads}} = E_{\\mathrm{int}} + E_{\\mathrm{MOF,deform}} \\tag{4}\n\nFor H2O adsorption in WOBHEB_0.11, we have\n\nE_int = E_combo - E_mof_adsorbed_state - E_h2o\nprint(f\"E_int: {E_int}\")\n\n\n\n\n\nE_mof_deform = E_mof_adsorbed_state - E_mof_empty\nprint(f\"E_mof_deform: {E_mof_deform}\")\n\n\n\n\n\nE_ads = E_int + E_mof_deform\nprint(f\"E_ads: {E_ads}\")\n\n\n\nE_{\\mathrm{int}} is equivalent to E_{\\mathrm{ads}} when the MOF is assumed to be rigid. In this case, failure to consider adsorbate-induced deformation would result in an overestimation of the adsorption energy magnitude.","type":"content","url":"/adsorption-energy#h2o-adsorption-energy-in-flexible-wobheb-with-uma","position":9},{"hierarchy":{"lvl1":"Adsorption Energies in MOFs","lvl2":"Acknowledgements & Authors"},"type":"lvl2","url":"/adsorption-energy#acknowledgements-authors","position":10},{"hierarchy":{"lvl1":"Adsorption Energies in MOFs","lvl2":"Acknowledgements & Authors"},"content":"Logan Brabson and Sihoon Choi (Georgia Tech) and the OpenDAC project.","type":"content","url":"/adsorption-energy#acknowledgements-authors","position":11},{"hierarchy":{"lvl1":"Examples & Tutorials"},"type":"lvl1","url":"/summary-8","position":0},{"hierarchy":{"lvl1":"Examples & Tutorials"},"content":"\n\nLearn how to use FAIRChem models for Direct Air Capture (DAC) applications with metal-organic frameworks (MOFs).\n\nAdsorption Energy\n\nCalculate CO2 and H2O adsorption energies in MOFs, including flexible framework effects.","type":"content","url":"/summary-8","position":1},{"hierarchy":{"lvl1":"Pretrained models"},"type":"lvl1","url":"/models-3","position":0},{"hierarchy":{"lvl1":"Pretrained models"},"content":"\n\nRecommended Models\n\nFor CO2 and H2O adsorption: Use \n\nUMA, trained on all FAIR chemistry datasets including ODAC25.\n\nFor N2 and O2 adsorption: Use the dedicated eSEN models trained on ODAC25, as UMA was not trained on these adsorbates.","type":"content","url":"/models-3","position":1},{"hierarchy":{"lvl1":"Pretrained models","lvl2":"ODAC25 Models"},"type":"lvl2","url":"/models-3#odac25-models","position":2},{"hierarchy":{"lvl1":"Pretrained models","lvl2":"ODAC25 Models"},"content":"As part of the ODAC25 release, we released two sets of models:\n\nUMA models trained on a range of FAIR chemistry datasets including a subset of ODAC25, available at the \n\nUMA HuggingFace site\n\neSEN models trained only on ODAC25, available at the \n\nODAC25 HuggingFace site\n\nThe UMA models were only trained on CO₂ and H₂O adsorbates, and are competitive with\nthe eSEN models for these adsorbates. Since the UMA models were not trained on\nN₂ and O₂, we strongly recommend using the eSEN models for these.\n\nIf you use the ODAC25 trained models, please cite the following paper:@misc{sriram2025odac25,\n    title={The Open DAC 2025 Dataset for Sorbent Discovery in Direct Air Capture}, \n    author={Anuroop Sriram and Logan M. Brabson and Xiaohan Yu and Sihoon Choi and Kareem Abdelmaqsoud and Elias Moubarak and Pim de Haan and Sindy Löwe and Johann Brehmer and John R. Kitchin and Max Welling and C. Lawrence Zitnick and Zachary Ulissi and Andrew J. Medford and David S. Sholl},\n    year={2025},\n    eprint={},\n    archivePrefix={arXiv},\n    primaryClass={},\n    url={}, \n}","type":"content","url":"/models-3#odac25-models","position":3},{"hierarchy":{"lvl1":"Pretrained models","lvl2":"ODAC23 Models"},"type":"lvl2","url":"/models-3#odac23-models","position":4},{"hierarchy":{"lvl1":"Pretrained models","lvl2":"ODAC23 Models"},"content":"Warning\n\nDeprecated: These models are superseded by ODAC25 models and UMA. They are provided here for reproducibility only.\n\nAll config files for the ODAC23 models are available in the \n\nconfigs/odac directory.","type":"content","url":"/models-3#odac23-models","position":5},{"hierarchy":{"lvl1":"Pretrained models","lvl3":"S2EF models","lvl2":"ODAC23 Models"},"type":"lvl3","url":"/models-3#s2ef-models","position":6},{"hierarchy":{"lvl1":"Pretrained models","lvl3":"S2EF models","lvl2":"ODAC23 Models"},"content":"Model Name\n\nModel\n\nCheckpoint\n\nConfig\n\nSchNet-S2EF-ODAC\n\nSchNet\n\ncheckpoint\n\nconfig\n\nDimeNet++-S2EF-ODAC\n\nDimeNet++\n\ncheckpoint\n\nconfig\n\nPaiNN-S2EF-ODAC\n\nPaiNN\n\ncheckpoint\n\nconfig\n\nGemNet-OC-S2EF-ODAC\n\nGemNet-OC\n\ncheckpoint\n\nconfig\n\neSCN-S2EF-ODAC\n\neSCN\n\ncheckpoint\n\nconfig\n\nEquiformerV2-S2EF-ODAC\n\nEquiformerV2\n\ncheckpoint\n\nconfig\n\nEquiformerV2-Large-S2EF-ODAC\n\nEquiformerV2 (Large)\n\ncheckpoint\n\nconfig","type":"content","url":"/models-3#s2ef-models","position":7},{"hierarchy":{"lvl1":"Pretrained models","lvl3":"IS2RE Direct models","lvl2":"ODAC23 Models"},"type":"lvl3","url":"/models-3#is2re-direct-models","position":8},{"hierarchy":{"lvl1":"Pretrained models","lvl3":"IS2RE Direct models","lvl2":"ODAC23 Models"},"content":"Model Name\n\nModel\n\nCheckpoint\n\nConfig\n\nGemnet-OC-IS2RE-ODAC\n\nGemnet-OC\n\ncheckpoint\n\nconfig\n\neSCN-IS2RE-ODAC\n\neSCN\n\ncheckpoint\n\nconfig\n\nEquiformerV2-IS2RE-ODAC\n\nEquiformerV2\n\ncheckpoint\n\nconfig\n\nThe models in the table above were trained to predict relaxed energy directly. Relaxed energies can also be predicted by running structural relaxations using the S2EF models from the previous section.","type":"content","url":"/models-3#is2re-direct-models","position":9},{"hierarchy":{"lvl1":"Pretrained models","lvl3":"IS2RS","lvl2":"ODAC23 Models"},"type":"lvl3","url":"/models-3#is2rs","position":10},{"hierarchy":{"lvl1":"Pretrained models","lvl3":"IS2RS","lvl2":"ODAC23 Models"},"content":"The IS2RS is solved by running structural relaxations using the S2EF models from the prior section.\n\nThe Open DAC 2023 (ODAC23) dataset is licensed under a \n\nCreative Commons Attribution 4.0 License.\n\nPlease consider citing the following paper in any research manuscript using the ODAC23 dataset:@article{odac23_dataset,\n    author = {Anuroop Sriram and Sihoon Choi and Xiaohan Yu and Logan M. Brabson and Abhishek Das and Zachary Ulissi and Matt Uyttendaele and Andrew J. Medford and David S. Sholl},\n    title = {The Open DAC 2023 Dataset and Challenges for Sorbent Discovery in Direct Air Capture},\n    year = {2023},\n    journal={arXiv preprint arXiv:2311.00341},\n}","type":"content","url":"/models-3#is2rs","position":11},{"hierarchy":{"lvl1":"FAIRChem"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"FAIRChem"},"content":"\n\nMachine learning models for materials science and quantum chemistry.\n\nState-of-the-art universal interatomic potentials for molecules, materials, and catalysts — built by the \n\nMeta FAIR Chemistry team.\n\n \n\n \n\npip install fairchem-core\n\nGet Started → \n\nTry the Demo →\n\n","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"FAIRChem","lvl2":"Application Domains"},"type":"lvl2","url":"/#application-domains","position":2},{"hierarchy":{"lvl1":"FAIRChem","lvl2":"Application Domains"},"content":"Heterogeneous Catalysis\n\nSurface reactions, adsorption energies, and catalyst design.\n\nExplore Catalysis →\n\nInorganic Materials\n\nBulk materials, phonons, and elastic properties.\n\nExplore Materials →\n\nMolecules & Polymers\n\nMolecular conformers and electronic properties.\n\nExplore Molecules →\n\nMolecular Crystals\n\nPacked molecular arrangements in crystal structures.\n\nExplore Crystals →\n\nMOFs for Direct Air Capture\n\nMetal-organic frameworks for CO₂ capture.\n\nExplore DAC →\n\n","type":"content","url":"/#application-domains","position":3},{"hierarchy":{"lvl1":"FAIRChem","lvl2":"Get Started"},"type":"lvl2","url":"/#get-started","position":4},{"hierarchy":{"lvl1":"FAIRChem","lvl2":"Get Started"},"content":"📘 Quickstart\n\nBuild your first calculation in minutes\n\nStart now →\n\n📖 UMA Model Guide\n\nLearn about task selection and model inputs\n\nRead guide →\n\n🔧 Installation\n\nSet up FAIRChem and HuggingFace access\n\nInstall →\n\n🎓 Tutorials\n\nHands-on tutorials for common workflows\n\nView tutorials →\n\n📊 Common Tasks\n\nInference, training, fine-tuning, and more\n\nBrowse tasks →\n\n🎬 Technical Talks\n\nVideo presentations from the team\n\nWatch →\n\n","type":"content","url":"/#get-started","position":5},{"hierarchy":{"lvl1":"FAIRChem","lvl2":"The UMA Model"},"type":"lvl2","url":"/#the-uma-model","position":6},{"hierarchy":{"lvl1":"FAIRChem","lvl2":"The UMA Model"},"content":"Read about our latest release: the Universal Machine-learning for Atomistic systems (UMA) model.\n\nMeta FAIR Science Release\n\nUMA is trained on 500M+ DFT calculations across molecules, materials, and catalysts — achieving state-of-the-art accuracy with energy conservation and fast inference.\n\nFAIRChem v2 is here!\n\nFAIRChem v2 introduces the UMA model — a universal machine learning potential for atoms.\nThis is a breaking change from v1 and is not compatible with previous pretrained models.\n\nMigration Guide • \n\nVersion 1 Documentation\n\n","type":"content","url":"/#the-uma-model","position":7},{"hierarchy":{"lvl1":"FAIRChem","lvl2":"Resources"},"type":"lvl2","url":"/#resources","position":8},{"hierarchy":{"lvl1":"FAIRChem","lvl2":"Resources"},"content":"GitHub Repository\n\nBrowse source code, report issues, and contribute\n\nfacebookresearch​/fairchem\n\nPapers Using FAIRChem\n\nSee how researchers are using our models\n\nView publications →\n\nOpen in Codespaces\n\nTry FAIRChem in your browser — no local setup required\n\n\n\nHuggingFace Models\n\nAccess pretrained UMA checkpoints\n\nfacebook/UMA\n\nTerms of Use | \n\nPrivacy Policy","type":"content","url":"/#resources","position":9},{"hierarchy":{"lvl1":"FAQ"},"type":"lvl1","url":"/faq-2","position":0},{"hierarchy":{"lvl1":"FAQ"},"content":"This page will be updated with FAQ questions as we get them. Please feel free to add PRs if there’s questions/explanations that you think others would find helpful!","type":"content","url":"/faq-2","position":1},{"hierarchy":{"lvl1":"OMat24"},"type":"lvl1","url":"/omat24","position":0},{"hierarchy":{"lvl1":"OMat24"},"content":"Dataset Overview\n\nProperty\n\nValue\n\nSize\n\n1.07M structures (train) + 1.02M (val)\n\nDomain\n\nInorganic bulk materials\n\nLabels\n\nTotal energy (eV), forces (eV/A), stress (eV/A^3)\n\nLevel of Theory\n\nDFT (PBE/PBE+U)\n\nLicense\n\nCC BY 4.0\n\nBenchmark\n\nMatbench-Discovery compatible\n\nThe Open Materials 2024 (OMat24) dataset contains a mix of single point calculations of non-equilibrium structures and\nstructural relaxations. The dataset contains structures labeled with total energy (eV), forces (eV/A)\nand stress (eV/A^3). The dataset is provided in ASE DB compatible lmdb files.\n\nThe OMat24 train and val splits are fully compatible with the Matbench-Discovery benchmark test set.\n\nThe splits do not contain any structure that has a protostructure label present in the initial or relaxed\nstructures of the WBM dataset.\n\nThe splits do not include any structure that was generated starting from an Alexandria relaxed structure with\nprotostructure lable in the intitial or relaxed structures of the  WBM datset.","type":"content","url":"/omat24","position":1},{"hierarchy":{"lvl1":"OMat24","lvl2":"Subdatasets"},"type":"lvl2","url":"/omat24#subdatasets","position":2},{"hierarchy":{"lvl1":"OMat24","lvl2":"Subdatasets"},"content":"OMat24 is made up of X subdatasets based on how the structures were generated. The subdatasets included are:\n\nrattled-1000-subsampled & rattled-1000\n\nrattled-500-subsampled & rattled-300\n\nrattled-300-subsampled & rattled-500\n\naimd-from-PBE-1000-npt\n\naimd-from-PBE-1000-nvt\n\naimd-from-PBE-3000-npt\n\naimd-from-PBE-3000-nvt\n\nrattled-relax\n\nNote There are two subdatasets for the rattled-< T > datasets. Both subdatasets in each pair were generated with the\nsame procedure as described in our manuscript.","type":"content","url":"/omat24#subdatasets","position":3},{"hierarchy":{"lvl1":"OMat24","lvl2":"File contents and downloads"},"type":"lvl2","url":"/omat24#file-contents-and-downloads","position":4},{"hierarchy":{"lvl1":"OMat24","lvl2":"File contents and downloads"},"content":"","type":"content","url":"/omat24#file-contents-and-downloads","position":5},{"hierarchy":{"lvl1":"OMat24","lvl3":"OMat24 train split","lvl2":"File contents and downloads"},"type":"lvl3","url":"/omat24#omat24-train-split","position":6},{"hierarchy":{"lvl1":"OMat24","lvl3":"OMat24 train split","lvl2":"File contents and downloads"},"content":"Sub-dataset\n\nNo. structures\n\nFile size\n\nDownload\n\nrattled-1000\n\n122,937\n\n21 GB\n\nrattled-1000.tar.gz\n\nrattled-1000-subsampled\n\n41,786\n\n7.1 GB\n\nrattled​-1000​-subsampled​.tar​.gz\n\nrattled-500\n\n75,167\n\n13 GB\n\nrattled-500.tar.gz\n\nrattled-500-subsampled\n\n43,068\n\n7.3 GB\n\nrattled​-500​-subsampled​.tar​.gz\n\nrattled-300\n\n68,593\n\n12 GB\n\nrattled-300.tar.gz\n\nrattled-300-subsampled\n\n37,393\n\n6.4 GB\n\nrattled​-300​-subsampled​.tar​.gz\n\naimd-from-PBE-1000-npt\n\n223,574\n\n26 GB\n\naimd​-from​-PBE​-1000​-npt​.tar​.gz\n\naimd-from-PBE-1000-nvt\n\n215,589\n\n24 GB\n\naimd​-from​-PBE​-1000​-nvt​.tar​.gz\n\naimd-from-PBE-3000-npt\n\n65,244\n\n25 GB\n\naimd​-from​-PBE​-3000​-npt​.tar​.gz\n\naimd-from-PBE-3000-nvt\n\n84,063\n\n32 GB\n\naimd​-from​-PBE​-3000​-nvt​.tar​.gz\n\nrattled-relax\n\n99,968\n\n12 GB\n\nrattled​-relax​.tar​.gz\n\nTotal\n\n1,077,382\n\n185.8 GB\n\n","type":"content","url":"/omat24#omat24-train-split","position":7},{"hierarchy":{"lvl1":"OMat24","lvl3":"OMat24 val split (this is a 1M subset used to train eqV2 models from the 5M val split)","lvl2":"File contents and downloads"},"type":"lvl3","url":"/omat24#omat24-val-split-this-is-a-1m-subset-used-to-train-eqv2-models-from-the-5m-val-split","position":8},{"hierarchy":{"lvl1":"OMat24","lvl3":"OMat24 val split (this is a 1M subset used to train eqV2 models from the 5M val split)","lvl2":"File contents and downloads"},"content":"NOTE: The original validation sets contained a duplicated structures. Corrected validation sets were uploaded on 20/12/24. Please see this \n\nissue\nfor more details, an re-download the correct version of the validation sets if needed.\n\nSub-dataset\n\nSize\n\nFile Size\n\nDownload\n\nrattled-1000\n\n117,004\n\n218 MB\n\nrattled-1000.tar.gz\n\nrattled-1000-subsampled\n\n39,785\n\n77 MB\n\nrattled​-1000​-subsampled​.tar​.gz\n\nrattled-500\n\n71,522\n\n135 MB\n\nrattled-500.tar.gz\n\nrattled-500-subsampled\n\n41,021\n\n79 MB\n\nrattled​-500​-subsampled​.tar​.gz\n\nrattled-300\n\n65,235\n\n122 MB\n\nrattled-300.tar.gz\n\nrattled-300-subsampled\n\n35,579\n\n69 MB\n\nrattled​-300​-subsampled​.tar​.gz\n\naimd-from-PBE-1000-npt\n\n212,737\n\n261 MB\n\naimd​-from​-PBE​-1000​-npt​.tar​.gz\n\naimd-from-PBE-1000-nvt\n\n205,165\n\n251 MB\n\naimd​-from​-PBE​-1000​-nvt​.tar​.gz\n\naimd-from-PBE-3000-npt\n\n62,130\n\n282 MB\n\naimd​-from​-PBE​-3000​-npt​.tar​.gz\n\naimd-from-PBE-3000-nvt\n\n79,977\n\n364 MB\n\naimd​-from​-PBE​-3000​-nvt​.tar​.gz\n\nrattled-relax\n\n95,206\n\n118 MB\n\nrattled​-relax​.tar​.gz\n\nTotal\n\n1,025,361\n\n1.98 GB\n\n","type":"content","url":"/omat24#omat24-val-split-this-is-a-1m-subset-used-to-train-eqv2-models-from-the-5m-val-split","position":9},{"hierarchy":{"lvl1":"OMat24","lvl3":"sAlex Dataset","lvl2":"File contents and downloads"},"type":"lvl3","url":"/omat24#salex-dataset","position":10},{"hierarchy":{"lvl1":"OMat24","lvl3":"sAlex Dataset","lvl2":"File contents and downloads"},"content":"We also provide the sAlex dataset used for fine-tuning of our OMat models. sAlex is a subsampled, Matbench-Discovery compliant, version of the original \n\nAlexandria.\nsAlex was created by removing structures matched in WBM and only sampling structure along a trajectory with an energy difference greater than 10 meV/atom. For full details,\nplease see the manuscript.\n\nDataset\n\nSplit\n\nNo. Structures\n\nFile Size\n\nDownload\n\nsAlex\n\ntrain\n\n10,447,765\n\n7.6 GB\n\ntrain.tar.gz\n\nsAlex\n\nval\n\n553,218\n\n408 MB\n\nval.tar.gz","type":"content","url":"/omat24#salex-dataset","position":11},{"hierarchy":{"lvl1":"OMat24","lvl2":"Getting ASE atoms objects"},"type":"lvl2","url":"/omat24#getting-ase-atoms-objects","position":12},{"hierarchy":{"lvl1":"OMat24","lvl2":"Getting ASE atoms objects"},"content":"Dataset files are written as AseLMDBDatabase objects which are an implementation of an \n\nASE Database,\nin LMDB format. A single *.aselmdb file can be read and queried like any other ASE DB.\n\nYou can also read many DB files at once and access atoms objects using the AseDBDataset class.\n\nFor example to read the rattled-relax subdataset,from fairchem.core.datasets import AseDBDataset\n\ndataset_path = \"/path/to/omat24/train/rattled-relax\"\nconfig_kwargs = {}  # see tutorial on additiona configuration\n\ndataset = AseDBDataset(config=dict(src=dataset_path, **config_kwargs))\n\n# atoms objects can be retrieved by index\natoms = dataset.get_atoms(0)\n\nTo read more than one subdataset you can simply pass a list of subdataset paths,from fairchem.core.datasets import AseDBDataset\n\nconfig_kwargs = {}  # see tutorial on additiona configuration\ndataset_paths = [\n    \"/path/to/omat24/train/rattled-relax\",\n    \"/path/to/omat24/train/rattled-1000-subsampled\",\n    \"/path/to/omat24/train/rattled-1000\",\n]\ndataset = AseDBDataset(config=dict(src=dataset_paths, **config_kwargs))\n\nTo read all of the OMat24 training or validations splits simply pass the paths to all subdatasets.","type":"content","url":"/omat24#getting-ase-atoms-objects","position":13},{"hierarchy":{"lvl1":"OMat24","lvl3":"Citing OMat24","lvl2":"Getting ASE atoms objects"},"type":"lvl3","url":"/omat24#citing-omat24","position":14},{"hierarchy":{"lvl1":"OMat24","lvl3":"Citing OMat24","lvl2":"Getting ASE atoms objects"},"content":"The OMat24 dataset is licensed under a \n\nCreative Commons Attribution 4.0 License.\n\nPlease consider citing the following paper in any publications that uses this dataset:@article{barroso_omat24,\n  title={Open Materials 2024 (OMat24) Inorganic Materials Dataset and Models},\n  author={Barroso-Luque, Luis and Muhammed, Shuaibi and Fu, Xiang and Wood, Brandon, Dzamba, Misko, and Gao, Meng and Rizvi, Ammar and  Zitnick, C. Lawrence and Ulissi, Zachary W.},\n  journal={arXiv preprint arXiv:2410.12771},\n  year={2024}\n}\n@article{schmidt_2023_machine,\n  title={Machine-Learning-Assisted Determination of the Global Zero-Temperature Phase Diagram of Materials},\n  author={Schmidt, Jonathan and Hoffmann, Noah and Wang, Hai-Chen and Borlido, Pedro and Carri{\\c{c}}o, Pedro JMA and Cerqueira, Tiago FT and Botti, Silvana and Marques, Miguel AL},\n  journal={Advanced Materials},\n  volume={35},\n  number={22},\n  pages={2210788},\n  year={2023},\n  url={https://onlinelibrary.wiley.com/doi/full/10.1002/adma.202210788},\n  publisher={Wiley Online Library}\n}","type":"content","url":"/omat24#citing-omat24","position":15},{"hierarchy":{"lvl1":"Datasets"},"type":"lvl1","url":"/summary-5","position":0},{"hierarchy":{"lvl1":"Datasets"},"content":"\n\nExplore the inorganic materials datasets for training and benchmarking machine learning interatomic potentials.\n\nOMat24\n\nOver 1 million structures from rattled and AIMD calculations for inorganic materials, fully compatible with Matbench-Discovery.","type":"content","url":"/summary-5","position":1},{"hierarchy":{"lvl1":"Elastic Tensors"},"type":"lvl1","url":"/elastic","position":0},{"hierarchy":{"lvl1":"Elastic Tensors"},"content":"What You Will Learn\n\nCalculate elastic constants and bulk modulus using automated strain-based workflows with quacc.\n\nLet’s do something more interesting that normally takes quite a bit of work in DFT: calculating an elastic constant! Elastic properties are important to understand how strong or easy to deform a material is, or how a material might change if compressed or expanded in specific directions (i.e. the Poisson ratio!).\n\nWe don’t have to change much code from above, we just use a built-in recipe to calculate the elastic tensor from quacc. This recipe\n\n(optionally) Relaxes the unit cell using the MLIP\n\nGenerates a number of deformed unit cells by applying strains\n\nFor each deformation, a relaxation using the MLIP and (optionally) a single point calculation is run\n\nFinally, all of the above calculations are used to calculate the elastic properties of the material\n\nFor more documentation, see the quacc docs for \n\nquacc​.recipes​.mlp​.elastic​_tensor​_flow\n\nNeed to install fairchem-core or get UMA access or getting permissions/401 errors?\n\nInstall the necessary packages using pip, uv etc\n\n! pip install fairchem-core fairchem-data-oc fairchem-applications-cattsunami\n\n\n\nGet access to any necessary huggingface gated models\n\nGet and login to your Huggingface account\n\nRequest access to \n\nhttps://​huggingface​.co​/facebook​/UMA\n\nCreate a Huggingface token at \n\nhttps://​huggingface​.co​/settings​/tokens/ with the permission “Permissions: Read access to contents of all public gated repos you can access”\n\nAdd the token as an environment variable using huggingface-cli login or by setting the HF_TOKEN environment variable.\n\n# Login using the huggingface-cli utility\n! huggingface-cli login\n\n# alternatively,\nimport os\nos.environ['HF_TOKEN'] = 'MY_TOKEN'\n\n\n\nfrom __future__ import annotations\n\nfrom ase.build import bulk\nfrom quacc.recipes.mlp.elastic import elastic_tensor_flow\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Run an elastic property calculation with our favorite MLP potential\nresult = elastic_tensor_flow(\n    atoms,\n    job_params={\n        \"all\": dict(\n            method=\"fairchem\",\n            name_or_path=\"uma-s-1p1\",\n            task_name=\"omat\",\n        ),\n    },\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nresult[\"elasticity_doc\"].bulk_modulus\n\n\n\nCongratulations, you ran your first elastic tensor calculation!","type":"content","url":"/elastic","position":1},{"hierarchy":{"lvl1":"Formation Energy"},"type":"lvl1","url":"/formation-energy","position":0},{"hierarchy":{"lvl1":"Formation Energy"},"content":"What You Will Learn\n\nCalculate formation energies for inorganic materials using UMA with Materials Project-compatible corrections.\n\nWe’re going to start simple here - let’s run a local relaxation (optimize the unit cell and positions) using a pre-trained UMA model to compute formation energies for inorganic materials.\n\nNote predicting formation energy using models that models trained solely on OMat24 must use OMat24 compatible references and corrections for mixing PBE and PBE+U calculations. We use MP2020-style corrections fitted to OMat24 DFT calculations. For more information see the \n\ndocumentation at the Materials Project. The necessary references can be found using the fairchem.data.omat package!\n\nNeed to install fairchem-core or get UMA access or getting permissions/401 errors?\n\nInstall the necessary packages using pip, uv etc\n\n! pip install fairchem-core fairchem-data-omat\n\n\n\nGet access to any necessary huggingface gated models\n\nGet and login to your Huggingface account\n\nRequest access to \n\nhttps://​huggingface​.co​/facebook​/UMA\n\nCreate a Huggingface token at \n\nhttps://​huggingface​.co​/settings​/tokens/ with the permission “Permissions: Read access to contents of all public gated repos you can access”\n\nAdd the token as an environment variable using huggingface-cli login or by setting the HF_TOKEN environment variable.\n\n# Login using the huggingface-cli utility\n! huggingface-cli login\n\n# alternatively,\nimport os\nos.environ['HF_TOKEN'] = 'MY_TOKEN'\n\n\n\nfrom __future__ import annotations\n\nimport pprint\n\nfrom ase.build import bulk\nfrom ase.optimize import FIRE\nfrom quacc.recipes.mlp.core import relax_job\nfrom quacc import flow\nfrom fairchem.core.calculate import FAIRChemCalculator, FormationEnergyCalculator\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Run a structure relaxation\n@flow\ndef relax_flow(*args, **kwargs):\n  return relax_job(*args, **kwargs)\n\nresult = relax_flow(\n    atoms,\n    method=\"fairchem\",\n    name_or_path=\"uma-s-1p1\",\n    task_name=\"omat\",\n    relax_cell=True,\n    opt_params={\"fmax\": 1e-3, \"optimizer\": FIRE},\n)\n\n# Get the realxed atoms!\natoms = result[\"atoms\"]\n\n# Create an calculator using uma-s-1p1\ncalculator = FAIRChemCalculator.from_model_checkpoint(\"uma-s-1p1\", task_name=\"omat\")\n\n# Now use the FormationEnergyCalculator to calculate the formation energy\n# This will now return MP-style corrected formation energies\n# For the omat task, this defaults to apply MP2020 style corrections with OMat24 compatibility\nform_e_calc = FormationEnergyCalculator(calculator, apply_corrections=True)\natoms.calc = form_e_calc\nform_energy = atoms.get_potential_energy()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npprint.pprint(f\"Total energy: {result['results']['energy']} eV \\n Formation energy {form_energy} eV\")\n\n\n\nCompare the results to the value of \n\n-3.038 eV/atom reported in the Materials Project!\nNote that we expect differences due to the different DFT settings used to calculate the OMat24 training data.\n\nCongratulations; you ran your first relaxation and predicted the formation energy of MgO using UMA and quacc!","type":"content","url":"/formation-energy","position":1},{"hierarchy":{"lvl1":"Phonon Calculations"},"type":"lvl1","url":"/phonons","position":0},{"hierarchy":{"lvl1":"Phonon Calculations"},"content":"What You Will Learn\n\nRun phonon calculations to predict thermal conductivity, vibrational modes, entropy, and finite-temperature stability.\n\nPhonon calculations are very important for inorganic materials science to\n\nCalculate thermal conductivity\n\nUnderstand the vibrational modes, and thus entropy and free energy, of a material\n\nPredict the stability of a material at finite temperature (e.g. 300 K)\namong many others!\nWe can run a similarly straightforward calculation that\n\nRuns a relaxation on the unit cell and atoms\n\nRepeats the unit cell a number of times to make it sufficiently large to capture many interesting vibrational models\n\nGeneratives a number of finite displacement structures by moving each atom of the unit cell a little bit in each direction\n\nRunning single point calculations on each of (3)\n\nGathering all of the calculations and calculating second derivatives (the hessian matrix!)\n\nCalculating the eigenvalues/eigenvectors of the hessian matrix to find the vibrational modes of the material\n\nAnalyzing the thermodynamic properties of the vibrational modes.\n\nNote that this analysis assumes that all vibrational modes are harmonic, which is a pretty reasonable approximately for low/moderate temperature materials, but becomes less realistic at high temperatures.\n\nfrom __future__ import annotations\n\nfrom ase.build import bulk\nfrom quacc.recipes.mlp.phonons import phonon_flow\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Run a phonon (hessian) calculation with our favorite MLP potential\nresult = phonon_flow(\n    atoms,\n    method=\"fairchem\",\n    job_params={\n        \"all\": dict(\n            name_or_path=\"uma-s-1p1\",\n            task_name=\"omat\",\n        ),\n    },\n    min_lengths=10.0,  # set the minimum unit cell size smaller to be compatible with limited github runner ram\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprint(\n    f'The entropy at { result[\"results\"][\"thermal_properties\"][\"temperatures\"][-1]:.0f} K is { result[\"results\"][\"thermal_properties\"][\"entropy\"][-1]:.2f} kJ/mol'\n)\n\n\n\nCongratulations, you ran your first phonon calculation!\n\nNeed to install fairchem-core or get UMA access or getting permissions/401 errors?\n\nInstall the necessary packages using pip, uv etc\n\n! pip install fairchem-core fairchem-data-oc fairchem-applications-cattsunami\n\n\n\nGet access to any necessary huggingface gated models\n\nGet and login to your Huggingface account\n\nRequest access to \n\nhttps://​huggingface​.co​/facebook​/UMA\n\nCreate a Huggingface token at \n\nhttps://​huggingface​.co​/settings​/tokens/ with the permission “Permissions: Read access to contents of all public gated repos you can access”\n\nAdd the token as an environment variable using huggingface-cli login or by setting the HF_TOKEN environment variable.\n\n# Login using the huggingface-cli utility\n! huggingface-cli login\n\n# alternatively,\nimport os\nos.environ['HF_TOKEN'] = 'MY_TOKEN'\n\n","type":"content","url":"/phonons","position":1},{"hierarchy":{"lvl1":"Examples & Tutorials"},"type":"lvl1","url":"/summary-6","position":0},{"hierarchy":{"lvl1":"Examples & Tutorials"},"content":"\n\nLearn how to use FAIRChem models for inorganic materials property prediction and simulation.\n\nFormation Energy\n\nCalculate formation energies for inorganic materials using UMA and MP-compatible corrections.\n\nPhonons\n\nRun phonon calculations to predict thermal conductivity, vibrational modes, and finite-temperature stability.\n\nElastic Tensors\n\nCalculate elastic constants and bulk modulus using automated strain-based workflows.","type":"content","url":"/summary-6","position":1},{"hierarchy":{"lvl1":"Pretrained models"},"type":"lvl1","url":"/models-2","position":0},{"hierarchy":{"lvl1":"Pretrained models"},"content":"\n\nRecommended Model\n\n2025 recommendation: We suggest using the \n\nUMA model, trained on all of the FAIR chemistry datasets. UMA provides state-of-the-art accuracy, energy conservation, and will continue to receive updates.\n\nThe UMA model has a number of nice features over the previous checkpoints:\n\nIt is state-of-the-art in out-of-domain prediction accuracy\n\nThe UMA small model is an energy conserving and smooth checkpoint, so should work much better for vibrational calculations, molecular dynamics, etc.\n\nThe UMA model is most likely to be updated in the future.","type":"content","url":"/models-2","position":1},{"hierarchy":{"lvl1":"Pretrained models","lvl2":"Legacy OMat pretrained models"},"type":"lvl2","url":"/models-2#legacy-omat-pretrained-models","position":2},{"hierarchy":{"lvl1":"Pretrained models","lvl2":"Legacy OMat pretrained models"},"content":"Note\n\nThese checkpoints are included here for baselining and model reproducibility. For new projects, we recommend using UMA.\n\nAll config files for the OMat24 models are available in the \n\nconfigs/omat24 directory.\n\nAll models are equiformerV2 S2EFS models\n\nNote in order to download any of the model checkpoints from the links below, you will need to first request access\nthrough the \n\nOMAT24 Hugging Face page.\n\nThese checkpoints are trained on OMat24 only. Note that predictions are not Materials Project compatible.\n\nModel Name\n\nCheckpoint\n\nConfig\n\nEquiformerV2-31M-OMat\n\ncheckpoint\n\nconfig\n\nEquiformerV2-86M-OMat\n\ncheckpoint\n\nconfig\n\nEquiformerV2-153M-OMat\n\ncheckpoint\n\nconfig","type":"content","url":"/models-2#legacy-omat-pretrained-models","position":3},{"hierarchy":{"lvl1":"Pretrained models","lvl2":"MPTrj only models"},"type":"lvl2","url":"/models-2#mptrj-only-models","position":4},{"hierarchy":{"lvl1":"Pretrained models","lvl2":"MPTrj only models"},"content":"These models are trained only on the \n\nMPTrj dataset.\n\nModel Name\n\nCheckpoint\n\nConfig\n\nEquiformerV2-31M-MP\n\ncheckpoint\n\nconfig\n\nEquiformerV2-31M-DeNS-MP\n\ncheckpoint\n\nconfig\n\nEquiformerV2-86M-DeNS-MP\n\ncheckpoint\n\nconfig\n\nEquiformerV2-153M-DeNS-MP\n\ncheckpoint\n\nconfig","type":"content","url":"/models-2#mptrj-only-models","position":5},{"hierarchy":{"lvl1":"Pretrained models","lvl2":"Finetuned OMat models"},"type":"lvl2","url":"/models-2#finetuned-omat-models","position":6},{"hierarchy":{"lvl1":"Pretrained models","lvl2":"Finetuned OMat models"},"content":"These models are finetuned from the OMat pretrained checkpoints using MPTrj or MPTrj and sub-sampled trajectories\nfrom the 3D PBE Alexandria dataset, which we call Alex.\n\nModel Name\n\nCheckpoint\n\nConfig\n\nEquiformerV2-31M-OMat-Alex-MP\n\ncheckpoint\n\nconfig\n\nEquiformerV2-86M-OMat-Alex-MP\n\ncheckpoint\n\nconfig\n\nEquiformerV2-153M-OMat-Alex-MP\n\ncheckpoint\n\nconfig\n\nPlease consider citing the following work if you use OMat24 models in your work,@article{barroso-luqueOpenMaterials20242024,\n    title = {Open Materials 2024 (OMat24) Inorganic Materials Dataset and Models},\n    author = {Barroso-Luque, Luis and Shuaibi, Muhammed and Fu, Xiang and Wood, Brandon M. and Dzamba, Misko and Gao, Meng and Rizvi, Ammar and Zitnick, C. Lawrence and Ulissi, Zachary W.},\n    date = {2024-10-16},\n    eprint = {2410.12771},\n    eprinttype = {arXiv},\n    doi = {10.48550/arXiv.2410.12771},\n    url = {http://arxiv.org/abs/2410.12771},\n}","type":"content","url":"/models-2#finetuned-omat-models","position":7},{"hierarchy":{"lvl1":"FAQ"},"type":"lvl1","url":"/faq","position":0},{"hierarchy":{"lvl1":"FAQ"},"content":"This page will be updated with FAQ questions as we get them. Please feel free to add PRs if there’s questions/explanations that you think others would find helpful!","type":"content","url":"/faq","position":1},{"hierarchy":{"lvl1":"OMC25"},"type":"lvl1","url":"/omc25","position":0},{"hierarchy":{"lvl1":"OMC25"},"content":"\n\nDataset Overview\n\nProperty\n\nValue\n\nSize\n\n25+ million structures\n\nDomain\n\nOrganic molecular crystals\n\nLabels\n\nTotal energy (eV), forces (eV/A), stress (eV/A^3)\n\nLevel of Theory\n\nPBE+D3 (VASP)\n\nLicense\n\nCC BY 4.0\n\nDownload\n\nHuggingFace\n\nThe Open Molecular Crystals 2025 (OMC25) dataset comprises >25 million structures of organic molecular crystals from relaxation trajectories of random packings of OE62 molecules into various 3D unit cells using Genarris 3.0 package. The dataset contains structures labeled with total energy (eV), forces (eV/A), and stress (eV/A^3) via VASP.\n\nThe training and validation splits of the OMC25 dataset are available for download from HuggingFace at \n\nhttps://​huggingface​.co​/facebook​/OMC25, under the CC BY 4.0 license, after applying for the repository access on HuggingFace.","type":"content","url":"/omc25","position":1},{"hierarchy":{"lvl1":"OMC25","lvl2":"Dataset format"},"type":"lvl2","url":"/omc25#dataset-format","position":2},{"hierarchy":{"lvl1":"OMC25","lvl2":"Dataset format"},"content":"The dataset is provided in ASE DB compatible lmdb files (*.aselmdb).","type":"content","url":"/omc25#dataset-format","position":3},{"hierarchy":{"lvl1":"OMC25","lvl2":"Level of theory"},"type":"lvl2","url":"/omc25#level-of-theory","position":4},{"hierarchy":{"lvl1":"OMC25","lvl2":"Level of theory"},"content":"OMC25 was calculated at the PBE+D3 level via VASP. To reproduce the calculations, please use fairchem.data.omc.scripts.create_vasp_inputs.py to write compatible VASP inputs.","type":"content","url":"/omc25#level-of-theory","position":5},{"hierarchy":{"lvl1":"OMC25","lvl2":"Citing"},"type":"lvl2","url":"/omc25#citing","position":6},{"hierarchy":{"lvl1":"OMC25","lvl2":"Citing"},"content":"We encourage users to cite this paper when using the OMC25 dataset or pretrained models for molecular crystals in their research.@misc{gharakhanyan2025openmolecularcrystals2025omc25dataset,\n      title={Open Molecular Crystals 2025 (OMC25) Dataset and Models},\n      author={Vahe Gharakhanyan and Luis Barroso-Luque and Yi Yang and Muhammed Shuaibi and Kyle Michel and Daniel S. Levine and Misko Dzamba and Xiang Fu and Meng Gao and Xingyu Liu and Haoran Ni and Keian Noori and Brandon M. Wood and Matt Uyttendaele and Arman Boromand and C. Lawrence Zitnick and Noa Marom and Zachary W. Ulissi and Anuroop Sriram},\n      year={2025},\n      eprint={2508.02651},\n      archivePrefix={arXiv},\n      primaryClass={physics.chem-ph},\n      url={https://arxiv.org/abs/2508.02651},\n}","type":"content","url":"/omc25#citing","position":7},{"hierarchy":{"lvl1":"OMol25"},"type":"lvl1","url":"/omol25","position":0},{"hierarchy":{"lvl1":"OMol25"},"content":"Dataset Overview\n\nProperty\n\nValue\n\nSize\n\n100+ million DFT calculations\n\nDomain\n\nOrganic/inorganic molecules, transition metal complexes, electrolytes\n\nLabels\n\nTotal energy (eV), forces (eV/A)\n\nLevel of Theory\n\nwB97M-V/def2-TZVPD (ORCA6)\n\nLicense\n\nCC BY 4.0\n\nDownload\n\nHuggingFace\n\nThe Open Molecules 2025 (OMol25) dataset contains over 100 million single point calculations of non-equilibrium structures and\nstructural relaxations across a wide swath of organic and inorganic molecular space, including things like transition metal complexes and electrolytes. The dataset contains structures labeled with total energy (eV) and forces (eV/A) via ORCA6. A much larger amount of electronic structure data were also stored during generation and we hope to make these available to the community (reach out via github issue).\n\nAll information about the dataset is available at the \n\nOMol25 HuggingFace site. If you have issues with the gated model request form, please reach out via a github issue on this repository.","type":"content","url":"/omol25","position":1},{"hierarchy":{"lvl1":"OMol25","lvl2":"Dataset format"},"type":"lvl2","url":"/omol25#dataset-format","position":2},{"hierarchy":{"lvl1":"OMol25","lvl2":"Dataset format"},"content":"The dataset is provided in ASE DB compatible lmdb files (*.aselmdb). The dataset contains labels of the total charge and spin multiplicity, saved in the atoms.info dictionary because ASE does not support these as default properties.","type":"content","url":"/omol25#dataset-format","position":3},{"hierarchy":{"lvl1":"OMol25","lvl2":"Level of theory"},"type":"lvl2","url":"/omol25#level-of-theory","position":4},{"hierarchy":{"lvl1":"OMol25","lvl2":"Level of theory"},"content":"OMol25 was calculated at the wB97M-V/def2-TZVPD level, including non-local dispersion, as defined in ORCA6. To reproduce the calculations, please fairchem.data.omol.orca.calc to write compatible ORCA inputs.","type":"content","url":"/omol25#level-of-theory","position":5},{"hierarchy":{"lvl1":"OMol25","lvl3":"Citing OMol25","lvl2":"Level of theory"},"type":"lvl3","url":"/omol25#citing-omol25","position":6},{"hierarchy":{"lvl1":"OMol25","lvl3":"Citing OMol25","lvl2":"Level of theory"},"content":"The OMol25 dataset is licensed under a \n\nCreative Commons Attribution 4.0 License.\n\nPlease consider citing the following paper in any publications that uses this dataset:@misc{levine2025openmolecules2025omol25,\n      title={The Open Molecules 2025 (OMol25) Dataset, Evaluations, and Models}, \n      author={Daniel S. Levine and Muhammed Shuaibi and Evan Walter Clark Spotte-Smith and Michael G. Taylor and Muhammad R. Hasyim and Kyle Michel and Ilyes Batatia and Gábor Csányi and Misko Dzamba and Peter Eastman and Nathan C. Frey and Xiang Fu and Vahe Gharakhanyan and Aditi S. Krishnapriyan and Joshua A. Rackers and Sanjeev Raja and Ammar Rizvi and Andrew S. Rosen and Zachary Ulissi and Santiago Vargas and C. Lawrence Zitnick and Samuel M. Blau and Brandon M. Wood},\n      year={2025},\n      eprint={2505.08762},\n      archivePrefix={arXiv},\n      primaryClass={physics.chem-ph},\n      url={https://arxiv.org/abs/2505.08762}, \n}","type":"content","url":"/omol25#citing-omol25","position":7},{"hierarchy":{"lvl1":"OMol25 Electronic Structures"},"type":"lvl1","url":"/omol25-elec","position":0},{"hierarchy":{"lvl1":"OMol25 Electronic Structures"},"content":"Dataset Overview\n\nProperty\n\nValue\n\nSize\n\n4M subset (full dataset available on request)\n\nContents\n\nORCA outputs, GBW files, density matrices\n\nDomains\n\nSmall molecules, biomolecules, metal complexes, electrolytes\n\nLevel of Theory\n\nwB97M-V/def2-TZVPD\n\nAccess\n\nArgonne National Laboratory via Globus\n\nThe Open Molecules 2025 (OMol25) dataset represents the largest dataset of its kind, with more than 100 million density functional theory (DFT) calculations at the wB97M-V/def2-TZVPD level of theory, spanning several chemical domains including small molecules, biomolecules, metal complexes, and electrolytes.\n\nAt release, the OMol25 dataset provided structure energies, per-atom forces, and Lowdin/Mulliken charges and spins, where available. These properties were sufficient to train state-of-the-art machine learning interatomic potentials (MLIPs) and are already demonstrating incredible performance across a wide range of applications. However, to maximize the community benefit of these calculations, we have partnered with the \n\nDepartment of Energy’s Argonne National Laboratory to provide access to the raw DFT outputs and additional files for the OMol25 dataset.\n\nBy releasing the \n\nORCA output files, users will be able to parse NBO orbital/bonding information, reduced orbital populations, Fock matrices, and more. By releasing the ORCA GBW files, users will be able to run electronic structure post-processing in order to obtain higher quality partial charges and partial spins and a variety of more advanced electronic features that could be extremely valuable for physics-informed ML models. Finally, the release will provide critical high quality data for nascent ML models that train directly on electron densities.","type":"content","url":"/omol25-elec","position":1},{"hierarchy":{"lvl1":"OMol25 Electronic Structures","lvl2":"Data Description"},"type":"lvl2","url":"/omol25-elec#data-description","position":2},{"hierarchy":{"lvl1":"OMol25 Electronic Structures","lvl2":"Data Description"},"content":"The OMol25 dataset is broken into several training splits - All and 4M. The 4M split corresponds to a randomly sampled 4M subset of the full OMol25 dataset. Given the size of the full dataset, O(petabytes), we are first releasing all electronic structure and ORCA output data for the 4M split. Based on community interest, we will work to provide the full dataset.\n\nFor each calculation, the following data is available:\n\norca.tar.zst: Bundle of the raw \n\nORCA outputs - including (orca.out, orca.inp orca.engrad, orca_property.txt, \n\norca.xyz). To open:>> tar --zstd -xvf orca.tar.zst\norca.engrad\norca.inp\norca.inp.orig\norca.out\norca.xyz\norca_property.txt\norca_stderr\n\norca.gbw.zstd0: Geometry-Basis-Wavefunction file - containing molecular orbitals and wavefunction information for the converged SCF.>> zstd -d orca.gbw.zstd0 -o orca.gbw\norca.gbw.zstd0      : 9462880 bytes\n\ndensity_mat.npz: The upper-triangle of the density matrix (“orca.scfp”) (two in the case of unrestricted systems with the addition of the spin density (“orca.scfr”)). This vectorized form of the density can be inflated into a symmetric matrix with the following code:import numpy as np\n\n# Load the NPZ file\nwith np.load('density_mat.npz') as loaded_data:\n    dens_vector = loaded_data['orca.scfp']\n\n# Re-inflate the symmetric matrix\nn = (np.sqrt(8 * len(dens_vector) + 1) - 1) // 2\nmat = np.zeros((n,n))\nmat[np.triu_indices(n)] = dens_vector\nmat = mat + mat.T - np.diag(mat.diagonal())\n\nThe dataset is organized on the Argonne cluster based on how we organized it internally for generation. The easiest way to find systems that you may be interested in is by using the ASE-DB format of the dataset that can be downloaded at \n\ntrain_4M.tar.gz:# pip install fairchem-core if not already installed\nfrom fairchem.core.datasets import AseDBDataset\n\ndataset = AseDBDataset({\"src\": \"path/to/train_4M/\"})\nindices = range(len(dataset))\n\nargonne_paths = []\nfor idx in indices:\n    # ASE Atoms object that can be visualized/examined\n    atoms = dataset.get_atoms(idx)\n    # Check if this is a system you care about.\n    is_relevant = is_atoms_object_relevant(atoms)\n    if is_relevant:\n\t# Extract the relative path that matches the Argonne cluster\n       relative_dir = os.path.dirname(atoms.info[\"source\"])\n\targonne_paths.append(relative_dir)","type":"content","url":"/omol25-elec#data-description","position":3},{"hierarchy":{"lvl1":"OMol25 Electronic Structures","lvl2":"How to Access the Data"},"type":"lvl2","url":"/omol25-elec#how-to-access-the-data","position":4},{"hierarchy":{"lvl1":"OMol25 Electronic Structures","lvl2":"How to Access the Data"},"content":"The data are stored and accessible via storage on the Eagle cluster at Argonne National Laboratory. For free access to the data, you will need to do the following:\n\nFollow the access instructions here: \n\nOMol25 Electronic Structure Spotlight Dataset. After group approval (this step requires human validation, so may take some time), you will be able to access the data via the same page.\n\nTo download the data, you can access via HTTPS calls (slower) or by downloading the \n\nGlobus Connect Personal client (preferred method) and creating a local endpoint.","type":"content","url":"/omol25-elec#how-to-access-the-data","position":5},{"hierarchy":{"lvl1":"OMol25 Electronic Structures","lvl2":"Contact Us"},"type":"lvl2","url":"/omol25-elec#contact-us","position":6},{"hierarchy":{"lvl1":"OMol25 Electronic Structures","lvl2":"Contact Us"},"content":"General Issues\n\nDataset questions?\n\nMuhammed Shuaibi\n\nDaniel Levine\n\nCluster/Access questions?\n\nBen Blaiszik","type":"content","url":"/omol25-elec#contact-us","position":7},{"hierarchy":{"lvl1":"Datasets"},"type":"lvl1","url":"/summary-2","position":0},{"hierarchy":{"lvl1":"Datasets"},"content":"\n\nExplore the molecular datasets available for training and benchmarking machine learning interatomic potentials.\n\nOMol25\n\nOver 100 million DFT calculations of organic and inorganic molecules including transition metal complexes and electrolytes.\n\nOMol25 Electronic Structures\n\nRaw ORCA outputs, GBW files, and density matrices from the OMol25 calculations for advanced electronic structure analysis.\n\nOMC25\n\n25+ million structures of organic molecular crystals from relaxation trajectories.","type":"content","url":"/summary-2","position":1},{"hierarchy":{"lvl1":"OMol25 Leaderboard"},"type":"lvl1","url":"/leaderboard","position":0},{"hierarchy":{"lvl1":"OMol25 Leaderboard"},"content":"Community Leaderboard\n\nSubmit your model predictions for evaluation on the \n\nfairchem​_leaderboard hosted on HuggingFace.\n\nAs part of the OMol25 release, we present a community leaderboard for researchers to submit their predictions for evaluation - \n\nfairchem​_leaderboard.\nBelow we outline the steps to generate predictions and submit them to the leaderboard.\n\nThe leaderboard is broken into two different sections - “S2EF” and “Evaluations”.\nStructure to Energy and Forces (S2EF) is the most straightforward evaluation for MLIPs - given a structure, how well can you predict the total energy and per-atom forces.\nEvaluations correspond to several chemistry relevant tasks (spin gap, ligand-strain, etc.) introduced in OMol25 to evaluate MLIPs beyond simple energy and force metrics (see the \n\npaper for more details).\n\nThe simplest way to get started is to have an ASE-compatible MLIP calculator that can make energy and force predictions. Input data for the different benchmarks can be downloaded below.","type":"content","url":"/leaderboard","position":1},{"hierarchy":{"lvl1":"OMol25 Leaderboard","lvl2":"Download"},"type":"lvl2","url":"/leaderboard#download","position":2},{"hierarchy":{"lvl1":"OMol25 Leaderboard","lvl2":"Download"},"content":"Benchmarks\n\nURL\n\nS2EF (Val/Test)\n\nHuggingFace Dataset Splits\n\nEvaluations\n\nHuggingFace Evaluation Data","type":"content","url":"/leaderboard#download","position":3},{"hierarchy":{"lvl1":"OMol25 Leaderboard","lvl2":"Install the necessary packages"},"type":"lvl2","url":"/leaderboard#install-the-necessary-packages","position":4},{"hierarchy":{"lvl1":"OMol25 Leaderboard","lvl2":"Install the necessary packages"},"content":"pip install \"fairchem-core>=2.5.0\"\npip install \"fairchem-data-omol>=0.1.1\"","type":"content","url":"/leaderboard#install-the-necessary-packages","position":5},{"hierarchy":{"lvl1":"OMol25 Leaderboard","lvl2":"S2EF"},"type":"lvl2","url":"/leaderboard#s2ef","position":6},{"hierarchy":{"lvl1":"OMol25 Leaderboard","lvl2":"S2EF"},"content":"The leadebroard supports S2EF evaluations for both the OMol25 “Validation” and “Test” sets. Validation labels are already accessible in the released dataset for local benchmarking and debugging, so we highly encourage users to make Test submissions to fairly and accurately compare models. The size of each split is as follows:\n\nSplit\n\nSize\n\nVal\n\n2,762,021\n\nTest\n\n2,805,046\n\nPredictions must be saved as “.npz” files and shall contain the following information:ids <class 'numpy.ndarray'>\nenergy <class 'numpy.ndarray'>\nforces <class 'numpy.ndarray'>\nnatoms <class 'numpy.ndarray'>\n\nWhere,\n\nids corresponds to the unique identifier, atoms.info[\"source\"]\n\nenergy is the predicted energy\n\nforces is the predicted forces, concatenated across all systems\n\nnatoms is the number of atoms corresponding to each prediction\n\nAs an example:from fairchem.core.datasets import AseDBDataset\nfrom fairchem.core import pretrained_mlip, FAIRChemCalculator\n\n### Define your MLIP calculator\npredictor = pretrained_mlip.get_predict_unit(args.checkpoint, device=\"cuda\")\ncalc = FAIRChemCalculator(predictor, task_name=\"omol\")\n\n### Read in the dataset you wish to submit predictions to\ndataset = AseDBDataset({\"src\": \"path/to/omol/test_data\"})\n\nids = []\nenergy = []\nforces = []\nnatoms = []\nfor idx in range(len(dataset)):\n    atoms = dataset.get_atoms(idx)\n    atoms.calc = calc\n    ids.append(atoms.info[\"source\"])\n    natoms.append(len(atoms))\n    energy.append(atoms.get_potential_energy())\n    forces.append(atoms.get_forces())\n\n### Do not forget this! Your submission will fail.\nforces = np.concatenate(forces)\n\nnp.savez_compressed(\n    \"test_predictions.npz\",\n    ids=ids,\n    energy=energy,\n    forces=forces,\n    natoms=natoms,\n)\n\nWarning\n\nThe above example can be very slow on a single GPU and we encourage users to parallelize this however they like. We provide the example as a means to understand the expected format for the leaderboard.\n\nOnce a prediction file is generated, proceed to the leaderboard, fill in the submission form, upload your file, select “Validation” or “Test” and hit submit. Stay on the page until you see the success message.","type":"content","url":"/leaderboard#s2ef","position":7},{"hierarchy":{"lvl1":"OMol25 Leaderboard","lvl2":"Evaluations"},"type":"lvl2","url":"/leaderboard#evaluations","position":8},{"hierarchy":{"lvl1":"OMol25 Leaderboard","lvl2":"Evaluations"},"content":"The following evaluations are currently available on the OMol25 leaderboard:\n\nLigand pocket: Protein-ligand interaction energy as a proxy to the binding energy, central to many biological processes.\n\nLigand strain: Ligand-strain energy is an important task to understanding protein-ligand binding.\n\nConformers: Identifying the lowest energy conformer is a crucial part of many biological and pharmaceutical tasks.\n\nProtonation: As a proxy to pKa prediction, we evaluate energy differences of structures differing by one proton.\n\nDistance scaling: Short range and long range intermolecular interactions are essential for observable properties like phase changes, density, etc.\n\nIE/EA: The addition, removal, and transfer of electrons is central to many redox processes.\n\nSpin gap: Differences between spin states can play a critical role of molecular optic devices and photactive catalysts.\n\nFor a detailed descripion of each task we refer people to the original \n\nmanuscript.\n\nTo generate prediction files for the different tasks, we have released a set of \n\nrecipes to be used with ASE-compatible calculators.\nEach evaluation task has its own unique structure, a detailed description of the expected output is provided in the recipe docstrings. The following recipes should be used to evaluate the corresponding task:\n\nLigand pocket\n\nLigand strain\n\nConformers\n\nProtonation\n\nDistance scaling\n\nIE/EA\n\nSpin gap\n\nAs an example, to run the ligand_pocket evaluation:import json\nimport pickle\nfrom fairchem.core import pretrained_mlip, FAIRChemCalculator\nfrom fairchem.core.components.calculate.recipes.omol import ligand_pocket\n\n### Define your MLIP calculator\npredictor = pretrained_mlip.get_predict_unit(args.checkpoint, device=\"cuda\")\ncalc = FAIRChemCalculator(predictor, task_name=\"omol\")\n\n### Load the desired evaluation task input data\nwith open(\"path/to/ligand_pocket_inputs.pkl\", \"rb\") as f:\n    ligand_pocket_data = pickle.load(f)\n\nresults = ligand_pocket(ligand_pocket_data, calc)\nwith open(\"ligand_pocket_results.json\") as f:\n    json.dump(results, f)\n\nWarning\n\nConformers, Protonation, Ligand strain, and Distance scaling can be quite slow on a single GPU and we encourage users to parallelize this however they like.\n\nOnce a prediction file is generated, proceed to the leaderboard, fill in the submission form, upload your file, select the corresponding evaluation task and hit submit. Stay on the page until you see the success message.","type":"content","url":"/leaderboard#evaluations","position":9},{"hierarchy":{"lvl1":"Pretrained models"},"type":"lvl1","url":"/models","position":0},{"hierarchy":{"lvl1":"Pretrained models"},"content":"\n\nRecommended Model\n\n2025 recommendation: We suggest using the \n\nUMA model, trained on all of the FAIR chemistry datasets. UMA provides state-of-the-art accuracy, energy conservation, and will continue to receive updates.\n\nThe UMA model has a number of nice features over the previous checkpoints:\n\nIt is state-of-the-art in out-of-domain prediction accuracy\n\nThe UMA small model is an energy conserving and smooth checkpoint, so should work much better for vibrational calculations, molecular dynamics, etc.\n\nThe UMA model is most likely to be updated in the future.","type":"content","url":"/models","position":1},{"hierarchy":{"lvl1":"Pretrained models","lvl2":"Baseline models in the OMol25 paper"},"type":"lvl2","url":"/models#baseline-models-in-the-omol25-paper","position":2},{"hierarchy":{"lvl1":"Pretrained models","lvl2":"Baseline models in the OMol25 paper"},"content":"As part of the OMol25 release, we released two sets of models:\n\n[preferred] UMA models trained on a range of FAIR chemistry datasets, available at \n\nHuggingFace\n\neSEN models trained only on OMol25, available at \n\nHuggingFace\n\nThe UMA models will continue to be updated regularly and we expect those to remain the default and performant option for the forseeable future. The OMol25-only eSEN models are provided mostly as a base-line for models trained only on OMol25.","type":"content","url":"/models#baseline-models-in-the-omol25-paper","position":3},{"hierarchy":{"lvl1":"Pretrained models","lvl2":"Citing"},"type":"lvl2","url":"/models#citing","position":4},{"hierarchy":{"lvl1":"Pretrained models","lvl2":"Citing"},"content":"If you use the OMol25-trained eSEN models, please cite the following paper.@misc{levine2025openmolecules2025omol25,\n      title={The Open Molecules 2025 (OMol25) Dataset, Evaluations, and Models},\n      author={Daniel S. Levine and Muhammed Shuaibi and Evan Walter Clark Spotte-Smith and Michael G. Taylor and Muhammad R. Hasyim and Kyle Michel and Ilyes Batatia and Gábor Csányi and Misko Dzamba and Peter Eastman and Nathan C. Frey and Xiang Fu and Vahe Gharakhanyan and Aditi S. Krishnapriyan and Joshua A. Rackers and Sanjeev Raja and Ammar Rizvi and Andrew S. Rosen and Zachary Ulissi and Santiago Vargas and C. Lawrence Zitnick and Samuel M. Blau and Brandon M. Wood},\n      year={2025},\n      eprint={2505.08762},\n      archivePrefix={arXiv},\n      primaryClass={physics.chem-ph},\n      url={https://arxiv.org/abs/2505.08762},\n}","type":"content","url":"/models#citing","position":5},{"hierarchy":{"lvl1":"Pretrained models","lvl2":"Baseline models in the OMC25 paper"},"type":"lvl2","url":"/models#baseline-models-in-the-omc25-paper","position":6},{"hierarchy":{"lvl1":"Pretrained models","lvl2":"Baseline models in the OMC25 paper"},"content":"As part of the OMC25 release, we released eSEN model trained only on OMC25, available at \n\nHuggingFace. [preferred] UMA models trained on a range of FAIR chemistry datasets are available at \n\nHuggingFace.","type":"content","url":"/models#baseline-models-in-the-omc25-paper","position":7},{"hierarchy":{"lvl1":"Pretrained models","lvl2":"Citing"},"type":"lvl2","url":"/models#citing-1","position":8},{"hierarchy":{"lvl1":"Pretrained models","lvl2":"Citing"},"content":"We encourage users to cite this paper when using the OMC25 dataset or pretrained models for molecular crystals in their research.@misc{gharakhanyan2025openmolecularcrystals2025omc25dataset,\n      title={Open Molecular Crystals 2025 (OMC25) Dataset and Models},\n      author={Vahe Gharakhanyan and Luis Barroso-Luque and Yi Yang and Muhammed Shuaibi and Kyle Michel and Daniel S. Levine and Misko Dzamba and Xiang Fu and Meng Gao and Xingyu Liu and Haoran Ni and Keian Noori and Brandon M. Wood and Matt Uyttendaele and Arman Boromand and C. Lawrence Zitnick and Noa Marom and Zachary W. Ulissi and Anuroop Sriram},\n      year={2025},\n      eprint={2508.02651},\n      archivePrefix={arXiv},\n      primaryClass={physics.chem-ph},\n      url={https://arxiv.org/abs/2508.02651},\n}","type":"content","url":"/models#citing-1","position":9},{"hierarchy":{"lvl1":"Pretrained models","lvl2":"License"},"type":"lvl2","url":"/models#license","position":10},{"hierarchy":{"lvl1":"Pretrained models","lvl2":"License"},"content":"All models require users to agree to the FAIR Chemistry License as part of the HuggingFace model gating process.","type":"content","url":"/models#license","position":11},{"hierarchy":{"lvl1":"UMA Tutorials"},"type":"lvl1","url":"/summary-1","position":0},{"hierarchy":{"lvl1":"UMA Tutorials"},"content":"Learn how to use UMA (Universal Machine-learning for Atomistic systems) models through these hands-on tutorials. UMA provides a unified interface for atomistic simulations across molecules, surfaces, and bulk materials with state-of-the-art accuracy and speed.\n\nUMA Basic Tutorial\n\nLearn the fundamentals of using UMA models for predictions including molecular energies, surface relaxations, molecular dynamics, and phonon calculations.\n\nUMA Catalysis Tutorial\n\nA comprehensive tutorial on applying UMA to heterogeneous catalysis problems, covering bulk optimization, surface energies, Wulff construction, adsorption energies, and reaction barriers.","type":"content","url":"/summary-1","position":1},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial"},"type":"lvl1","url":"/uma-catalysis-tutorial","position":0},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial"},"content":"Author: Zack Ulissi (Meta, CMU), with help from AI coding agents / LLMs\n\nOriginal paper: Bjarne Kreitz et al. JPCC (2021)","type":"content","url":"/uma-catalysis-tutorial","position":1},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl2":"Overview"},"type":"lvl2","url":"/uma-catalysis-tutorial#overview","position":2},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl2":"Overview"},"content":"This tutorial demonstrates how to use the Universal Model for Atoms (UMA) machine learning potential to perform comprehensive catalyst surface analysis. We replicate key computational workflows from \n\n“Microkinetic Modeling of CO₂ Desorption from Supported Multifaceted Ni Catalysts” by Bjarne Kreitz (now faculty at Georgia Tech!), showing how ML potentials can accelerate computational catalysis research.\n\nLearning Objectives\n\nBy the end of this tutorial, you will be able to:\n\nOptimize bulk crystal structures and extract lattice constants\n\nCalculate surface energies using linear extrapolation methods\n\nConstruct Wulff shapes to predict nanoparticle morphologies\n\nCompute adsorption energies with zero-point energy corrections\n\nStudy coverage-dependent binding phenomena\n\nCalculate reaction barriers using the nudged elastic band (NEB) method\n\nApply D3 dispersion corrections to improve accuracy\n\nAbout UMA-S-1P1\n\nThe UMA-S-1P1 model is a state-of-the-art universal machine learning potential trained on the OMat24, OC20, OMol25, ODAC23, and OMC25 datasets, covering diverse materials and surface chemistries. It provides ~1000× speedup over DFT while maintaining reasonable accuracy for screening studies. Here we’ll use the UMA-s-1p1 checkpoint which is the small (=faster) 1.1 version released in June. The UMA-s-1p1 checkpoint is open science with a lightweight license that users have to agree to through Huggingface.\n\nYou can read more about the UMA models here: \n\nhttps://​arxiv​.org​/abs​/2506​.23971","type":"content","url":"/uma-catalysis-tutorial#overview","position":3},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl2":"Installation and Setup"},"type":"lvl2","url":"/uma-catalysis-tutorial#installation-and-setup","position":4},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl2":"Installation and Setup"},"content":"This tutorial uses a number of helpful open source packages:\n\nase - Atomic Simulation Environment\n\nfairchem - FAIR Chemistry ML potentials (formerly OCP)\n\npymatgen - Materials analysis\n\nmatplotlib - Visualization\n\nnumpy - Numerical computing\n\ntorch-dftd - Dispersion corrections\namong many others!","type":"content","url":"/uma-catalysis-tutorial#installation-and-setup","position":5},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Huggingface setups","lvl2":"Installation and Setup"},"type":"lvl3","url":"/uma-catalysis-tutorial#huggingface-setups","position":6},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Huggingface setups","lvl2":"Installation and Setup"},"content":"You need to get a HuggingFace account and request access to the UMA models.\n\nYou need a Huggingface account, request access to \n\nhttps://​huggingface​.co​/facebook​/UMA, and to create a Huggingface token at \n\nhttps://​huggingface​.co​/settings​/tokens/ with these permission:\n\nPermissions: Read access to contents of all public gated repos you can access\n\nThen, add the token as an environment variable using huggingface-cli login:\n\n# Enter token via huggingface-cli\n! huggingface-cli login\n\n\n\nor you can set the token via HF_TOKEN variable:\n\n# Set token via env variable\nimport os\n\nos.environ[\"HF_TOKEN\"] = \"MYTOKEN\"\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#huggingface-setups","position":7},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"FAIR Chemistry (UMA) installation","lvl2":"Installation and Setup"},"type":"lvl3","url":"/uma-catalysis-tutorial#fair-chemistry-uma-installation","position":8},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"FAIR Chemistry (UMA) installation","lvl2":"Installation and Setup"},"content":"It may be enough to use pip install fairchem-core. This gets you the latest version on PyPi (\n\nhttps://​pypi​.org​/project​/fairchem​-core/)\n\nHere we install some sub-packages. This can take 2-5 minutes to run.\n\n! pip install fairchem-core[docs] fairchem-data-oc fairchem-applications-cattsunami x3dase\n\n\n\n# Check that packages are installed\n!pip list | grep fairchem\n\n\n\nimport fairchem.core\n\nfairchem.core.__version__\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#fair-chemistry-uma-installation","position":9},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl2":"Package imports"},"type":"lvl2","url":"/uma-catalysis-tutorial#package-imports","position":10},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl2":"Package imports"},"content":"First, let’s import all necessary libraries and initialize the UMA-S-1P1 predictor:\n\nfrom pathlib import Path\n\nimport ase.io\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom ase import Atoms\nfrom ase.build import bulk\nfrom ase.constraints import FixBondLengths\nfrom ase.io import write\nfrom ase.mep import interpolate\nfrom ase.mep.dyneb import DyNEB\nfrom ase.optimize import FIRE, LBFGS\nfrom ase.vibrations import Vibrations\nfrom ase.visualize import view\nfrom fairchem.core import FAIRChemCalculator, pretrained_mlip\nfrom fairchem.data.oc.core import (\n    Adsorbate,\n    AdsorbateSlabConfig,\n    Bulk,\n    MultipleAdsorbateSlabConfig,\n    Slab,\n)\nfrom pymatgen.analysis.wulff import WulffShape\nfrom pymatgen.core import Lattice, Structure\nfrom pymatgen.core.surface import SlabGenerator\nfrom pymatgen.io.ase import AseAtomsAdaptor\nfrom torch_dftd.torch_dftd3_calculator import TorchDFTD3Calculator\n\n# Set up output directory structure\noutput_dir = Path(\"ni_tutorial_results\")\noutput_dir.mkdir(exist_ok=True)\n\n# Create subdirectories for each part\npart_dirs = {\n    \"part1\": \"part1-bulk-optimization\",\n    \"part2\": \"part2-surface-energies\",\n    \"part3\": \"part3-wulff-construction\",\n    \"part4\": \"part4-h-adsorption\",\n    \"part5\": \"part5-coverage-dependence\",\n    \"part6\": \"part6-co-dissociation\",\n}\n\nfor key, dirname in part_dirs.items():\n    (output_dir / dirname).mkdir(exist_ok=True)\n\n# Create subdirectories for different facets in part2\nfor facet in [\"111\", \"100\", \"110\", \"211\"]:\n    (output_dir / part_dirs[\"part2\"] / f\"ni{facet}\").mkdir(exist_ok=True)\n\n# Initialize the UMA-S-1P1 predictor\nprint(\"\\nLoading UMA-S-1P1 model...\")\npredictor = pretrained_mlip.get_predict_unit(\"uma-s-1p1\")\nprint(\"✓ Model loaded successfully!\")\n\n\n\n\n\n\n\nIt is somewhat time consuming to run this. We’re going to use a small number of bulks for the testing of this documentation, but otherwise run all of the results for the actual documentation.\n\nimport os\n\nfast_docs = os.environ.get(\"FAST_DOCS\", \"false\").lower() == \"true\"\nif fast_docs:\n    num_sites = 2\n    relaxation_steps = 20\nelse:\n    num_sites = 5\n    relaxation_steps = 300\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#package-imports","position":11},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl2":"Part 1: Bulk Crystal Optimization"},"type":"lvl2","url":"/uma-catalysis-tutorial#part-1-bulk-crystal-optimization","position":12},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl2":"Part 1: Bulk Crystal Optimization"},"content":"","type":"content","url":"/uma-catalysis-tutorial#part-1-bulk-crystal-optimization","position":13},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Introduction","lvl2":"Part 1: Bulk Crystal Optimization"},"type":"lvl3","url":"/uma-catalysis-tutorial#introduction","position":14},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Introduction","lvl2":"Part 1: Bulk Crystal Optimization"},"content":"Before studying surfaces, we need to determine the equilibrium lattice constant of bulk Ni. This is crucial because surface energies and adsorbate binding depend strongly on the underlying lattice parameter.","type":"content","url":"/uma-catalysis-tutorial#introduction","position":15},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Theory","lvl2":"Part 1: Bulk Crystal Optimization"},"type":"lvl3","url":"/uma-catalysis-tutorial#theory","position":16},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Theory","lvl2":"Part 1: Bulk Crystal Optimization"},"content":"For FCC metals like Ni, the lattice constant a defines the unit cell size. The experimental value for Ni is a = 3.524 Å at room temperature. We’ll optimize both atomic positions and the cell volume to find the ML potential’s equilibrium structure.\n\n# Create initial FCC Ni structure\na_initial = 3.52  # Å, close to experimental\nni_bulk = bulk(\"Ni\", \"fcc\", a=a_initial, cubic=True)\n\nprint(f\"Initial lattice constant: {a_initial:.2f} Å\")\nprint(f\"Number of atoms: {len(ni_bulk)}\")\n\n# Set up calculator for bulk optimization\ncalc = FAIRChemCalculator(predictor, task_name=\"omat\")\nni_bulk.calc = calc\n\n# Use ExpCellFilter to allow cell relaxation\nfrom ase.filters import ExpCellFilter\n\necf = ExpCellFilter(ni_bulk)\n\n# Optimize with LBFGS\nopt = LBFGS(\n    ecf,\n    trajectory=str(output_dir / part_dirs[\"part1\"] / \"ni_bulk_opt.traj\"),\n    logfile=str(output_dir / part_dirs[\"part1\"] / \"ni_bulk_opt.log\"),\n)\nopt.run(fmax=0.05, steps=relaxation_steps)\n\n# Extract results\ncell = ni_bulk.get_cell()\na_optimized = cell[0, 0]\na_exp = 3.524  # Experimental value\nerror = abs(a_optimized - a_exp) / a_exp * 100\n\nprint(f\"\\n{'='*50}\")\nprint(f\"Experimental lattice constant: {a_exp:.2f} Å\")\nprint(f\"Optimized lattice constant:    {a_optimized:.2f} Å\")\nprint(f\"Relative error:                {error:.2f}%\")\nprint(f\"{'='*50}\")\n\nase.io.write(str(output_dir / part_dirs[\"part1\"] / \"ni_bulk_relaxed.cif\"), ni_bulk)\n\n# Store results for later use\na_opt = a_optimized\n\n\n\n\n\n\n\nMissing UMA access?\n\nDon’t have access to UMA yet? You can still explore this calculation!\n\nDownload example Ni bulk structure and test it in the \n\nUMA demo (no login required) to see how the model predicts properties for bulk Ni.\n\nUnderstanding the Results\n\nUMA-s-1p1 using the omat task name will predict lattice constants at the PBE level of DFT. For metals, PBE typically predicts lattice constants within 1-2% of experimental values.\n\nSmall discrepancies arise from:\n\nTraining data biases (if your structure is far from OMAT24)\n\nTemperature effects (0 K vs room temperature). You can do a quasi-harmonic analysis to include finite temperature effects if desired.\n\nQuantum effects not captured by the underlying DFT/PBE simulations\n\nFor surface calculations, using the ML-optimized lattice constant maintains internal consistency.\n\nComparison with Paper\n\nPaper (Table 1): Ni lattice constant = 3.524 Å (experimental reference)\n\nThe UMA-S-1P1 model with OMAT provides excellent agreement with experiment, as would be expected for the PBE functional for simple BCC Ni. The underlying calculations for OMat24 and the original results cited in the paper should be very similar (both PBE), so the fact that the results are a little closer to experiment than the original results is within the numerical noise of the ML model.\n\nFurther exploration\n\nTry modifying the following parameters and observe the effects:\n\nTask name: The original paper re-relaxed the structures at the RPBE level of theory before continuing. Try that with the UMA-s-1p1 model (using the oc20 task name) and see if it matters here.\n\nInitial guess: Change a_initial to 3.0 or 4.0 Å. Does the optimizer still converge to the same value?\n\nConvergence criterion: Tighten fmax to 0.01 eV/Å. How many more steps are required?\n\nDifferent metals: Replace \"Ni\" with \"Cu\", \"Pd\", or \"Pt\". Compare predicted vs experimental lattice constants.\n\nCell shape: Remove cubic=True and allow the cell to distort. Does FCC remain stable?","type":"content","url":"/uma-catalysis-tutorial#theory","position":17},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl2":"Part 2: Surface Energy Calculations"},"type":"lvl2","url":"/uma-catalysis-tutorial#part-2-surface-energy-calculations","position":18},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl2":"Part 2: Surface Energy Calculations"},"content":"","type":"content","url":"/uma-catalysis-tutorial#part-2-surface-energy-calculations","position":19},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Introduction","lvl2":"Part 2: Surface Energy Calculations"},"type":"lvl3","url":"/uma-catalysis-tutorial#introduction-1","position":20},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Introduction","lvl2":"Part 2: Surface Energy Calculations"},"content":"Surface energy (γ) quantifies the thermodynamic cost of creating a surface. It determines surface stability, morphology, and catalytic activity. We’ll calculate γ for four low-index Ni facets: (111), (100), (110), and (211).","type":"content","url":"/uma-catalysis-tutorial#introduction-1","position":21},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Theory","lvl2":"Part 2: Surface Energy Calculations"},"type":"lvl3","url":"/uma-catalysis-tutorial#theory-1","position":22},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Theory","lvl2":"Part 2: Surface Energy Calculations"},"content":"The surface energy is defined as:\\gamma = \\frac{E_{\\text{slab}} - N \\cdot E_{\\text{bulk}}}{2A}\n\nwhere:\n\nE_{\\text{slab}} = total energy of the slab\n\nN = number of atoms in the slab\n\nE_{\\text{bulk}} = bulk energy per atom\n\nA = surface area\n\nFactor of 2 accounts for two surfaces (top and bottom)\n\nChallenge: Direct calculation suffers from quantum size effects, and if you were doing DFT calculations small numerical errors in the simulation or from the K-point grid sampling can lead to small (but significant) errors in the bulk lattice energy.\n\nSolution: It is fairly common when calculating surface energies to use the bulk energy from a bulk relaxation in the above equation. However, because DFT often has some small numerical noise in the predictions from k-point convergence, this might lead to the wrong surface energy. Instead, two more careful schemes are either:\n\nCalculate the energy of a bulk structure oriented to each slab to maximize cancellation of small numerical errors or\n\nCalculate the energy of multiple slabs at multiple thicknesses and extrapolate to zero thickness. The intercept will be the surface energy, and the slope will be a fitted bulk energy. A benefit of this approach is that it also forces us to check that we have a sufficiently thick slab for a well defined surface energy; if the fit is non-linear we need thicker slabs.\n\nWe’ll use the linear extrapolation method here as it’s more likely to work in future DFT studies if you use this code!","type":"content","url":"/uma-catalysis-tutorial#theory-1","position":23},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 1: Setup and Bulk Energy Reference","lvl2":"Part 2: Surface Energy Calculations"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-1-setup-and-bulk-energy-reference","position":24},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 1: Setup and Bulk Energy Reference","lvl2":"Part 2: Surface Energy Calculations"},"content":"First, we’ll set up the calculation parameters and get the bulk energy reference:\n\n# Calculate surface energies for all facets\nfacets = [(1, 1, 1), (1, 0, 0), (1, 1, 0), (2, 1, 1)]\nsurface_energies = {}\nsurface_energies_SI = {}\nall_fit_data = {}\n\n# Get bulk energy reference (only need to do this once)\nE_bulk_total = ni_bulk.get_potential_energy()\nN_bulk = len(ni_bulk)\nE_bulk_per_atom = E_bulk_total / N_bulk\n\nprint(f\"Bulk energy reference:\")\nprint(f\"  Total energy: {E_bulk_total:.2f} eV\")\nprint(f\"  Number of atoms: {N_bulk}\")\nprint(f\"  Energy per atom: {E_bulk_per_atom:.6f} eV/atom\")\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#step-1-setup-and-bulk-energy-reference","position":25},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 2: Generate and Relax Slabs","lvl2":"Part 2: Surface Energy Calculations"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-2-generate-and-relax-slabs","position":26},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 2: Generate and Relax Slabs","lvl2":"Part 2: Surface Energy Calculations"},"content":"Now we’ll loop through each facet, generating slabs at three different thicknesses:\n\n# Convert bulk to pymatgen structure for slab generation\nadaptor = AseAtomsAdaptor()\nni_structure = adaptor.get_structure(ni_bulk)\n\nfor facet in facets:\n    facet_str = \"\".join(map(str, facet))\n    print(f\"\\n{'='*60}\")\n    print(f\"Calculating Ni({facet_str}) surface energy\")\n    print(f\"{'='*60}\")\n\n    # Calculate for three thicknesses\n    thicknesses = [4, 6, 8]  # layers\n    n_atoms_list = []\n    energies_list = []\n\n    for n_layers in thicknesses:\n        print(f\"\\n  Thickness: {n_layers} layers\")\n\n        # Generate slab\n        slabgen = SlabGenerator(\n            ni_structure,\n            facet,\n            min_slab_size=n_layers * a_opt / np.sqrt(sum([h**2 for h in facet])),\n            min_vacuum_size=10.0,\n            center_slab=True,\n        )\n        pmg_slab = slabgen.get_slabs()[0]\n        slab = adaptor.get_atoms(pmg_slab)\n        slab.center(vacuum=10.0, axis=2)\n\n        print(f\"    Atoms: {len(slab)}\")\n\n        # Relax slab (no constraints - both surfaces free)\n        calc = FAIRChemCalculator(predictor, task_name=\"omat\")\n        slab.calc = calc\n        opt = LBFGS(slab, logfile=None)\n        opt.run(fmax=0.05, steps=relaxation_steps)\n\n        E_slab = slab.get_potential_energy()\n        n_atoms_list.append(len(slab))\n        energies_list.append(E_slab)\n        print(f\"    Energy: {E_slab:.2f} eV\")\n\n    # Linear regression: E_slab = slope * N + intercept\n    coeffs = np.polyfit(n_atoms_list, energies_list, 1)\n    slope = coeffs[0]\n    intercept = coeffs[1]\n\n    # Extract surface energy from intercept\n    cell = slab.get_cell()\n    area = np.linalg.norm(np.cross(cell[0], cell[1]))\n    gamma = intercept / (2 * area)  # eV/Å²\n    gamma_SI = gamma * 16.0218  # J/m²\n\n    print(f\"\\n  Linear fit:\")\n    print(f\"    Slope:     {slope:.6f} eV/atom (cf. bulk {E_bulk_per_atom:.6f})\")\n    print(f\"    Intercept: {intercept:.2f} eV\")\n    print(f\"\\n  Surface energy:\")\n    print(f\"    γ = {gamma:.6f} eV/Å² = {gamma_SI:.2f} J/m²\")\n\n    # Store results and fit data\n    surface_energies[facet] = gamma\n    surface_energies_SI[facet] = gamma_SI\n    all_fit_data[facet] = {\n        \"n_atoms\": n_atoms_list,\n        \"energies\": energies_list,\n        \"slope\": slope,\n        \"intercept\": intercept,\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#step-2-generate-and-relax-slabs","position":27},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 3: Visualize Linear Fits","lvl2":"Part 2: Surface Energy Calculations"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-3-visualize-linear-fits","position":28},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 3: Visualize Linear Fits","lvl2":"Part 2: Surface Energy Calculations"},"content":"Let’s visualize the linear extrapolation for all four facets:\n\n# Visualize linear fits for all facets\nfig, axes = plt.subplots(2, 2, figsize=(12, 10))\naxes = axes.flatten()\n\nfor idx, facet in enumerate(facets):\n    ax = axes[idx]\n    data = all_fit_data[facet]\n\n    # Plot data points\n    ax.scatter(\n        data[\"n_atoms\"],\n        data[\"energies\"],\n        s=100,\n        color=\"steelblue\",\n        marker=\"o\",\n        zorder=3,\n        label=\"Calculated\",\n    )\n\n    # Plot fit line\n    n_range = np.linspace(min(data[\"n_atoms\"]) - 5, max(data[\"n_atoms\"]) + 5, 100)\n    E_fit = data[\"slope\"] * n_range + data[\"intercept\"]\n    ax.plot(\n        n_range,\n        E_fit,\n        \"r--\",\n        linewidth=2,\n        label=f'Fit: {data[\"slope\"]:.2f}N + {data[\"intercept\"]:.2f}',\n    )\n\n    # Formatting\n    facet_str = f\"Ni({facet[0]}{facet[1]}{facet[2]})\"\n    ax.set_xlabel(\"Number of Atoms\", fontsize=11)\n    ax.set_ylabel(\"Slab Energy (eV)\", fontsize=11)\n    ax.set_title(\n        f\"{facet_str}: γ = {surface_energies_SI[facet]:.2f} J/m²\",\n        fontsize=12,\n        fontweight=\"bold\",\n    )\n    ax.legend(fontsize=9)\n    ax.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.savefig(\n    str(output_dir / part_dirs[\"part2\"] / \"surface_energy_fits.png\"),\n    dpi=300,\n    bbox_inches=\"tight\",\n)\nplt.show()\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#step-3-visualize-linear-fits","position":29},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 4: Compare with Literature","lvl2":"Part 2: Surface Energy Calculations"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-4-compare-with-literature","position":30},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 4: Compare with Literature","lvl2":"Part 2: Surface Energy Calculations"},"content":"Finally, let’s compare our calculated surface energies with DFT literature values:\n\nprint(f\"\\n{'='*70}\")\nprint(\"Comparison with DFT Literature (Tran et al., 2016)\")\nprint(f\"{'='*70}\")\nlit_values = {\n    (1, 1, 1): 1.92,\n    (1, 0, 0): 2.21,\n    (1, 1, 0): 2.29,\n    (2, 1, 1): 2.24,\n}  # J/m²\n\nfor facet in facets:\n    facet_str = f\"Ni({facet[0]}{facet[1]}{facet[2]})\"\n    calc = surface_energies_SI[facet]\n    lit = lit_values[facet]\n    diff = abs(calc - lit) / lit * 100\n    print(f\"{facet_str:<10} {calc:>8.2f} J/m²  (Lit: {lit:.2f}, Δ={diff:.1f}%)\")\n\n\n\nMissing UMA access?\n\nDon’t have access to UMA yet? You can still explore this calculation!\n\nDownload example Ni(111) slab structure and test it in the \n\nUMA demo (no login required) to see how the model predicts energies for Ni surfaces.\n\nComparison with Paper (Table 1)\n\nPaper Results (PBE-DFT, Tran et al.):\n\nNi(111): 1.92 J/m²\n\nNi(100): 2.21 J/m²\n\nNi(110): 2.29 J/m²\n\nNi(211): 2.24 J/m²\n\nKey Observations:\n\nEnergy ordering preserved: (111) < (100) < (110) ≈ (211), matching DFT\n\nAbsolute errors: Typically 10-20%, within expected range for ML potentials\n\n(111) most stable: Both methods agree this is the lowest energy surface\n\nPhysical trend correct: Close-packed surfaces have lower energy\n\nWhy differences exist:\n\nTraining data biases in ML model, which has seen mostly periodic bulk structures, not surfaces.\n\nSlab thickness effects (even with extrapolation)\n\nLack of explicit spin polarization in ML model. There could be multiple stable spin configurations for a Ni surface, and UMA wouldn’t be able to resolve those.\n\nCaveat\nBoth methods here use PBE as the underlying functional in DFT. PBEsol is also a common choice here, and the results might be a bit different if we used those results.\n\nBottom line: Surface energy ordering is more reliable than absolute values. Use ML for screening, validate critical cases with DFT.\n\nWhy Linear Extrapolation?\n\nSingle-thickness slabs suffer from:\n\nQuantum confinement: Electronic structure depends on slab thickness\n\nSurface-surface interactions: Bottom and top surfaces couple at small thicknesses\n\nRelaxation artifacts: Atoms at center may not reach bulk-like coordination\n\nLinear extrapolation eliminates these by fitting E_{\\text{slab}}(N) and extracting the asymptotic surface energy.","type":"content","url":"/uma-catalysis-tutorial#step-4-compare-with-literature","position":31},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Explore on Your Own","lvl2":"Part 2: Surface Energy Calculations"},"type":"lvl3","url":"/uma-catalysis-tutorial#explore-on-your-own","position":32},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Explore on Your Own","lvl2":"Part 2: Surface Energy Calculations"},"content":"Thickness convergence: Add 10 and 12 layer calculations. Is the linear fit still valid?\n\nConstraint effects: Fix the bottom 2 layers during relaxation. How does this affect γ?\n\nVacuum size: Vary min_vacuum_size from 8 to 15 Å. When does γ converge?\n\nHigh-index facets: Try (311) or (331) surfaces. Are they more or less stable?\n\nAlternative fitting: Use polynomial (degree 2) instead of linear fit. Does the intercept change?","type":"content","url":"/uma-catalysis-tutorial#explore-on-your-own","position":33},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl2":"Part 3: Wulff Construction"},"type":"lvl2","url":"/uma-catalysis-tutorial#part-3-wulff-construction","position":34},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl2":"Part 3: Wulff Construction"},"content":"","type":"content","url":"/uma-catalysis-tutorial#part-3-wulff-construction","position":35},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Introduction","lvl2":"Part 3: Wulff Construction"},"type":"lvl3","url":"/uma-catalysis-tutorial#introduction-2","position":36},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Introduction","lvl2":"Part 3: Wulff Construction"},"content":"The Wulff construction predicts the equilibrium shape of a crystalline particle by minimizing total surface energy. This determines the morphology of supported catalyst nanoparticles.","type":"content","url":"/uma-catalysis-tutorial#introduction-2","position":37},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Theory","lvl2":"Part 3: Wulff Construction"},"type":"lvl3","url":"/uma-catalysis-tutorial#theory-2","position":38},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Theory","lvl2":"Part 3: Wulff Construction"},"content":"The Wulff theorem states that at equilibrium, the distance from the particle center to a facet is proportional to its surface energy:\\frac{h_i}{\\gamma_i} = \\text{constant}\n\nFacets with lower surface energy have larger areas in the equilibrium shape.","type":"content","url":"/uma-catalysis-tutorial#theory-2","position":39},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 1: Prepare Surface Energies","lvl2":"Part 3: Wulff Construction"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-1-prepare-surface-energies","position":40},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 1: Prepare Surface Energies","lvl2":"Part 3: Wulff Construction"},"content":"We’ll use the surface energies calculated in Part 2 to construct the Wulff shape:\n\nprint(\"\\nConstructing Wulff Shape\")\nprint(\"=\" * 50)\n\n# Use optimized bulk structure\nadaptor = AseAtomsAdaptor()\nni_structure = adaptor.get_structure(ni_bulk)\n\nmiller_list = list(surface_energies_SI.keys())\nenergy_list = [surface_energies_SI[m] for m in miller_list]\n\nprint(f\"Using {len(miller_list)} facets:\")\nfor miller, energy in zip(miller_list, energy_list):\n    print(f\"  {miller}: {energy:.2f} J/m²\")\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#step-1-prepare-surface-energies","position":41},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 2: Generate Wulff Construction","lvl2":"Part 3: Wulff Construction"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-2-generate-wulff-construction","position":42},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 2: Generate Wulff Construction","lvl2":"Part 3: Wulff Construction"},"content":"Now we create the Wulff shape and analyze its properties:\n\n# Create Wulff shape\nwulff = WulffShape(ni_structure.lattice, miller_list, energy_list)\n\n# Print properties\nprint(f\"\\nWulff Shape Properties:\")\nprint(f\"  Volume:          {wulff.volume:.2f} Å³\")\nprint(f\"  Surface area:    {wulff.surface_area:.2f} Å²\")\nprint(f\"  Effective radius: {wulff.effective_radius:.2f} Å\")\nprint(f\"  Weighted γ:      {wulff.weighted_surface_energy:.2f} J/m²\")\n\n# Area fractions\nprint(f\"\\nFacet Area Fractions:\")\narea_frac = wulff.area_fraction_dict\nfor hkl, frac in sorted(area_frac.items(), key=lambda x: x[1], reverse=True):\n    print(f\"  {hkl}: {frac*100:.1f}%\")\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#step-2-generate-wulff-construction","position":43},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 3: Visualize and Compare","lvl2":"Part 3: Wulff Construction"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-3-visualize-and-compare","position":44},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 3: Visualize and Compare","lvl2":"Part 3: Wulff Construction"},"content":"Let’s visualize the Wulff shape and compare with literature:\n\n# Visualize\nfig = wulff.get_plot()\nplt.title(\"Wulff Construction: Ni Nanoparticle\", fontsize=14)\nplt.tight_layout()\nplt.savefig(\n    str(output_dir / part_dirs[\"part3\"] / \"wulff_shape.png\"),\n    dpi=300,\n    bbox_inches=\"tight\",\n)\nplt.show()\n\n# Compare with paper\nprint(f\"\\nComparison with Paper (Table 2):\")\npaper_fractions = {(1, 1, 1): 69.23, (1, 0, 0): 21.10, (1, 1, 0): 5.28, (2, 1, 1): 4.39}\nfor hkl in miller_list:\n    calc_frac = area_frac.get(hkl, 0) * 100\n    paper_frac = paper_fractions.get(hkl, 0)\n    print(f\"  {hkl}: {calc_frac:>6.1f}% (Paper: {paper_frac:.1f}%)\")\n\n\n\n\n\nComparison with Paper (Table 2)\n\nPaper Results (Wulff Construction):\n\nNi(111): 69.23% of surface area\n\nNi(100): 21.10%\n\nNi(110): 5.28%\n\nNi(211): 4.39%\n\nKey Findings:\n\n(111) dominance: Both ML and DFT show >65% of surface is (111) facets\n\nShape prediction: Truncated octahedron with primarily {111} and {100} faces\n\nMinor facets: (110) and (211) have small contributions (<10%)\n\nAgreement: Area fraction ordering matches perfectly with paper\n\nPhysical interpretation:\n\nReal Ni nanoparticles are (111)-terminated octahedra\n\n(100) facets appear at corners/edges as truncations\n\nThis morphology is confirmed experimentally by TEM\n\nExplains why (111) surface chemistry dominates catalysis\n\nImpact on catalysis:\n\nMust study (111) surface for representative results\n\n(100) sites may be important for minority reaction pathways\n\nEdge/corner sites (not captured here) can be highly active\n\nPhysical Interpretation\n\nThe Wulff shape shows:\n\n(111) dominance: Close-packed surface has lowest energy → largest area\n\n(100) presence: Moderate energy → significant area fraction\n\n(110), (211) minor: Higher energy → small or absent\n\nThis predicts that Ni nanoparticles will be predominantly {111}-faceted octahedra with {100} truncations, matching experimental observations.","type":"content","url":"/uma-catalysis-tutorial#step-3-visualize-and-compare","position":45},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Explore on Your Own","lvl2":"Part 3: Wulff Construction"},"type":"lvl3","url":"/uma-catalysis-tutorial#explore-on-your-own-1","position":46},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Explore on Your Own","lvl2":"Part 3: Wulff Construction"},"content":"Particle size effects: How would including edge/corner energies modify the shape?\n\nAnisotropic strain: Apply 2% compressive strain to the lattice. How does the shape change?\n\nTemperature effects: Surface energies decrease with T. Estimate γ(T) and recompute Wulff shape.\n\nAlloy nanoparticles: Replace some Ni with Cu or Au. How would segregation affect the shape?\n\nSupport effects: Some facets interact more strongly with supports. Model this by reducing their γ.","type":"content","url":"/uma-catalysis-tutorial#explore-on-your-own-1","position":47},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl2":"Part 4: H Adsorption Energy with ZPE Correction"},"type":"lvl2","url":"/uma-catalysis-tutorial#part-4-h-adsorption-energy-with-zpe-correction","position":48},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl2":"Part 4: H Adsorption Energy with ZPE Correction"},"content":"","type":"content","url":"/uma-catalysis-tutorial#part-4-h-adsorption-energy-with-zpe-correction","position":49},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Introduction","lvl2":"Part 4: H Adsorption Energy with ZPE Correction"},"type":"lvl3","url":"/uma-catalysis-tutorial#introduction-3","position":50},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Introduction","lvl2":"Part 4: H Adsorption Energy with ZPE Correction"},"content":"Hydrogen adsorption is a fundamental step in many catalytic reactions (hydrogenation, dehydrogenation, etc.). We’ll calculate the binding energy with vibrational zero-point energy (ZPE) corrections.","type":"content","url":"/uma-catalysis-tutorial#introduction-3","position":51},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Theory","lvl2":"Part 4: H Adsorption Energy with ZPE Correction"},"type":"lvl3","url":"/uma-catalysis-tutorial#theory-3","position":52},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Theory","lvl2":"Part 4: H Adsorption Energy with ZPE Correction"},"content":"The adsorption energy is:E_{\\text{ads}} = E(\\text{slab+H}) - E(\\text{slab}) - \\frac{1}{2}E(\\text{H}_2)\n\nZPE correction accounts for quantum vibrational effects:E_{\\text{ads}}^{\\text{ZPE}} = E_{\\text{ads}} + \\text{ZPE}(\\text{H}^*) - \\frac{1}{2}\\text{ZPE}(\\text{H}_2)\n\nThe ZPE correction is calculated by analyzing the vibrational modes of the molecule/adsorbate.","type":"content","url":"/uma-catalysis-tutorial#theory-3","position":53},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 1: Setup and Relax Clean Slab","lvl2":"Part 4: H Adsorption Energy with ZPE Correction"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-1-setup-and-relax-clean-slab","position":54},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 1: Setup and Relax Clean Slab","lvl2":"Part 4: H Adsorption Energy with ZPE Correction"},"content":"First, we create the Ni(111) surface and relax it:\n\n# Create Ni(111) slab\nni_bulk_atoms = bulk(\"Ni\", \"fcc\", a=a_opt, cubic=True)\nni_bulk_obj = Bulk(bulk_atoms=ni_bulk_atoms)\nni_slabs = Slab.from_bulk_get_specific_millers(\n    bulk=ni_bulk_obj, specific_millers=(1, 1, 1)\n)\nni_slab = ni_slabs[0].atoms\n\nprint(f\"   Created {len(ni_slab)} atom slab\")\n\n# Set up calculators\ncalc = FAIRChemCalculator(predictor, task_name=\"oc20\")\nd3_calc = TorchDFTD3Calculator(device=\"cpu\", damping=\"bj\")\nprint(\"   Calculators initialized (ML + D3)\")\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#step-1-setup-and-relax-clean-slab","position":55},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 2: Relax Clean Slab","lvl2":"Part 4: H Adsorption Energy with ZPE Correction"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-2-relax-clean-slab","position":56},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 2: Relax Clean Slab","lvl2":"Part 4: H Adsorption Energy with ZPE Correction"},"content":"Relax the bare Ni(111) surface as our reference:\n\nprint(\"\\n1. Relaxing clean Ni(111) slab...\")\nclean_slab = ni_slab.copy()\nclean_slab.set_pbc([True, True, True])\nclean_slab.calc = calc\n\nopt = LBFGS(\n    clean_slab,\n    trajectory=str(output_dir / part_dirs[\"part4\"] / \"ni111_clean.traj\"),\n    logfile=str(output_dir / part_dirs[\"part4\"] / \"ni111_clean.log\"),\n)\nopt.run(fmax=0.05, steps=relaxation_steps)\n\nE_clean_ml = clean_slab.get_potential_energy()\nclean_slab.calc = d3_calc\nE_clean_d3 = clean_slab.get_potential_energy()\nE_clean = E_clean_ml + E_clean_d3\nprint(f\"   E(clean): {E_clean:.2f} eV (ML: {E_clean_ml:.2f}, D3: {E_clean_d3:.2f})\")\n\n# Save clean slab\nase.io.write(str(output_dir / part_dirs[\"part4\"] / \"ni111_clean.xyz\"), clean_slab)\nprint(\"   ✓ Clean slab relaxed and saved\")\n\n\n\n\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#step-2-relax-clean-slab","position":57},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 3: Generate H Adsorption Sites","lvl2":"Part 4: H Adsorption Energy with ZPE Correction"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-3-generate-h-adsorption-sites","position":58},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 3: Generate H Adsorption Sites","lvl2":"Part 4: H Adsorption Energy with ZPE Correction"},"content":"Use heuristic placement to generate multiple candidate H adsorption sites:\n\nprint(\"\\n2. Generating 5 H adsorption sites...\")\nni_slab_for_ads = ni_slabs[0]\nni_slab_for_ads.atoms = clean_slab.copy()\n\nadsorbate_h = Adsorbate(adsorbate_smiles_from_db=\"*H\")\nads_slab_config = AdsorbateSlabConfig(\n    ni_slab_for_ads,\n    adsorbate_h,\n    mode=\"random_site_heuristic_placement\",\n    num_sites=num_sites,\n)\n\nprint(f\"   Generated {len(ads_slab_config.atoms_list)} initial configurations\")\nprint(\"   These include fcc, hcp, bridge, and top sites\")\n\n\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#step-3-generate-h-adsorption-sites","position":59},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 4: Relax All H Configurations","lvl2":"Part 4: H Adsorption Energy with ZPE Correction"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-4-relax-all-h-configurations","position":60},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 4: Relax All H Configurations","lvl2":"Part 4: H Adsorption Energy with ZPE Correction"},"content":"Relax each configuration and identify the most stable site:\n\nprint(\"\\n3. Relaxing all H adsorption configurations...\")\nh_energies = []\nh_configs = []\nh_d3_energies = []\n\nfor idx, config in enumerate(ads_slab_config.atoms_list):\n    config_relaxed = config.copy()\n    config_relaxed.set_pbc([True, True, True])\n    config_relaxed.calc = calc\n\n    opt = LBFGS(\n        config_relaxed,\n        trajectory=str(output_dir / part_dirs[\"part4\"] / f\"h_site_{idx+1}.traj\"),\n        logfile=str(output_dir / part_dirs[\"part4\"] / f\"h_site_{idx+1}.log\"),\n    )\n    opt.run(fmax=0.05, steps=relaxation_steps)\n\n    E_ml = config_relaxed.get_potential_energy()\n    config_relaxed.calc = d3_calc\n    E_d3 = config_relaxed.get_potential_energy()\n    E_total = E_ml + E_d3\n\n    h_energies.append(E_total)\n    h_configs.append(config_relaxed)\n    h_d3_energies.append(E_d3)\n    print(f\"   Config {idx+1}: {E_total:.2f} eV (ML: {E_ml:.2f}, D3: {E_d3:.2f})\")\n\n    # Save structure\n    ase.io.write(\n        str(output_dir / part_dirs[\"part4\"] / f\"h_site_{idx+1}.xyz\"), config_relaxed\n    )\n\n# Select best configuration\nbest_idx = np.argmin(h_energies)\nslab_with_h = h_configs[best_idx]\nE_with_h = h_energies[best_idx]\nE_with_h_d3 = h_d3_energies[best_idx]\n\nprint(f\"\\n   ✓ Best site: Config {best_idx+1}, E = {E_with_h:.2f} eV\")\nprint(f\"   Energy spread: {max(h_energies) - min(h_energies):.2f} eV\")\nprint(f\"   This spread indicates the importance of testing multiple sites!\")\n\n\n\n\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#step-4-relax-all-h-configurations","position":61},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 5: Calculate H₂ Reference Energy","lvl2":"Part 4: H Adsorption Energy with ZPE Correction"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-5-calculate-h-reference-energy","position":62},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 5: Calculate H₂ Reference Energy","lvl2":"Part 4: H Adsorption Energy with ZPE Correction"},"content":"We need the H₂ molecule energy as a reference:\n\nprint(\"\\n4. Calculating H₂ reference energy...\")\nh2 = Atoms(\"H2\", positions=[[0, 0, 0], [0, 0, 0.74]])\nh2.center(vacuum=10.0)\nh2.set_pbc([True, True, True])\nh2.calc = calc\n\nopt = LBFGS(\n    h2,\n    trajectory=str(output_dir / part_dirs[\"part4\"] / \"h2.traj\"),\n    logfile=str(output_dir / part_dirs[\"part4\"] / \"h2.log\"),\n)\nopt.run(fmax=0.05, steps=relaxation_steps)\n\nE_h2_ml = h2.get_potential_energy()\nh2.calc = d3_calc\nE_h2_d3 = h2.get_potential_energy()\nE_h2 = E_h2_ml + E_h2_d3\nprint(f\"   E(H₂): {E_h2:.2f} eV (ML: {E_h2_ml:.2f}, D3: {E_h2_d3:.2f})\")\n\n# Save H2 structure\nase.io.write(str(output_dir / part_dirs[\"part4\"] / \"h2_optimized.xyz\"), h2)\n\n\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#step-5-calculate-h-reference-energy","position":63},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 6: Compute Adsorption Energy","lvl2":"Part 4: H Adsorption Energy with ZPE Correction"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-6-compute-adsorption-energy","position":64},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 6: Compute Adsorption Energy","lvl2":"Part 4: H Adsorption Energy with ZPE Correction"},"content":"Calculate the adsorption energy using the formula: E_ads = E(slab+H) - E(slab) - 0.5×E(H₂)\n\nprint(f\"\\n4. Computing Adsorption Energy:\")\nprint(\"   E_ads = E(slab+H) - E(slab) - 0.5×E(H₂)\")\n\nE_ads = E_with_h - E_clean - 0.5 * E_h2\nE_ads_no_d3 = (E_with_h - E_with_h_d3) - (E_clean - E_clean_d3) - 0.5 * (E_h2 - E_h2_d3)\n\nprint(f\"\\n   Without D3: {E_ads_no_d3:.2f} eV\")\nprint(f\"   With D3:    {E_ads:.2f} eV\")\nprint(f\"   D3 effect:  {E_ads - E_ads_no_d3:.2f} eV\")\nprint(f\"\\n   → D3 corrections are negligible for H* (small, covalent bonding)\")\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#step-6-compute-adsorption-energy","position":65},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 7: Zero-Point Energy (ZPE) Corrections","lvl2":"Part 4: H Adsorption Energy with ZPE Correction"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-7-zero-point-energy-zpe-corrections","position":66},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 7: Zero-Point Energy (ZPE) Corrections","lvl2":"Part 4: H Adsorption Energy with ZPE Correction"},"content":"Calculate vibrational frequencies to get ZPE corrections:\n\nprint(\"\\n6. Computing ZPE corrections...\")\nprint(\"   This accounts for quantum vibrational effects\")\nh_index = len(slab_with_h) - 1\nslab_with_h.calc = calc\nvib = Vibrations(slab_with_h, indices=[h_index], delta=0.02)\nvib.run()\nvib_energies = vib.get_energies()\nzpe_ads = np.sum(vib_energies) / 2.0\n\nh2.calc = calc\nvib_h2 = Vibrations(h2, indices=[0, 1], delta=0.02)\nvib_h2.run()\nvib_energies_h2 = vib_h2.get_energies()\nzpe_h2 = np.sum(vib_energies_h2) / 2.0\n\nE_ads_zpe = E_ads + zpe_ads - 0.5 * zpe_h2\n\nprint(f\"   ZPE(H*):  {zpe_ads:.2f} eV\")\nprint(f\"   ZPE(H₂):  {zpe_h2:.2f} eV\")\nprint(f\"   E_ads(ZPE): {E_ads_zpe:.2f} eV\")\n\n# Visualize vibrational modes\nprint(\"\\n   Creating animations of vibrational modes...\")\nvib.write_mode(n=0)\nase.io.write(\"vib.0.gif\", ase.io.read(\"vib.0.traj@:\"), rotation=(\"-45x,0y,0z\"))\n\nvib.clean()\nvib_h2.clean()\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#step-7-zero-point-energy-zpe-corrections","position":67},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 8: Visualize and Compare Results","lvl2":"Part 4: H Adsorption Energy with ZPE Correction"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-8-visualize-and-compare-results","position":68},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 8: Visualize and Compare Results","lvl2":"Part 4: H Adsorption Energy with ZPE Correction"},"content":"Visualize the best configuration and compare with literature:\n\nprint(\"\\n7. Visualizing best H* configuration...\")\nview(slab_with_h, viewer='x3d')\n\n\n\n\n\nMissing UMA access?\n\nDon’t have access to UMA yet? You can still explore this calculation!\n\nDownload example H on Ni(111) structure and test it in the \n\nUMA demo (no login required) to see how the model predicts adsorption properties.\n\n# 6. Compare with literature\nprint(f\"\\n{'='*60}\")\nprint(\"Comparison with Literature:\")\nprint(f\"{'='*60}\")\nprint(\"Table 4 (DFT): -0.60 eV (Ni(111), ref H₂)\")\nprint(f\"This work:     {E_ads_zpe:.2f} eV\")\nprint(f\"Difference:    {abs(E_ads_zpe - (-0.60)):.2f} eV\")\n\n\n\nD3 Dispersion Corrections\n\nDispersion (van der Waals) interactions are important for:\n\nLarge molecules (CO, CO₂)\n\nPhysisorption\n\nMetal-support interfaces\n\nFor H adsorption, D3 corrections are typically small (<0.1 eV) because H forms strong covalent bonds with the surface. However, always check the magnitude!","type":"content","url":"/uma-catalysis-tutorial#step-8-visualize-and-compare-results","position":69},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Explore on Your Own","lvl2":"Part 4: H Adsorption Energy with ZPE Correction"},"type":"lvl3","url":"/uma-catalysis-tutorial#explore-on-your-own-2","position":70},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Explore on Your Own","lvl2":"Part 4: H Adsorption Energy with ZPE Correction"},"content":"Site preference: Identify which site (fcc, hcp, bridge, top) the H prefers. Visualize with view(atoms, viewer='x3d').\n\nCoverage effects: Place 2 H atoms on the slab. How does binding change with separation?\n\nDifferent facets: Compare H adsorption on (100) and (110) surfaces. Which is strongest?\n\nSubsurface H: Place H below the surface layer. Is it stable?\n\nZPE uncertainty: How sensitive is E_ads to the vibrational delta parameter (try 0.01, 0.03 Å)?","type":"content","url":"/uma-catalysis-tutorial#explore-on-your-own-2","position":71},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl2":"Part 5: Coverage-Dependent H Adsorption"},"type":"lvl2","url":"/uma-catalysis-tutorial#part-5-coverage-dependent-h-adsorption","position":72},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl2":"Part 5: Coverage-Dependent H Adsorption"},"content":"","type":"content","url":"/uma-catalysis-tutorial#part-5-coverage-dependent-h-adsorption","position":73},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Introduction","lvl2":"Part 5: Coverage-Dependent H Adsorption"},"type":"lvl3","url":"/uma-catalysis-tutorial#introduction-4","position":74},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Introduction","lvl2":"Part 5: Coverage-Dependent H Adsorption"},"content":"At higher coverages, adsorbate-adsorbate interactions become significant. We’ll study how H binding energy changes from dilute (1 atom) to saturated (full monolayer) coverage.","type":"content","url":"/uma-catalysis-tutorial#introduction-4","position":75},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Theory","lvl2":"Part 5: Coverage-Dependent H Adsorption"},"type":"lvl3","url":"/uma-catalysis-tutorial#theory-4","position":76},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Theory","lvl2":"Part 5: Coverage-Dependent H Adsorption"},"content":"The differential adsorption energy at coverage θ is:E_{\\text{ads}}(\\theta) = \\frac{E(n\\text{H}^*) - E(*) - n \\cdot \\frac{1}{2}E(\\text{H}_2)}{n}\n\nFor many systems, this varies linearly:E_{\\text{ads}}(\\theta) = E_{\\text{ads}}(0) + \\beta \\theta\n\nwhere β quantifies lateral interactions (repulsive if β > 0).","type":"content","url":"/uma-catalysis-tutorial#theory-4","position":77},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 1: Setup Slab and Calculators","lvl2":"Part 5: Coverage-Dependent H Adsorption"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-1-setup-slab-and-calculators","position":78},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 1: Setup Slab and Calculators","lvl2":"Part 5: Coverage-Dependent H Adsorption"},"content":"Create a larger Ni(111) slab to accommodate multiple adsorbates:\n\n# Create large Ni(111) slab\nni_bulk_atoms = bulk(\"Ni\", \"fcc\", a=a_opt, cubic=True)\nni_bulk_obj = Bulk(bulk_atoms=ni_bulk_atoms)\nni_slabs = Slab.from_bulk_get_specific_millers(\n    bulk=ni_bulk_obj, specific_millers=(1, 1, 1)\n)\nslab = ni_slabs[0].atoms.copy()\n\nprint(f\"   Created {len(slab)} atom slab\")\n\n# Set up calculators\nbase_calc = FAIRChemCalculator(predictor, task_name=\"oc20\")\nd3_calc = TorchDFTD3Calculator(device=\"cpu\", damping=\"bj\")\nprint(\"   ✓ Calculators initialized\")\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#step-1-setup-slab-and-calculators","position":79},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 2: Calculate Reference Energies","lvl2":"Part 5: Coverage-Dependent H Adsorption"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-2-calculate-reference-energies","position":80},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 2: Calculate Reference Energies","lvl2":"Part 5: Coverage-Dependent H Adsorption"},"content":"Get reference energies for clean surface and H₂:\n\nprint(\"\\n1. Relaxing clean slab...\")\nclean_slab = slab.copy()\nclean_slab.pbc = True\nclean_slab.calc = base_calc\n\nopt = LBFGS(\n    clean_slab,\n    trajectory=str(output_dir / part_dirs[\"part5\"] / \"ni111_clean.traj\"),\n    logfile=str(output_dir / part_dirs[\"part5\"] / \"ni111_clean.log\"),\n)\nopt.run(fmax=0.05, steps=relaxation_steps)\n\nE_clean_ml = clean_slab.get_potential_energy()\nclean_slab.calc = d3_calc\nE_clean_d3 = clean_slab.get_potential_energy()\nE_clean = E_clean_ml + E_clean_d3\nprint(f\"   E(clean): {E_clean:.2f} eV\")\n\nprint(\"\\n2. Calculating H₂ reference...\")\nh2 = Atoms(\"H2\", positions=[[0, 0, 0], [0, 0, 0.74]])\nh2.center(vacuum=10.0)\nh2.set_pbc([True, True, True])\nh2.calc = base_calc\n\nopt = LBFGS(\n    h2,\n    trajectory=str(output_dir / part_dirs[\"part5\"] / \"h2.traj\"),\n    logfile=str(output_dir / part_dirs[\"part5\"] / \"h2.log\"),\n)\nopt.run(fmax=0.05, steps=relaxation_steps)\n\nE_h2_ml = h2.get_potential_energy()\nh2.calc = d3_calc\nE_h2_d3 = h2.get_potential_energy()\nE_h2 = E_h2_ml + E_h2_d3\nprint(f\"   E(H₂): {E_h2:.2f} eV\")\n\n\n\n\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#step-2-calculate-reference-energies","position":81},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 3: Set Up Coverage Study","lvl2":"Part 5: Coverage-Dependent H Adsorption"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-3-set-up-coverage-study","position":82},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 3: Set Up Coverage Study","lvl2":"Part 5: Coverage-Dependent H Adsorption"},"content":"Define the coverages we’ll test (from dilute to nearly 1 ML):\n\n# Count surface sites\ntags = slab.get_tags()\nn_sites = np.sum(tags == 1)\nprint(f\"\\n3. Surface sites: {n_sites} (4×4 Ni(111))\")\n\n# Test coverages: 1 H, 0.25 ML, 0.5 ML, 0.75 ML, 1.0 ML\ncoverages_to_test = [1, 4, 8, 12, 16]\nprint(f\"\\n   Will test coverages: {[f'{n/n_sites:.2f} ML' for n in coverages_to_test]}\")\nprint(\"   This spans from dilute to nearly full monolayer\")\n\ncoverages = []\nadsorption_energies = []\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#step-3-set-up-coverage-study","position":83},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 4: Generate and Relax Configurations at Each Coverage","lvl2":"Part 5: Coverage-Dependent H Adsorption"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-4-generate-and-relax-configurations-at-each-coverage","position":84},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 4: Generate and Relax Configurations at Each Coverage","lvl2":"Part 5: Coverage-Dependent H Adsorption"},"content":"For each coverage, generate multiple configurations and find the lowest energy:\n\nfor n_h in coverages_to_test:\n    print(f\"\\n3. Coverage: {n_h} H ({n_h/n_sites:.2f} ML)\")\n\n    # Generate configurations\n    ni_bulk_obj_h = Bulk(bulk_atoms=ni_bulk_atoms)\n    ni_slabs_h = Slab.from_bulk_get_specific_millers(\n        bulk=ni_bulk_obj_h, specific_millers=(1, 1, 1)\n    )\n    slab_for_ads = ni_slabs_h[0]\n    slab_for_ads.atoms = clean_slab.copy()\n\n    adsorbates_list = [Adsorbate(adsorbate_smiles_from_db=\"*H\") for _ in range(n_h)]\n\n    try:\n        multi_ads_config = MultipleAdsorbateSlabConfig(\n            slab_for_ads, adsorbates_list, num_configurations=num_sites\n        )\n    except ValueError as e:\n        print(f\"   ⚠ Configuration generation failed: {e}\")\n        continue\n\n    if len(multi_ads_config.atoms_list) == 0:\n        print(f\"   ⚠ No configurations generated\")\n        continue\n\n    print(f\"   Generated {len(multi_ads_config.atoms_list)} configurations\")\n\n    # Relax each and find best\n    config_energies = []\n\n    for idx, config in enumerate(multi_ads_config.atoms_list):\n        config_relaxed = config.copy()\n        config_relaxed.set_pbc([True, True, True])\n        config_relaxed.calc = base_calc\n\n        opt = LBFGS(config_relaxed, logfile=None)\n        opt.run(fmax=0.05, steps=relaxation_steps)\n\n        E_ml = config_relaxed.get_potential_energy()\n        config_relaxed.calc = d3_calc\n        E_d3 = config_relaxed.get_potential_energy()\n        E_total = E_ml + E_d3\n\n        config_energies.append(E_total)\n        print(f\"     Config {idx+1}: {E_total:.2f} eV\")\n\n    best_idx = np.argmin(config_energies)\n    best_energy = config_energies[best_idx]\n    best_config = multi_ads_config.atoms_list[best_idx]\n    E_ads_per_h = (best_energy - E_clean - n_h * 0.5 * E_h2) / n_h\n\n    coverage = n_h / n_sites\n    coverages.append(coverage)\n    adsorption_energies.append(E_ads_per_h)\n\n    print(f\"   → E_ads/H: {E_ads_per_h:.2f} eV\")\n\n    # Visualize best configuration at this coverage\n    print(f\"   Visualizing configuration with {n_h} H atoms...\")\n    view(best_config, viewer='x3d')\n\nprint(f\"\\n✓ Completed coverage study: {len(coverages)} data points\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#step-4-generate-and-relax-configurations-at-each-coverage","position":85},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 5: Perform Linear Fit","lvl2":"Part 5: Coverage-Dependent H Adsorption"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-5-perform-linear-fit","position":86},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 5: Perform Linear Fit","lvl2":"Part 5: Coverage-Dependent H Adsorption"},"content":"Fit E_ads vs coverage to extract the slope (lateral interaction strength):\n\nprint(\"\\n4. Performing linear fit to coverage dependence...\")\n\n# Linear fit\nfrom numpy.polynomial import Polynomial\n\np = Polynomial.fit(coverages, adsorption_energies, 1)\nslope = p.coef[1]\nintercept = p.coef[0]\n\nprint(f\"\\n{'='*60}\")\nprint(f\"Linear Fit: E_ads = {intercept:.2f} + {slope:.2f}θ (eV)\")\nprint(f\"Slope: {slope * 96.485:.1f} kJ/mol per ML\")\nprint(f\"Paper: 8.7 kJ/mol per ML\")\nprint(f\"{'='*60}\")\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#step-5-perform-linear-fit","position":87},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 6: Visualize Coverage Dependence","lvl2":"Part 5: Coverage-Dependent H Adsorption"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-6-visualize-coverage-dependence","position":88},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 6: Visualize Coverage Dependence","lvl2":"Part 5: Coverage-Dependent H Adsorption"},"content":"Create a plot showing how adsorption energy changes with coverage:\n\nprint(\"\\n5. Plotting coverage dependence...\")\n\n# Plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.scatter(\n    coverages,\n    adsorption_energies,\n    s=100,\n    marker=\"o\",\n    label=\"Calculated\",\n    zorder=3,\n    color=\"steelblue\",\n)\n\ncov_fit = np.linspace(0, max(coverages), 100)\nads_fit = p(cov_fit)\nax.plot(\n    cov_fit, ads_fit, \"r--\", label=f\"Fit: {intercept:.2f} + {slope:.2f}θ\", linewidth=2\n)\n\nax.set_xlabel(\"H Coverage (ML)\", fontsize=12)\nax.set_ylabel(\"Adsorption Energy (eV/H)\", fontsize=12)\nax.set_title(\"Coverage-Dependent H Adsorption on Ni(111)\", fontsize=14)\nax.legend(fontsize=11)\nax.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.savefig(str(output_dir / part_dirs[\"part5\"] / \"coverage_dependence.png\"), dpi=300)\nplt.show()\n\nprint(\"\\n✓ Coverage dependence analysis complete!\")\n\n\n\n\n\n\n\nMissing UMA access?\n\nDon’t have access to UMA yet? You can still explore this calculation!\n\nDownload example multiple H on Ni(111) structure and test it in the \n\nUMA demo (no login required) to see how the model handles coverage-dependent binding.\n\nComparison with Paper\n\nExpected Results from Paper:\n\nSlope: 8.7 kJ/mol per ML (indicating repulsive lateral H-H interactions)\n\nPhysical interpretation: H atoms repel weakly due to electrostatic and Pauli effects\n\nWhat to Check:\n\nYour fitted slope should be close to 8.7 kJ/mol per ML\n\nThe relationship should be approximately linear for θ < 1 ML\n\nIntercept (E_ads at θ → 0) should match the single-H result from Part 4 (~-0.60 eV)\n\nTypical Variations:\n\nSlope can vary by ±2-3 kJ/mol depending on slab size and configuration sampling\n\nNon-linearity may appear at very high coverage (θ > 0.75 ML)\n\nModel differences can affect lateral interactions more than adsorption energies\n\nPhysical Insights\n\nPositive slope (repulsive interactions):\n\nElectrostatic: H atoms accumulate negative charge from Ni\n\nPauli repulsion: Overlapping electron clouds\n\nStrain: Lattice distortions propagate\n\nMagnitude:\n\nWeak (~10 kJ/mol/ML) → isolated adsorbates\n\nStrong (>50 kJ/mol/ML) → clustering or phase separation likely\n\nThe paper reports 8.7 kJ/mol/ML, indicating relatively weak lateral interactions for H on Ni(111).","type":"content","url":"/uma-catalysis-tutorial#step-6-visualize-coverage-dependence","position":89},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Explore on Your Own","lvl2":"Part 5: Coverage-Dependent H Adsorption"},"type":"lvl3","url":"/uma-catalysis-tutorial#explore-on-your-own-3","position":90},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Explore on Your Own","lvl2":"Part 5: Coverage-Dependent H Adsorption"},"content":"Non-linear behavior: Use polynomial (degree 2) fit. Is there curvature at high coverage?\n\nTemperature effects: Estimate configurational entropy at each coverage. How does this affect free energy?\n\nPattern formation: Visualize the lowest-energy configuration at 0.5 ML. Are H atoms ordered?\n\nOther adsorbates: Repeat for O or N. How do lateral interactions compare?\n\nPhase diagrams: At what coverage do you expect phase separation (islands vs uniform)?","type":"content","url":"/uma-catalysis-tutorial#explore-on-your-own-3","position":91},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"type":"lvl2","url":"/uma-catalysis-tutorial#part-6-co-formation-dissociation-thermochemistry-and-barrier","position":92},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"content":"","type":"content","url":"/uma-catalysis-tutorial#part-6-co-formation-dissociation-thermochemistry-and-barrier","position":93},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Introduction","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"type":"lvl3","url":"/uma-catalysis-tutorial#introduction-5","position":94},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Introduction","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"content":"CO dissociation (CO* → C* + O*) is the rate-limiting step in many catalytic processes (Fischer-Tropsch, CO oxidation, etc.). We’ll calculate the reaction energy for C* + O* → CO* and the activation barriers in both directions using the nudged elastic band (NEB) method.","type":"content","url":"/uma-catalysis-tutorial#introduction-5","position":95},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Theory","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"type":"lvl3","url":"/uma-catalysis-tutorial#theory-5","position":96},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Theory","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"content":"Forward Reaction: C* + O* → CO* + * (recombination)\n\nReverse Reaction: CO* + → C + O* (dissociation)\n\nThermochemistry: \\Delta E_{\\text{rxn}} = E(\\text{C}^* + \\text{O}^*) - E(\\text{CO}^*)\n\nBarrier: NEB finds the minimum energy path (MEP) and transition state: E_a = E^{\\ddagger} - E_{\\text{initial}}","type":"content","url":"/uma-catalysis-tutorial#theory-5","position":97},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 1: Setup Slab and Calculators","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-1-setup-slab-and-calculators-1","position":98},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 1: Setup Slab and Calculators","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"content":"Initialize the Ni(111) surface and calculators:\n\n# Create slab\nni_bulk_atoms = bulk(\"Ni\", \"fcc\", a=a_opt, cubic=True)\nni_bulk_obj = Bulk(bulk_atoms=ni_bulk_atoms)\nni_slabs = Slab.from_bulk_get_specific_millers(\n    bulk=ni_bulk_obj, specific_millers=(1, 1, 1)\n)\nslab = ni_slabs[0].atoms\n\nprint(f\"   Created {len(slab)} atom slab\")\n\nbase_calc = FAIRChemCalculator(predictor, task_name=\"oc20\")\nd3_calc = TorchDFTD3Calculator(device=\"cpu\", damping=\"bj\")\nprint(\"   \\u2713 Calculators initialized\")\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#step-1-setup-slab-and-calculators-1","position":99},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 2: Generate and Relax Final State (CO*)","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-2-generate-and-relax-final-state-co","position":100},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 2: Generate and Relax Final State (CO*)","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"content":"Find the most stable CO adsorption configuration (this is the product of C+O recombination):\n\nprint(\"\\n1. Final State: CO* on Ni(111)\")\nprint(\"   Generating CO adsorption configurations...\")\n\nni_bulk_obj_co = Bulk(bulk_atoms=ni_bulk_atoms)\nni_slab_co = Slab.from_bulk_get_specific_millers(\n    bulk=ni_bulk_obj_co, specific_millers=(1, 1, 1)\n)[0]\nni_slab_co.atoms = slab.copy()\n\nadsorbate_co = Adsorbate(adsorbate_smiles_from_db=\"*CO\")\nmulti_ads_config_co = MultipleAdsorbateSlabConfig(\n    ni_slab_co, [adsorbate_co], num_configurations=num_sites\n)\n\nprint(f\"   Generated {len(multi_ads_config_co.atoms_list)} configurations\")\n\n# Relax and find best\nco_energies = []\nco_energies_ml = []\nco_energies_d3 = []\nco_configs = []\n\nfor idx, config in enumerate(multi_ads_config_co.atoms_list):\n    config_relaxed = config.copy()\n    config_relaxed.set_pbc([True, True, True])\n    config_relaxed.calc = base_calc\n    opt = LBFGS(config_relaxed, logfile=None)\n    opt.run(fmax=0.05, steps=relaxation_steps)\n\n    E_ml = config_relaxed.get_potential_energy()\n    config_relaxed.calc = d3_calc\n    E_d3 = config_relaxed.get_potential_energy()\n    E_total = E_ml + E_d3\n\n    co_energies.append(E_total)\n    co_energies_ml.append(E_ml)\n    co_energies_d3.append(E_d3)\n    co_configs.append(config_relaxed)\n    print(\n        f\"     Config {idx+1}: E_total = {E_total:.2f} eV (RPBE: {E_ml:.2f}, D3: {E_d3:.2f})\"\n    )\n\nbest_co_idx = np.argmin(co_energies)\nfinal_co = co_configs[best_co_idx]\nE_final_co = co_energies[best_co_idx]\nE_final_co_ml = co_energies_ml[best_co_idx]\nE_final_co_d3 = co_energies_d3[best_co_idx]\n\nprint(f\"\\n   → Best CO* (Config {best_co_idx+1}):\")\nprint(f\"      RPBE:  {E_final_co_ml:.2f} eV\")\nprint(f\"      D3:    {E_final_co_d3:.2f} eV\")\nprint(f\"      Total: {E_final_co:.2f} eV\")\n\n# Save best CO state\nase.io.write(str(output_dir / part_dirs[\"part6\"] / \"co_final_best.traj\"), final_co)\nprint(\"   ✓ Best CO* structure saved\")\n\n# Visualize best CO* structure\nprint(\"\\n   Visualizing best CO* structure...\")\nview(final_co, viewer='x3d')\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#step-2-generate-and-relax-final-state-co","position":101},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 3: Generate and Relax Initial State (C* + O*)","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-3-generate-and-relax-initial-state-c-o","position":102},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 3: Generate and Relax Initial State (C* + O*)","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"content":"Find the most stable configuration for dissociated C and O (reactants):\n\nprint(\"\\n2. Initial State: C* + O* on Ni(111)\")\nprint(\"   Generating C+O configurations...\")\n\nni_bulk_obj_c_o = Bulk(bulk_atoms=ni_bulk_atoms)\nni_slab_c_o = Slab.from_bulk_get_specific_millers(\n    bulk=ni_bulk_obj_c_o, specific_millers=(1, 1, 1)\n)[0]\n\nadsorbate_c = Adsorbate(adsorbate_smiles_from_db=\"*C\")\nadsorbate_o = Adsorbate(adsorbate_smiles_from_db=\"*O\")\n\nmulti_ads_config_c_o = MultipleAdsorbateSlabConfig(\n    ni_slab_c_o, [adsorbate_c, adsorbate_o], num_configurations=num_sites\n)\n\nprint(f\"   Generated {len(multi_ads_config_c_o.atoms_list)} configurations\")\n\nc_o_energies = []\nc_o_energies_ml = []\nc_o_energies_d3 = []\nc_o_configs = []\n\nfor idx, config in enumerate(multi_ads_config_c_o.atoms_list):\n    config_relaxed = config.copy()\n    config_relaxed.set_pbc([True, True, True])\n    config_relaxed.calc = base_calc\n    opt = LBFGS(config_relaxed, logfile=None)\n    opt.run(fmax=0.05, steps=relaxation_steps)\n\n    # Check C-O bond distance to ensure they haven't formed CO molecule\n    c_o_dist = config_relaxed[config_relaxed.get_tags() == 2].get_distance(\n        0, 1, mic=True\n    )\n\n    # CO bond length is ~1.15 Å, so if distance < 1.5 Å, they've formed a molecule\n    if c_o_dist < 1.5:\n        print(\n            f\"     Config {idx+1}: ⚠ REJECTED - C and O formed CO molecule (d = {c_o_dist:.2f} Å)\"\n        )\n        continue\n\n    E_ml = config_relaxed.get_potential_energy()\n    config_relaxed.calc = d3_calc\n    E_d3 = config_relaxed.get_potential_energy()\n    E_total = E_ml + E_d3\n\n    c_o_energies.append(E_total)\n    c_o_energies_ml.append(E_ml)\n    c_o_energies_d3.append(E_d3)\n    c_o_configs.append(config_relaxed)\n    print(\n        f\"     Config {idx+1}: E_total = {E_total:.2f} eV (RPBE: {E_ml:.2f}, D3: {E_d3:.2f}, C-O dist: {c_o_dist:.2f} Å)\"\n    )\n\nbest_c_o_idx = np.argmin(c_o_energies)\ninitial_c_o = c_o_configs[best_c_o_idx]\nE_initial_c_o = c_o_energies[best_c_o_idx]\nE_initial_c_o_ml = c_o_energies_ml[best_c_o_idx]\nE_initial_c_o_d3 = c_o_energies_d3[best_c_o_idx]\n\nprint(f\"\\n   → Best C*+O* (Config {best_c_o_idx+1}):\")\nprint(f\"      RPBE:  {E_initial_c_o_ml:.2f} eV\")\nprint(f\"      D3:    {E_initial_c_o_d3:.2f} eV\")\nprint(f\"      Total: {E_initial_c_o:.2f} eV\")\n\n# Save best C+O state\nase.io.write(str(output_dir / part_dirs[\"part6\"] / \"co_initial_best.traj\"), initial_c_o)\nprint(\"   ✓ Best C*+O* structure saved\")\n\n# Visualize best C*+O* structure\nprint(\"\\n   Visualizing best C*+O* structure...\")\nview(initial_c_o, viewer='x3d')\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#step-3-generate-and-relax-initial-state-c-o","position":103},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 3b: Calculate C* and O* Energies Separately","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-3b-calculate-c-and-o-energies-separately","position":104},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 3b: Calculate C* and O* Energies Separately","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"content":"Another strategy to calculate the initial energies for *C and *O at very low coverage (without interactions between the two reactants) is to do two separate relaxations.\n\n# Clean slab\nni_bulk_obj = Bulk(bulk_atoms=ni_bulk_atoms)\nclean_slab = Slab.from_bulk_get_specific_millers(\n    bulk=ni_bulk_obj_c_o, specific_millers=(1, 1, 1)\n)[0].atoms\nclean_slab.set_pbc([True, True, True])\nclean_slab.calc = base_calc\nopt = LBFGS(clean_slab, logfile=None)\nopt.run(fmax=0.05, steps=relaxation_steps)\n\nE_clean_ml = clean_slab.get_potential_energy()\nclean_slab.calc = d3_calc\nE_clean_d3 = clean_slab.get_potential_energy()\nE_clean = E_clean_ml + E_clean_d3\n\nprint(\n    f\"\\n   Clean slab: E_total = {E_clean:.2f} eV (RPBE: {E_clean_ml:.2f}, D3: {E_clean_d3:.2f})\"\n)\n\n\n\n\n\nprint(f\"\\n2b. Separate C* and O* Energies:\")\nprint(\"    Calculating energies in separate unit cells to avoid interactions\")\n\nni_bulk_obj_c_o = Bulk(bulk_atoms=ni_bulk_atoms)\nni_slab_c_o = Slab.from_bulk_get_specific_millers(\n    bulk=ni_bulk_obj_c_o, specific_millers=(1, 1, 1)\n)[0]\n\nprint(\"\\n   Generating C* configurations...\")\nmulti_ads_config_c = MultipleAdsorbateSlabConfig(\n    ni_slab_c_o,\n    adsorbates=[Adsorbate(adsorbate_smiles_from_db=\"*C\")],\n    num_configurations=num_sites,\n)\n\nc_energies = []\nc_energies_ml = []\nc_energies_d3 = []\nc_configs = []\n\nfor idx, config in enumerate(multi_ads_config_c.atoms_list):\n    config_relaxed = config.copy()\n    config_relaxed.set_pbc([True, True, True])\n    config_relaxed.calc = base_calc\n    opt = LBFGS(config_relaxed, logfile=None)\n    opt.run(fmax=0.05, steps=relaxation_steps)\n\n    E_ml = config_relaxed.get_potential_energy()\n    config_relaxed.calc = d3_calc\n    E_d3 = config_relaxed.get_potential_energy()\n    E_total = E_ml + E_d3\n\n    c_energies.append(E_total)\n    c_energies_ml.append(E_ml)\n    c_energies_d3.append(E_d3)\n    c_configs.append(config_relaxed)\n    print(\n        f\"     Config {idx+1}: E_total = {E_total:.2f} eV (RPBE: {E_ml:.2f}, D3: {E_d3:.2f})\"\n    )\n\nbest_c_idx = np.argmin(c_energies)\nc_ads = c_configs[best_c_idx]\nE_c = c_energies[best_c_idx]\nE_c_ml = c_energies_ml[best_c_idx]\nE_c_d3 = c_energies_d3[best_c_idx]\n\nprint(f\"\\n   → Best C* (Config {best_c_idx+1}):\")\nprint(f\"      RPBE:  {E_c_ml:.2f} eV\")\nprint(f\"      D3:    {E_c_d3:.2f} eV\")\nprint(f\"      Total: {E_c:.2f} eV\")\n\n# Save best C state\nase.io.write(str(output_dir / part_dirs[\"part6\"] / \"c_best.traj\"), c_ads)\n\n# Visualize best C* structure\nprint(\"\\n   Visualizing best C* structure...\")\nview(c_ads, viewer='x3d')\n\n# Generate O* configuration\nprint(\"\\n   Generating O* configurations...\")\nmulti_ads_config_o = MultipleAdsorbateSlabConfig(\n    ni_slab_c_o,\n    adsorbates=[Adsorbate(adsorbate_smiles_from_db=\"*O\")],\n    num_configurations=num_sites,\n)\no_energies = []\no_energies_ml = []\no_energies_d3 = []\no_configs = []\n\nfor idx, config in enumerate(multi_ads_config_o.atoms_list):\n    config_relaxed = config.copy()\n    config_relaxed.set_pbc([True, True, True])\n    config_relaxed.calc = base_calc\n    opt = LBFGS(config_relaxed, logfile=None)\n    opt.run(fmax=0.05, steps=relaxation_steps)\n\n    E_ml = config_relaxed.get_potential_energy()\n    config_relaxed.calc = d3_calc\n    E_d3 = config_relaxed.get_potential_energy()\n    E_total = E_ml + E_d3\n\n    o_energies.append(E_total)\n    o_energies_ml.append(E_ml)\n    o_energies_d3.append(E_d3)\n    o_configs.append(config_relaxed)\n    print(\n        f\"     Config {idx+1}: E_total = {E_total:.2f} eV (RPBE: {E_ml:.2f}, D3: {E_d3:.2f})\"\n    )\n\nbest_o_idx = np.argmin(o_energies)\no_ads = o_configs[best_o_idx]\nE_o = o_energies[best_o_idx]\nE_o_ml = o_energies_ml[best_o_idx]\nE_o_d3 = o_energies_d3[best_o_idx]\n\nprint(f\"\\n   → Best O* (Config {best_o_idx+1}):\")\nprint(f\"      RPBE:  {E_o_ml:.2f} eV\")\nprint(f\"      D3:    {E_o_d3:.2f} eV\")\nprint(f\"      Total: {E_o:.2f} eV\")\n\n# Save best O state\nase.io.write(str(output_dir / part_dirs[\"part6\"] / \"o_best.traj\"), o_ads)\n\n# Visualize best O* structure\nprint(\"\\n   Visualizing best O* structure...\")\nview(o_ads, viewer='x3d')\n\n# Calculate combined energy for separate C* and O*\nE_initial_c_o_separate = E_c + E_o\nE_initial_c_o_separate_ml = E_c_ml + E_o_ml\nE_initial_c_o_separate_d3 = E_c_d3 + E_o_d3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprint(f\"\\n   Combined C* + O* (separate calculations):\")\nprint(f\"      RPBE:  {E_initial_c_o_separate_ml:.2f} eV\")\nprint(f\"      D3:    {E_initial_c_o_separate_d3:.2f} eV\")\nprint(f\"      Total: {E_initial_c_o_separate:.2f} eV\")\n\nprint(f\"\\n   Comparison:\")\nprint(f\"      C*+O* (same cell):  {E_initial_c_o - E_clean:.2f} eV\")\nprint(f\"      C* + O* (separate): {E_initial_c_o_separate - 2*E_clean:.2f} eV\")\nprint(\n    f\"      Difference:         {(E_initial_c_o - E_clean) - (E_initial_c_o_separate - 2*E_clean):.2f} eV\"\n)\nprint(\"   ✓ Separate C* and O* energies calculated\")\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#step-3b-calculate-c-and-o-energies-separately","position":105},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 4: Calculate Reaction Energy with ZPE","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-4-calculate-reaction-energy-with-zpe","position":106},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 4: Calculate Reaction Energy with ZPE","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"content":"Compute the thermochemistry for C* + O* → CO* with ZPE corrections:\n\nprint(f\"\\n3. Reaction Energy (C* + O* → CO*):\")\nprint(f\"   \" + \"=\" * 60)\n\n# Electronic energies\nprint(f\"\\n   Electronic Energies:\")\nprint(\n    f\"   Initial (C*+O*): RPBE = {E_initial_c_o_ml:.2f} eV, D3 = {E_initial_c_o_d3:.2f} eV, Total = {E_initial_c_o:.2f} eV\"\n)\nprint(\n    f\"   Final (CO*):     RPBE = {E_final_co_ml:.2f} eV, D3 = {E_final_co_d3:.2f} eV, Total = {E_final_co:.2f} eV\"\n)\n\n# Reaction energies without ZPE\ndelta_E_rpbe = E_final_co_ml - E_initial_c_o_ml\ndelta_E_d3_contrib = E_final_co_d3 - E_initial_c_o_d3\ndelta_E_elec = E_final_co - E_initial_c_o\n\nprint(f\"\\n   Reaction Energies (without ZPE):\")\nprint(f\"   ΔE(RPBE only):     {delta_E_rpbe:.2f} eV = {delta_E_rpbe*96.485:.1f} kJ/mol\")\nprint(\n    f\"   ΔE(D3 contrib):    {delta_E_d3_contrib:.2f} eV = {delta_E_d3_contrib*96.485:.1f} kJ/mol\"\n)\nprint(f\"   ΔE(RPBE+D3):       {delta_E_elec:.2f} eV = {delta_E_elec*96.485:.1f} kJ/mol\")\n\n# Calculate ZPE for CO* (final state)\nprint(f\"\\n   Computing ZPE for CO*...\")\nfinal_co.calc = base_calc\n\nco_indices = np.where(final_co.get_tags() == 2)[0]\nvib_co = Vibrations(final_co, indices=co_indices, delta=0.02, name=\"vib_co\")\nvib_co.run()\nvib_energies_co = vib_co.get_energies()\nzpe_co = np.sum(vib_energies_co[vib_energies_co > 0]) / 2.0\nvib_co.clean()\nprint(f\"   ZPE(CO*): {zpe_co:.2f} eV ({zpe_co*1000:.1f} meV)\")\n\n\n# Calculate ZPE for C* and O* (initial state)\nprint(f\"\\n   Computing ZPE for C* and O*...\")\ninitial_c_o.calc = base_calc\nc_o_indices = np.where(initial_c_o.get_tags() == 2)[0]\nvib_c_o = Vibrations(initial_c_o, indices=c_o_indices, delta=0.02, name=\"vib_c_o\")\nvib_c_o.run()\nvib_energies_c_o = vib_c_o.get_energies()\nzpe_c_o = np.sum(vib_energies_c_o[vib_energies_c_o > 0]) / 2.0\nvib_c_o.clean()\nprint(f\"   ZPE(C*+O*): {zpe_c_o:.2f} eV ({zpe_c_o*1000:.1f} meV)\")\n\n\n# Total reaction energy with ZPE\ndelta_zpe = zpe_co - zpe_c_o\ndelta_E_zpe = delta_E_elec + delta_zpe\n\nprint(f\"\\n   Reaction Energy (with ZPE):\")\nprint(f\"   ΔE(electronic):    {delta_E_elec:.2f} eV = {delta_E_elec*96.485:.1f} kJ/mol\")\nprint(\n    f\"   ΔZPE:              {delta_zpe:.2f} eV = {delta_zpe*96.485:.1f} kJ/mol ({delta_zpe*1000:.1f} meV)\"\n)\nprint(f\"   ΔE(total):         {delta_E_zpe:.2f} eV = {delta_E_zpe*96.485:.1f} kJ/mol\")\n\nprint(f\"\\n   Summary:\")\nprint(\n    f\"   Without D3, without ZPE: {delta_E_rpbe:.2f} eV = {delta_E_rpbe*96.485:.1f} kJ/mol\"\n)\nprint(\n    f\"   With D3, without ZPE:    {delta_E_elec:.2f} eV = {delta_E_elec*96.485:.1f} kJ/mol\"\n)\nprint(\n    f\"   With D3, with ZPE:       {delta_E_zpe:.2f} eV = {delta_E_zpe*96.485:.1f} kJ/mol\"\n)\n\nprint(f\"\\n   \" + \"=\" * 60)\nprint(f\"\\n   Comparison with Paper (Table 5):\")\nprint(f\"   Paper (DFT-D3): -142.7 kJ/mol = -1.48 eV\")\nprint(f\"   This work:      {delta_E_zpe*96.485:.1f} kJ/mol = {delta_E_zpe:.2f} eV\")\nprint(f\"   Difference:     {abs(delta_E_zpe - (-1.48)):.2f} eV\")\n\nif delta_E_zpe < 0:\n    print(f\"\\n   ✓ Reaction is exothermic (C+O recombination favorable)\")\nelse:\n    print(f\"\\n   ⚠ Reaction is endothermic (dissociation favorable)\")\n\n\n\n\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#step-4-calculate-reaction-energy-with-zpe","position":107},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 5: Calculate CO Adsorption Energy (Bonus)","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-5-calculate-co-adsorption-energy-bonus","position":108},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 5: Calculate CO Adsorption Energy (Bonus)","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"content":"Calculate how strongly CO binds to the surface:\n\nprint(f\"\\n4. CO Adsorption Energy ( CO(g) + * → CO*):\")\nprint(\"   This helps us understand CO binding strength\")\n\n# CO(g)\nco_gas = Atoms(\"CO\", positions=[[0, 0, 0], [0, 0, 1.15]])\nco_gas.center(vacuum=10.0)\nco_gas.set_pbc([True, True, True])\nco_gas.calc = base_calc\nopt = LBFGS(co_gas, logfile=None)\nopt.run(fmax=0.05, steps=relaxation_steps)\n\nE_co_gas_ml = co_gas.get_potential_energy()\nco_gas.calc = d3_calc\nE_co_gas_d3 = co_gas.get_potential_energy()\nE_co_gas = E_co_gas_ml + E_co_gas_d3\n\nprint(\n    f\"   CO(g):       E_total = {E_co_gas:.2f} eV (RPBE: {E_co_gas_ml:.2f}, D3: {E_co_gas_d3:.2f})\"\n)\n\n# Calculate ZPE for CO(g)\nco_gas.calc = base_calc\nvib_co_gas = Vibrations(co_gas, indices=[0, 1], delta=0.01, nfree=2)\nvib_co_gas.clean()\nvib_co_gas.run()\nvib_energies_co_gas = vib_co_gas.get_energies()\nzpe_co_gas = 0.5 * np.sum(vib_energies_co_gas[vib_energies_co_gas > 0])\nvib_co_gas.clean()\n\nprint(f\"   ZPE(CO(g)):  {zpe_co_gas:.2f} eV\")\nprint(f\"   ZPE(CO*):    {zpe_co:.2f} eV (from Step 4 calculation)\")\n\n# Electronic adsorption energy\nE_ads_co_elec = E_final_co - E_clean - E_co_gas\n\n# ZPE contribution to adsorption energy\ndelta_zpe_ads = zpe_co - zpe_co_gas\n\n# Total adsorption energy with ZPE\nE_ads_co_total = E_ads_co_elec + delta_zpe_ads\n\nprint(f\"\\n   Electronic Energy Breakdown:\")\nprint(f\"   ΔE(RPBE only) = {(E_final_co_ml - E_clean_ml - E_co_gas_ml):.2f} eV\")\nprint(f\"   ΔE(D3 contrib) = {((E_final_co_d3 - E_clean_d3 - E_co_gas_d3)):.2f} eV\")\nprint(f\"   ΔE(RPBE+D3) = {E_ads_co_elec:.2f} eV\")\nprint(f\"\\n   ZPE Contribution:\")\nprint(f\"   ΔZPE = {delta_zpe_ads:.2f} eV\")\nprint(f\"\\n   Total Adsorption Energy:\")\nprint(f\"   ΔE(total) = {E_ads_co_total:.2f} eV = {E_ads_co_total*96.485:.1f} kJ/mol\")\nprint(f\"\\n   Summary:\")\nprint(\n    f\"   E_ads(CO) without ZPE = {-E_ads_co_elec:.2f} eV = {-E_ads_co_elec*96.485:.1f} kJ/mol\"\n)\nprint(\n    f\"   E_ads(CO) with ZPE    = {-E_ads_co_total:.2f} eV = {-E_ads_co_total*96.485:.1f} kJ/mol\"\n)\nprint(\n    f\"   → CO binds {abs(E_ads_co_total):.2f} eV stronger than H ({abs(E_ads_co_total)/0.60:.1f}x)\"\n)\n\n\n\n\n\n\n\nComparison with Paper Results\n\nThe paper reports a CO adsorption energy of 1.82 eV (175.6 kJ/mol) in Table 4, calculated using DFT (RPBE functional).\n\nThese results show:\n\nWithout ZPE: The electronic binding energy matches well with DFT predictions\n\nWith ZPE: The zero-point energy correction reduces the binding strength slightly\n\nD3 Dispersion: Contributes to stronger binding due to van der Waals interactions","type":"content","url":"/uma-catalysis-tutorial#step-5-calculate-co-adsorption-energy-bonus","position":109},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 6: Find guesses for nearby initial and final states for the reaction","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-6-find-guesses-for-nearby-initial-and-final-states-for-the-reaction","position":110},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 6: Find guesses for nearby initial and final states for the reaction","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"content":"Now that we have an estimate on the reaction energy from the best possible initial and final states, we want to find a transition state (barrier) for this reaction. There are MANY possible ways that we could do this. In this case, we’ll start with the *CO final state and then try and find a nearby local minimal of *C and *O, by fixing the C-O bond distance and finding a nearby local minima. Note that this approach required some insight into what the transition state might look like, and could be considerably more complicated for a reaction that did not involve breaking a single bond.\n\nprint(f\"\\nFinding Transition State Initial and Final States\")\nprint(\"   Creating initial guess with stretched C-O bond...\")\nprint(\"   Starting from CO* and stretching the C-O bond...\")\n\n# Create a guess structure with stretched CO bond (start from CO*)\ninitial_guess = final_co.copy()\n\n# Set up a constraint to fix the bond length to ~2 Angstroms, which should be far enough that we'll be closer to *C+*O than *CO\nco_indices = np.where(initial_guess.get_tags() == 2)[0]\n\n# Rotate the atoms a bit just to break the symmetry and prevent the O from going straight up to satisfy the constraint\ninitial_slab = initial_guess[initial_guess.get_tags() != 2]\ninitial_co = initial_guess[initial_guess.get_tags() == 2]\ninitial_co.rotate(30, \"x\", center=initial_co.positions[0])\ninitial_guess = initial_slab + initial_co\n\ninitial_guess.calc = FAIRChemCalculator(predictor, task_name=\"oc20\")\n\n# Add constraints to keep the CO bond length extended\ninitial_guess.constraints += [\n    FixBondLengths([co_indices], tolerance=1e-2, iterations=5000, bondlengths=[2.0])\n]\n\n\ntry:\n    opt = LBFGS(\n        initial_guess,\n        trajectory=output_dir / part_dirs[\"part6\"] / \"initial_guess_with_constraint.traj\",\n    )\n    opt.run(fmax=0.01)\nexcept RuntimeError:\n    # The FixBondLength constraint is sometimes a little finicky,\n    # but it's ok if it doesn't finish as it's just an initial guess\n    # for the next step\n    pass\n\n# Now that we have a guess, re-relax without the constraints\ninitial_guess.constraints = initial_guess.constraints[:-1]\nopt = LBFGS(\n    initial_guess,\n    trajectory=output_dir\n    / part_dirs[\"part6\"]\n    / \"initial_guess_without_constraint.traj\",\n)\nopt.run(fmax=0.01)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#step-6-find-guesses-for-nearby-initial-and-final-states-for-the-reaction","position":111},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 7: Run NEB to Find Activation Barrier","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-7-run-neb-to-find-activation-barrier","position":112},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 7: Run NEB to Find Activation Barrier","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"content":"Use the nudged elastic band method to find the minimum energy path:\n\nprint(f\"\\n7. NEB Barrier Calculation (C* + O* → CO*)\")\nprint(\"   Setting up 7-image NEB chain with TS guess in middle...\")\nprint(\"   Reaction: C* + O* (initial) → TS → CO* (final)\")\n\ninitial = initial_guess.copy()\ninitial.calc = FAIRChemCalculator(predictor, task_name=\"oc20\")\nimages = [initial]  # Start with C* + O*\n\nn_images = 10\nfor i in range(n_images):\n    image = initial.copy()\n    image.calc = FAIRChemCalculator(predictor, task_name=\"oc20\")\n    images.append(image)\n\nfinal = final_co.copy()\nfinal.calc = FAIRChemCalculator(predictor, task_name=\"oc20\")\nimages.append(final)  # End with CO*\n\n# Interpolate with better initial guess\ndyneb = DyNEB(images, climb=True, fmax=0.05)\n\n# Interpolate first half (C*+O* → TS)\nprint(\"\\n   Interpolating images...\")\ndyneb.interpolate(\"idpp\", mic=True)\n\n# Optimize\nprint(\"   Optimizing NEB path (this may take a while)...\")\nopt = FIRE(\n    dyneb,\n    trajectory=str(output_dir / part_dirs[\"part6\"] / \"neb.traj\"),\n    logfile=str(output_dir / part_dirs[\"part6\"] / \"neb.log\"),\n)\nopt.run(fmax=0.1, steps=relaxation_steps)\n\n# Extract barrier (from C*+O* to TS)\nenergies = [img.get_potential_energy() for img in images]\nenergies_rel = np.array(energies) - energies[0]\nE_barrier = np.max(energies_rel)\n\nprint(f\"\\n   ✓ NEB converged!\")\nprint(\n    f\"\\n   Forward barrier (C*+O* → CO*): {E_barrier:.2f} eV = {E_barrier*96.485:.1f} kJ/mol\"\n)\nprint(\n    f\"   Reverse barrier (CO* → C*+O*): {E_barrier - energies_rel[-1]:.2f} eV = {(E_barrier- energies_rel[-1])*96.485:.1f} kJ/mol\"\n)\nprint(f\"\\n   Paper (Table 5): 153 kJ/mol = 1.59 eV \")\nprint(f\"   Difference: {abs(E_barrier - 1.59):.2f} eV\")\n\n\n\n\n\n\n\n","type":"content","url":"/uma-catalysis-tutorial#step-7-run-neb-to-find-activation-barrier","position":113},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 8: Visualize NEB Path and Key Structures","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"type":"lvl3","url":"/uma-catalysis-tutorial#step-8-visualize-neb-path-and-key-structures","position":114},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Step 8: Visualize NEB Path and Key Structures","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"content":"Create plots showing the reaction pathway:\n\nprint(\"\\n   Creating NEB visualization...\")\n\n# Plot NEB path\nfig, ax = plt.subplots(figsize=(10, 6))\nax.plot(\n    range(len(energies_rel)),\n    energies_rel,\n    \"o-\",\n    linewidth=2,\n    markersize=10,\n    color=\"steelblue\",\n    label=\"NEB Path\",\n)\nax.axhline(0, color=\"green\", linestyle=\"--\", alpha=0.5, label=\"Initial: C*+O*\")\nax.axhline(delta_E_zpe, color=\"red\", linestyle=\"--\", alpha=0.5, label=\"Final: CO*\")\nax.axhline(\n    E_barrier,\n    color=\"orange\",\n    linestyle=\":\",\n    alpha=0.7,\n    linewidth=2,\n    label=f\"Forward Barrier = {E_barrier:.2f} eV\",\n)\n\n# Annotate transition state\nts_idx = np.argmax(energies_rel)\nax.annotate(\n    f\"TS\\n{energies_rel[ts_idx]:.2f} eV\",\n    xy=(ts_idx, energies_rel[ts_idx]),\n    xytext=(ts_idx, energies_rel[ts_idx] + 0.3),\n    ha=\"center\",\n    fontsize=11,\n    fontweight=\"bold\",\n    arrowprops=dict(arrowstyle=\"->\", lw=1.5, color=\"red\"),\n)\n\nax.set_xlabel(\"Image Number\", fontsize=13)\nax.set_ylabel(\"Relative Energy (eV)\", fontsize=13)\nax.set_title(\n    \"CO Formation on Ni(111): C* + O* → CO* - NEB Path\", fontsize=15, fontweight=\"bold\"\n)\nax.legend(fontsize=11, loc=\"upper left\")\nax.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.savefig(\n    str(output_dir / part_dirs[\"part6\"] / \"neb_path.png\"), dpi=300, bbox_inches=\"tight\"\n)\nplt.show()\n\n# Create animation of NEB path\nprint(\"\\n   Creating NEB path animation...\")\nfrom ase.io import write as ase_write\n\nase.io.write(\n    str(output_dir / part_dirs[\"part6\"] / \"neb_path.gif\"), images, format=\"gif\"\n)\nprint(\"   → Saved as neb_path.gif\")\n\n# Visualize key structures\nprint(\"\\n   Visualizing initial state (C* + O*)...\")\nview(initial_c_o, viewer='x3d')\n\nprint(\"\\n   Visualizing transition state...\")\nview(images[ts_idx], viewer='x3d')\n\nprint(\"\\n   Visualizing final state (CO*)...\")\nview(final_co, viewer='x3d')\n\nprint(\"\\n✓ NEB analysis complete!\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nMissing UMA access?\n\nDon’t have access to UMA yet? You can still explore this calculation!\n\nDownload example CO on Ni(111) structure and \n\nDownload C+O on Ni(111) structure to test in the \n\nUMA demo (no login required) and explore the reaction pathway.\n\nComparison with Paper (Tables 4 & 5)\n\nExpected Results from Paper:\n\nReaction Energy (C + O → CO*)**: -142.7 kJ/mol = -1.48 eV (exothermic, DFT-D3)\n\nActivation Barrier (C + O → CO*)**: 153 kJ/mol = 1.59 eV (reverse/dissociation, DFT-D3)\n\nCO Adsorption Energy: 1.82 eV = 175.6 kJ/mol (DFT-D3)\n\nReaction Direction:\n\nPaper reports CO dissociation barrier (CO* → C* + O*), which is the reverse of the recombination we calculate\n\nForward (C* + O* → CO*): barrier = reverse_barrier - |ΔE| ≈ 1.59 - 1.48 ≈ 0.11 eV (very fast)\n\nReverse (CO* → C* + O*): barrier = 1.59 eV (very slow, kinetic bottleneck)\n\nWhat to Check:\n\nReaction energy (C*+O* → CO*) should be strongly exothermic (~-1.5 eV)\n\nReverse barrier (CO dissociation) should be substantial (~1.6 eV)\n\nForward barrier (recombination) should be very small (~0.1 eV)\n\nCO binds much more strongly than H (1.82 eV vs 0.60 eV)\n\nTypical Variations:\n\nReaction energies typically accurate within 0.1-0.2 eV\n\nBarriers more sensitive: expect ±0.2-0.3 eV variation\n\nZPE corrections typically add 0.05-0.15 eV to reaction energies\n\nNEB convergence affects barrier more than reaction energy\n\nPhysical Insight:\n\nLarge reverse barrier (1.59 eV) makes CO dissociation very slow at low T\n\nSmall forward barrier (0.11 eV) means C+O rapidly recombine to CO\n\nThis explains why Ni produces CO in Fischer-Tropsch rather than keeping C and O separate\n\nHigh temperatures needed to overcome the dissociation barrier for further C-C coupling\n\nNEB Method Explained\n\nThe Nudged Elastic Band (NEB) method finds the minimum energy path between reactants and products:\n\nInterpolate between initial and final states (5-9 images typical)\n\nAdd spring forces along the chain to maintain spacing\n\nProject out spring components perpendicular to the path\n\nClimbing image variant: highest energy image climbs to saddle point\n\nAdvantages:\n\nNo prior knowledge of transition state needed\n\nFinds entire reaction coordinate\n\nRobust for complex reactions\n\nLimitations:\n\nComputationally expensive (optimize N images)\n\nMay find wrong path if initial interpolation is poor","type":"content","url":"/uma-catalysis-tutorial#step-8-visualize-neb-path-and-key-structures","position":115},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Explore on Your Own","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"type":"lvl3","url":"/uma-catalysis-tutorial#explore-on-your-own-4","position":116},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Explore on Your Own","lvl2":"Part 6: CO Formation/Dissociation Thermochemistry and Barrier"},"content":"Image convergence: Run with 7 or 9 images. Does the barrier change?\n\nSpring constant: Modify the NEB spring constant. How does this affect convergence?\n\nAlternative paths: Try different initial CO/final C+O configurations. Are there multiple pathways?\n\nReverse barrier: Calculate E_a(reverse) = E_a(forward) - ΔE. Check Brønsted-Evans-Polanyi relationship.\n\nDiffusion barriers: Compute NEB for C or O diffusion on the surface. How do they compare?","type":"content","url":"/uma-catalysis-tutorial#explore-on-your-own-4","position":117},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl2":"Summary and Best Practices"},"type":"lvl2","url":"/uma-catalysis-tutorial#summary-and-best-practices","position":118},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl2":"Summary and Best Practices"},"content":"","type":"content","url":"/uma-catalysis-tutorial#summary-and-best-practices","position":119},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Key Takeaways","lvl2":"Summary and Best Practices"},"type":"lvl3","url":"/uma-catalysis-tutorial#key-takeaways","position":120},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Key Takeaways","lvl2":"Summary and Best Practices"},"content":"ML Potentials: UMa-S-1P1 provides ~1000× speedup over DFT with reasonable accuracy\n\nBulk optimization: Always use the ML-optimized lattice constant for consistency\n\nSurface energies: Linear extrapolation eliminates finite-size effects\n\nAdsorption: Test multiple sites; lowest energy may not be intuitive\n\nCoverage: Lateral interactions become significant above ~0.3 ML\n\nBarriers: NEB requires careful setup but yields full reaction pathway","type":"content","url":"/uma-catalysis-tutorial#key-takeaways","position":121},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Recommended Workflow for New Systems","lvl2":"Summary and Best Practices"},"type":"lvl3","url":"/uma-catalysis-tutorial#recommended-workflow-for-new-systems","position":122},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Recommended Workflow for New Systems","lvl2":"Summary and Best Practices"},"content":"Optimize Bulk - Determine equilibrium lattice constant\n\nCalculate Surface Energies - Identify stable facets\n\nWulff Construction - Predict nanoparticle morphology\n\nLow-Coverage Adsorption - Find binding sites and energies\n\nCoverage Study (if coverage-dependent effects are important) - Determine lateral interactions\n\nReaction Barriers - Calculate activation energies using NEB\n\nMicrokinetic Modeling - Predict overall catalytic performance","type":"content","url":"/uma-catalysis-tutorial#recommended-workflow-for-new-systems","position":123},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Accuracy Considerations","lvl2":"Summary and Best Practices"},"type":"lvl3","url":"/uma-catalysis-tutorial#accuracy-considerations","position":124},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Accuracy Considerations","lvl2":"Summary and Best Practices"},"content":"Property\n\nTypical Error\n\nWhen Critical\n\nLattice constants\n\n1-2%\n\nStrain effects, alloys\n\nSurface energies\n\n10-20%\n\nNanoparticle shapes\n\nAdsorption energies\n\n0.1-0.3 eV\n\nThermochemistry\n\nBarriers\n\n0.2-0.5 eV\n\nKinetics, selectivity\n\nRule of thumb: Use ML for screening → DFT for validation → Experiment for verification","type":"content","url":"/uma-catalysis-tutorial#accuracy-considerations","position":125},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Further Reading","lvl2":"Summary and Best Practices"},"type":"lvl3","url":"/uma-catalysis-tutorial#further-reading","position":126},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Further Reading","lvl2":"Summary and Best Practices"},"content":"UMA Paper: \n\nWood et al. 2025\n\nOMat24 Paper: \n\nBarroso-Luque et al., 2024\n\nOC20 Dataset: \n\nChanussot et al., ACS Catalysis, 2021\n\nASE Tutorial: \n\nhttps://​wiki​.fysik​.dtu​.dk​/ase/","type":"content","url":"/uma-catalysis-tutorial#further-reading","position":127},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl2":"Appendix: Troubleshooting"},"type":"lvl2","url":"/uma-catalysis-tutorial#appendix-troubleshooting","position":128},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl2":"Appendix: Troubleshooting"},"content":"","type":"content","url":"/uma-catalysis-tutorial#appendix-troubleshooting","position":129},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Common Issues","lvl2":"Appendix: Troubleshooting"},"type":"lvl3","url":"/uma-catalysis-tutorial#common-issues","position":130},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Common Issues","lvl2":"Appendix: Troubleshooting"},"content":"Problem: Convergence failures\n\nSolution: Reduce fmax to 0.1 initially, tighten later\n\nCheck if system is metastable (try different starting geometry)\n\nProblem: NEB fails to find transition state\n\nSolution: Use more images (9-11) or better initial guess\n\nTry fixed-end NEB first, then climbing image\n\nProblem: Unexpected adsorption energies\n\nSolution: Visualize structures - check for distortions\n\nCompare with multiple sites\n\nAdd D3 corrections\n\nProblem: Out of memory\n\nSolution: Reduce system size (smaller supercells)\n\nUse fewer NEB images\n\nRun on HPC with more RAM","type":"content","url":"/uma-catalysis-tutorial#common-issues","position":131},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Performance Tips","lvl2":"Appendix: Troubleshooting"},"type":"lvl3","url":"/uma-catalysis-tutorial#performance-tips","position":132},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"Performance Tips","lvl2":"Appendix: Troubleshooting"},"content":"Use batching: Relax multiple configurations in parallel\n\nStart with DEBUG_MAX_STEPS=50: Get quick results, refine later\n\nCache bulk energies: Don’t recalculate reference systems\n\nTrajectory analysis: Monitor optimization progress with ASE GUI","type":"content","url":"/uma-catalysis-tutorial#performance-tips","position":133},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl2":"Caveats and Pitfalls"},"type":"lvl2","url":"/uma-catalysis-tutorial#caveats-and-pitfalls","position":134},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl2":"Caveats and Pitfalls"},"content":"Important Considerations\n\nWhen using ML potentials for surface catalysis, be aware of these critical issues!","type":"content","url":"/uma-catalysis-tutorial#caveats-and-pitfalls","position":135},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"1. Task Selection: OMAT vs OC20","lvl2":"Caveats and Pitfalls"},"type":"lvl3","url":"/uma-catalysis-tutorial#id-1-task-selection-omat-vs-oc20","position":136},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"1. Task Selection: OMAT vs OC20","lvl2":"Caveats and Pitfalls"},"content":"Critical choice: Which task_name to use?\n\ntask_name=\"omat\": Optimized for bulk and clean surface calculations\n\nUse for: Part 1 (bulk), Part 2 (surface energies), Part 3 (Wulff)\n\nBetter for structural relaxations without adsorbates\n\ntask_name=\"oc20\": Optimized for surface chemistry with adsorbates\n\nUse for: Part 4-6 (all adsorbate calculations)\n\nTrained on Open Catalyst data with adsorbate-surface interactions\n\nImpact: Using wrong task can lead to 0.1-0.3 eV errors in adsorption energies!","type":"content","url":"/uma-catalysis-tutorial#id-1-task-selection-omat-vs-oc20","position":137},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"2. D3 Dispersion Corrections","lvl2":"Caveats and Pitfalls"},"type":"lvl3","url":"/uma-catalysis-tutorial#id-2-d3-dispersion-corrections","position":138},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"2. D3 Dispersion Corrections","lvl2":"Caveats and Pitfalls"},"content":"Multiple decisions required:\n\nWhether to use D3 at all?\n\nSmall adsorbates (H, O, N): D3 effect ~0.01-0.05 eV (often negligible)\n\nLarge molecules (CO, CO₂, aromatics): D3 effect ~0.1-0.3 eV (important!)\n\nPhysisorption: D3 critical (can change binding from repulsive to attractive)\n\nRPBE was originally fit for chemisorption energies without D3 corrections, so adding D3 corrections may actually cause small adsorbates to overbind. However, it probably would be important for larger molecules. It’s relatively uncommon to see RPBE+D3 as a choice in the catalysis literature (compared to PBE+D3, or RPBE, or BEEF-vdW).\n\nWhich DFT functional for D3?\n\nThis tutorial uses method=\"PBE\" consistently for the D3 correction. This is often implied when papers say they use a D3 correction, but the results can be different if use the RPBE parameterizations.\n\nOriginal paper used PBE for bulk/surfaces, RPBE for adsorption. It’s not specified what D3 parameterization they used, but it’s likely PBE.\n\nWhen to apply D3?\n\nEnd-point correction (used here): Fast, run ML optimization then add D3 energy\n\nDuring optimization: Slower but more accurate geometries\n\nImpact: Usually <0.05 eV difference, but can be larger for weak interactions","type":"content","url":"/uma-catalysis-tutorial#id-2-d3-dispersion-corrections","position":139},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"3. Coverage Dependence Challenges","lvl2":"Caveats and Pitfalls"},"type":"lvl3","url":"/uma-catalysis-tutorial#id-3-coverage-dependence-challenges","position":140},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"3. Coverage Dependence Challenges","lvl2":"Caveats and Pitfalls"},"content":"Non-linearity at high coverage:\n\nThis tutorial assumes linear E_ads(θ) = E₀ + βθ\n\nReality: Often non-linear, especially near θ = 1 ML. See the plots generated - there is a linear regime for relatively high coverage, and relatively low coverage, but it’s not uniformly linear everywhere. As long as you consistently in one regime or the other a linear assumption is probably ok, but you could get into problems if solving microkinetic models where the coverage of the species in question changes significantly from very low to high.\n\nWhy: Phase transitions, adsorbate ordering, surface reconstruction\n\nSolution: Test polynomial fits, look for ordering in visualizations\n\nLow coverage limit:\n\nAt θ < 0.1 ML, coverage effects are tiny (<0.01 eV)\n\nHard to distinguish from numerical noise\n\nBest practice: Focus on 0.25-1.0 ML range for fitting","type":"content","url":"/uma-catalysis-tutorial#id-3-coverage-dependence-challenges","position":141},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"4. Periodic Boundary Conditions","lvl2":"Caveats and Pitfalls"},"type":"lvl3","url":"/uma-catalysis-tutorial#id-4-periodic-boundary-conditions","position":142},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"4. Periodic Boundary Conditions","lvl2":"Caveats and Pitfalls"},"content":"UMa requires PBC=True in all directions!atoms.set_pbc([True, True, True])  # Always required\n\nForgetting this causes crashes or wrong energies\n\nEven for “gas phase” molecules in vacuum","type":"content","url":"/uma-catalysis-tutorial#id-4-periodic-boundary-conditions","position":143},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"5. Gas Phase Reference Energies","lvl2":"Caveats and Pitfalls"},"type":"lvl3","url":"/uma-catalysis-tutorial#id-5-gas-phase-reference-energies","position":144},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"5. Gas Phase Reference Energies","lvl2":"Caveats and Pitfalls"},"content":"Tricky cases:\n\nH₂(g): UMa handles well (used in this tutorial)\n\nH(g): May not be reliable (use H₂/2 instead)\n\nCO(g), O₂(g): Usually okay, but check against DFT\n\nRadicals: Often problematic\n\nBest practice: Always use stable molecules as references (H₂, not H; H₂O, not OH)","type":"content","url":"/uma-catalysis-tutorial#id-5-gas-phase-reference-energies","position":145},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"6. Spin Polarization","lvl2":"Caveats and Pitfalls"},"type":"lvl3","url":"/uma-catalysis-tutorial#id-6-spin-polarization","position":146},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"6. Spin Polarization","lvl2":"Caveats and Pitfalls"},"content":"Key limitation: OC20/UMa does not include spin!\n\nPaper used spin-polarized DFT\n\nImpact: Usually small (0.05-0.1 eV)\n\nLarger for:\n\nMagnetic metals (Fe, Co, Ni)\n\nOpen-shell adsorbates (O*, OH*)\n\nReaction barriers with radicals","type":"content","url":"/uma-catalysis-tutorial#id-6-spin-polarization","position":147},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"7. Constraint Philosophy","lvl2":"Caveats and Pitfalls"},"type":"lvl3","url":"/uma-catalysis-tutorial#id-7-constraint-philosophy","position":148},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"7. Constraint Philosophy","lvl2":"Caveats and Pitfalls"},"content":"Clean slabs (Part 2): No constraints (both surfaces relax)\n\nBest for surface energy calculations\n\nMore physical for symmetric slabs\n\nAdsorbate slabs (Part 4-6): Bottom layers fixed\n\nFaster convergence\n\nPrevents adsorbate-induced reconstruction\n\nStandard practice in surface chemistry\n\nFairchem helper functions: Automatically apply sensible constraints\n\nTrust their heuristics unless you have good reason not to\n\nCheck atoms.constraints to see what was applied","type":"content","url":"/uma-catalysis-tutorial#id-7-constraint-philosophy","position":149},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"8. Complex Surface Structures","lvl2":"Caveats and Pitfalls"},"type":"lvl3","url":"/uma-catalysis-tutorial#id-8-complex-surface-structures","position":150},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"8. Complex Surface Structures","lvl2":"Caveats and Pitfalls"},"content":"This tutorial uses low-index facets (111, 100, 110, 211)\n\nWell-defined, symmetric\n\nEasy to generate and analyze\n\nReal catalysts have:\n\nSteps, kinks, grain boundaries\n\nSupport interfaces\n\nDefects and vacancies\n\nChallenge: Harder to generate, more configurations to test","type":"content","url":"/uma-catalysis-tutorial#id-8-complex-surface-structures","position":151},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"9. Slab Thickness and Vacuum","lvl2":"Caveats and Pitfalls"},"type":"lvl3","url":"/uma-catalysis-tutorial#id-9-slab-thickness-and-vacuum","position":152},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"9. Slab Thickness and Vacuum","lvl2":"Caveats and Pitfalls"},"content":"Convergence tests critical but expensive:\n\nThis tutorial uses “reasonable” values (4-8 layers, 10 Å vacuum)\n\nAlways check convergence for new systems\n\nEspecially important for:\n\nMetals with long electron screening (Au, Ag)\n\nCharged adsorbates\n\nStrong adsorbate-induced reconstruction","type":"content","url":"/uma-catalysis-tutorial#id-9-slab-thickness-and-vacuum","position":153},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"10. NEB Convergence","lvl2":"Caveats and Pitfalls"},"type":"lvl3","url":"/uma-catalysis-tutorial#id-10-neb-convergence","position":154},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"10. NEB Convergence","lvl2":"Caveats and Pitfalls"},"content":"Most computationally expensive part:\n\nMay need 7-11 images (not just 5)\n\nInitial guess matters a lot\n\nCan get stuck in local minima\n\nTricks:\n\nUse dimer method to find better TS guess (as shown in Part 6)\n\nStart with coarse convergence (fmax=0.2), refine later\n\nVisualize the path - does it make chemical sense?\n\nTry different spring constants (0.1-1.0 eV/Å)","type":"content","url":"/uma-catalysis-tutorial#id-10-neb-convergence","position":155},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"11. Lattice Constant Source","lvl2":"Caveats and Pitfalls"},"type":"lvl3","url":"/uma-catalysis-tutorial#id-11-lattice-constant-source","position":156},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"11. Lattice Constant Source","lvl2":"Caveats and Pitfalls"},"content":"Consistency is key:\n\nUse ML-optimized lattice constant throughout (as done here)\n\nDon’t mix: ML lattice + DFT surface energies = inconsistent\n\nAlternative: Use experimental lattice constant for everything","type":"content","url":"/uma-catalysis-tutorial#id-11-lattice-constant-source","position":157},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"12. Adsorbate Placement","lvl2":"Caveats and Pitfalls"},"type":"lvl3","url":"/uma-catalysis-tutorial#id-12-adsorbate-placement","position":158},{"hierarchy":{"lvl1":"UMA Catalysis Tutorial","lvl3":"12. Adsorbate Placement","lvl2":"Caveats and Pitfalls"},"content":"Multiple local minima:\n\nSurface chemistry is not convex!\n\nAlways test multiple adsorption sites\n\nFairchem helpers generate ~5 configurations in this tutorial, but you may need more to search many modes. You can already try methods like minima hopping or other global optimization methods to sample more configurations.\n\nFor complex adsorbates:\n\nTest different orientations\n\nMay need 10-20 configurations\n\nConsider genetic algorithms or basin hopping\n\nCongratulations! 🎉\n\nYou’ve completed a comprehensive computational catalysis workflow using state-of-the-art ML potentials. You can now:\n\nCharacterize catalyst surfaces computationally\n\nPredict nanoparticle shapes\n\nCalculate reaction thermodynamics and kinetics\n\nApply these methods to your own research questions\n\nNext steps:\n\nApply to your catalyst system of interest\n\nValidate key results with DFT\n\nDevelop microkinetic models\n\nPublish your findings!","type":"content","url":"/uma-catalysis-tutorial#id-12-adsorbate-placement","position":159},{"hierarchy":{"lvl1":"UMA Intro Tutorial"},"type":"lvl1","url":"/uma-tutorial","position":0},{"hierarchy":{"lvl1":"UMA Intro Tutorial"},"content":"Learning Objectives\n\nBy the end of this tutorial, you will be able to:\n\nSet up and configure UMA models with HuggingFace authentication\n\nUse the FAIRChemCalculator with different task names (omol, oc20, omat)\n\nPerform molecular energy calculations including spin states\n\nRun adsorbate relaxations on catalyst surfaces\n\nExecute bulk relaxations with cell optimization\n\nConduct molecular dynamics simulations\n\nCalculate adsorption energies with proper reference energies\n\nCompute molecular vibrations and phonon spectra\n\nSet up and run transition state calculations (NEBs)\n\nThis tutorial will walk you through a few examples of how you can use UMA. Each step is covered in more detail elsewhere in the documentation, but this is well suited to a ~1-2 hour tutorial session for researchers new to UMA but with some background in ASE and molecular simulations.","type":"content","url":"/uma-tutorial","position":1},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl2":"Before you start / installation"},"type":"lvl2","url":"/uma-tutorial#before-you-start-installation","position":2},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl2":"Before you start / installation"},"content":"You need to get a HuggingFace account and request access to the UMA models.\n\nYou need a Huggingface account, request access to \n\nhttps://​huggingface​.co​/facebook​/UMA, and to create a Huggingface token at \n\nhttps://​huggingface​.co​/settings​/tokens/ with these permission:\n\nPermissions: Read access to contents of all public gated repos you can access\n\nThen, add the token as an environment variable (using huggingface-cli login:\n\n# Enter token via huggingface-cli\n! huggingface-cli login\n\n\n\nor you can set the token via HF_TOKEN variable:\n\n# Set token via env variable\nimport os\nos.environ['HF_TOKEN'] = 'MYTOKEN'\n\n\n\n","type":"content","url":"/uma-tutorial#before-you-start-installation","position":3},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"Installation process","lvl2":"Before you start / installation"},"type":"lvl3","url":"/uma-tutorial#installation-process","position":4},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"Installation process","lvl2":"Before you start / installation"},"content":"It may be enough to use pip install fairchem-core. This gets you the latest version on PyPi (\n\nhttps://​pypi​.org​/project​/fairchem​-core/)\n\nHere we install some sub-packages. This can take 2-5 minutes to run.\n\n! pip install fairchem-core fairchem-data-oc fairchem-applications-cattsunami x3dase\n\n\n\n# Check that packages are installed\n!pip list | grep fairchem\n\n\n\nimport fairchem.core\n\nfairchem.core.__version__\n\n\n\n","type":"content","url":"/uma-tutorial#installation-process","position":5},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl2":"Illustrative examples"},"type":"lvl2","url":"/uma-tutorial#illustrative-examples","position":6},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl2":"Illustrative examples"},"content":"These should just run, and are here to show some basic uses.\n\nCritical Points\n\nWhen using UMA, remember these key steps:\n\nCreate a calculator using pretrained_mlip.get_predict_unit()\n\nSpecify the appropriate task_name for your system (omol, oc20, omat, odac, omc)\n\nUse the calculator like any other ASE calculator","type":"content","url":"/uma-tutorial#illustrative-examples","position":7},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"Spin gap energy - OMOL","lvl2":"Illustrative examples"},"type":"lvl3","url":"/uma-tutorial#spin-gap-energy-omol","position":8},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"Spin gap energy - OMOL","lvl2":"Illustrative examples"},"content":"This is the difference in energy between a triplet and single ground state for a CH2 radical. This downloads a ~1GB checkpoint the first time you run it.\n\nOMOL Task Requirements\n\nFor molecular calculations with the omol task, you must set spin and charge in atoms.info:atoms.info.update({\"spin\": 1, \"charge\": 0})\n\nSpin is the multiplicity (1 for singlet, 2 for doublet, 3 for triplet, etc.).\n\nWe don’t set a device here, so we get a warning about using a CPU device. You can ignore that. If a CUDA environment is available, a GPU may be used to speed up the calculations.\n\nfrom fairchem.core import FAIRChemCalculator, pretrained_mlip\n\npredictor = pretrained_mlip.get_predict_unit(\"uma-s-1\")\n\n\n\nfrom ase.build import molecule\n\n#  singlet CH2\nsinglet = molecule(\"CH2_s1A1d\")\nsinglet.info.update({\"spin\": 1, \"charge\": 0})\nsinglet.calc = FAIRChemCalculator(predictor, task_name=\"omol\")\n\n#  triplet CH2\ntriplet = molecule(\"CH2_s3B1d\")\ntriplet.info.update({\"spin\": 3, \"charge\": 0})\ntriplet.calc = FAIRChemCalculator(predictor, task_name=\"omol\")\n\nprint(triplet.get_potential_energy() - singlet.get_potential_energy())\n\n\n\n","type":"content","url":"/uma-tutorial#spin-gap-energy-omol","position":9},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"Example of adsorbate relaxation - OC20","lvl2":"Illustrative examples"},"type":"lvl3","url":"/uma-tutorial#example-of-adsorbate-relaxation-oc20","position":10},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"Example of adsorbate relaxation - OC20","lvl2":"Illustrative examples"},"content":"Here we just setup a Cu(100) slab with a CO on it and relax it.\n\nNote\n\nThis is an OC20 task because it involves a slab with an adsorbate. The OC20 task is trained specifically for heterogeneous catalysis systems and understands the surface-adsorbate interaction.\n\nWe specify an explicit device in the predictor here, and avoid the warning.\n\nfrom ase.build import add_adsorbate, fcc100, molecule\nfrom ase.optimize import LBFGS\nfrom fairchem.core import FAIRChemCalculator, pretrained_mlip\n\npredictor = pretrained_mlip.get_predict_unit(\"uma-s-1\")\ncalc = FAIRChemCalculator(predictor, task_name=\"oc20\")\n\n# Set up your system as an ASE atoms object\nslab = fcc100(\"Cu\", (3, 3, 3), vacuum=8, periodic=True)\n\nadsorbate = molecule(\"CO\")\nadd_adsorbate(slab, adsorbate, 2.0, \"bridge\")\nslab.calc = calc\n\n# Set up LBFGS dynamics object\nopt = LBFGS(slab)\nopt.run(0.05, 100)\nprint(slab.get_potential_energy())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/uma-tutorial#example-of-adsorbate-relaxation-oc20","position":11},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl2":"Example bulk relaxation - OMAT"},"type":"lvl2","url":"/uma-tutorial#example-bulk-relaxation-omat","position":12},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl2":"Example bulk relaxation - OMAT"},"content":"OMAT Task for Bulk Materials\n\nThe omat task is trained on bulk inorganic materials and supports stress tensor predictions, enabling cell optimization with filters like FrechetCellFilter. This is essential for finding equilibrium lattice constants.\n\nfrom ase.build import bulk\nfrom ase.filters import FrechetCellFilter\nfrom ase.optimize import FIRE\nfrom fairchem.core import FAIRChemCalculator, pretrained_mlip\n\npredictor = pretrained_mlip.get_predict_unit(\"uma-s-1\")\ncalc = FAIRChemCalculator(predictor, task_name=\"omat\")\n\natoms = bulk(\"Fe\")\natoms.calc = calc\n\nopt = FIRE(FrechetCellFilter(atoms))\nopt.run(0.05, 100)\n\nprint(atoms.get_stress())  # !!!! We get stress now!\n\n\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/uma-tutorial#example-bulk-relaxation-omat","position":13},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"Molecular dynamics - OMOL","lvl2":"Example bulk relaxation - OMAT"},"type":"lvl3","url":"/uma-tutorial#molecular-dynamics-omol","position":14},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"Molecular dynamics - OMOL","lvl2":"Example bulk relaxation - OMAT"},"content":"\n\nimport matplotlib.pyplot as plt\n\nfrom ase import units\nfrom ase.build import molecule\nfrom ase.io import Trajectory\nfrom ase.md.langevin import Langevin\nfrom fairchem.core import FAIRChemCalculator, pretrained_mlip\n\npredictor = pretrained_mlip.get_predict_unit(\"uma-s-1\")\ncalc = FAIRChemCalculator(predictor, task_name=\"omol\")\n\natoms = molecule(\"H2O\")\natoms.info.update(charge=0, spin=1)  # For omol\n\natoms.calc = calc\n\ndyn = Langevin(\n    atoms,\n    timestep=0.1 * units.fs,\n    temperature_K=400,\n    friction=0.001 / units.fs,\n)\n\ntrajectory = Trajectory(\"my_md.traj\", \"w\", atoms)\ndyn.attach(trajectory.write, interval=1)\ndyn.run(steps=50)\n\n# See some results - not paper ready!\ntraj = Trajectory(\"my_md.traj\")\nplt.plot(\n    [i * 0.1 * units.fs for i in range(len(traj))],\n    [a.get_potential_energy() for a in traj],\n)\nplt.xlabel(\"Time (fs)\")\nplt.ylabel(\"Energy (eV)\");\n\n\n\n\n\n","type":"content","url":"/uma-tutorial#molecular-dynamics-omol","position":15},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl2":"Catalyst Adsorption energies"},"type":"lvl2","url":"/uma-tutorial#catalyst-adsorption-energies","position":16},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl2":"Catalyst Adsorption energies"},"content":"The basic approach in computing an adsorption energy is to compute this energy difference:dH = E_adslab - E_slab - E_ads\n\nWe use UMA for two of these energies E_adslab and E_slab. For E_ads We have to do something a little different. The OC20 task is not trained for molecules or molecular fragments. We use atomic energy reference energies instead.  These are tabulated below.\n\nThe OC20 reference scheme is this reaction:x CO + (x + y/2 - z) H2 + (z-x) H2O + w/2 N2 + * -> CxHyOzNw*  \n\nFor this example we have-H2 + H2O + * -> O*.   \"O\": -7.204 eV\n\nWhere \"O\": -7.204 is a constant.\n\nTo get the desired reaction energy we want we add the formation energy of water. We use either DFT or experimental values for this reaction energy.1/2O2 + H2 -> H2O\n\nAlternatives to this approach are using DFT to estimate the energy of 1/2 O2, just make sure to use consistent settings with your task. You should not use OMOL for this.\n\nfrom ase.build import add_adsorbate, fcc111\nfrom ase.optimize import BFGS\nfrom fairchem.core import FAIRChemCalculator, pretrained_mlip\n\npredictor = pretrained_mlip.get_predict_unit(\"uma-s-1\")\ncalc = FAIRChemCalculator(predictor, task_name=\"oc20\")\n\n\n\n# reference energies from a linear combination of H2O/N2/CO/H2!\natomic_reference_energies = {\n    \"H\": -3.477,\n    \"N\": -8.083,\n    \"O\": -7.204,\n    \"C\": -7.282,\n}\n\nre1 = -3.03  # Water formation energy from experiment\n\nslab = fcc111(\"Pt\", size=(2, 2, 5), vacuum=20.0)\nslab.pbc = True\n\nadslab = slab.copy()\nadd_adsorbate(adslab, \"O\", height=1.2, position=\"fcc\")\n\nslab.calc = calc\nopt = BFGS(slab)\nprint(\"Relaxing slab\")\nopt.run(fmax=0.05, steps=100)\nslab_e = slab.get_potential_energy()\n\nadslab.calc = calc\nopt = BFGS(adslab)\nprint(\"\\nRelaxing adslab\")\nopt.run(fmax=0.05, steps=100)\nadslab_e = adslab.get_potential_energy()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNow we compute the adsorption energy.\n\n# Energy for ((H2O-H2) + * -> *O) + (H2 + 1/2O2 -> H2O) leads to 1/2O2 + * -> *O!\nadslab_e - slab_e - atomic_reference_energies[\"O\"] + re1\n\n\n\nHow did we do? We need a reference point. In the paper below, there is an atomic adsorption energy for O on Pt(111) of about -4.264 eV. This is for the reaction O + * -> O*. To convert this to the dissociative adsorption energy, we have to add the reaction:1/2 O2 -> O   D = 2.58 eV (expt)\n\nto get a comparable energy of about -1.68 eV. There is about ~0.2 eV difference (we predicted -1.47 eV above, and the reference comparison is -1.68 eV) to account for. The biggest difference is likely due to the differences in exchange-correlation functional. The reference data used the PBE functional, and eSCN was trained on RPBE data. To additional places where there are differences include:\n\nDifference in lattice constant\n\nThe reference energy used for the experiment references. These can differ by up to 0.5 eV from comparable DFT calculations.\n\nHow many layers are relaxed in the calculation\n\nSome of these differences tend to be systematic, and you can calibrate and correct these, especially if you can augment these with your own DFT calculations.\n\nIt is always a good idea to visualize the geometries to make sure they look reasonable.\n\nimport matplotlib.pyplot as plt\nfrom ase.visualize.plot import plot_atoms\n\nfig, axs = plt.subplots(1, 2)\nplot_atoms(slab, axs[0])\nplot_atoms(slab, axs[1], rotation=(\"-90x\"))\naxs[0].set_axis_off()\naxs[1].set_axis_off()\n\n\n\nfig, axs = plt.subplots(1, 2)\nplot_atoms(adslab, axs[0])\nplot_atoms(adslab, axs[1], rotation=(\"-90x\"))\naxs[0].set_axis_off()\naxs[1].set_axis_off()\n\n\n\n","type":"content","url":"/uma-tutorial#catalyst-adsorption-energies","position":17},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl2":"Molecular vibrations"},"type":"lvl2","url":"/uma-tutorial#molecular-vibrations","position":18},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl2":"Molecular vibrations"},"content":"\n\nfrom ase import Atoms\nfrom ase.optimize import BFGS\n\npredictor = pretrained_mlip.get_predict_unit(\"uma-s-1\")\ncalc = FAIRChemCalculator(predictor, task_name=\"omol\")\n\nfrom ase.vibrations import Vibrations\n\nn2 = Atoms(\"N2\", [(0, 0, 0), (0, 0, 1.1)])\nn2.info.update({\"spin\": 1, \"charge\": 0})\nn2.calc = calc\n\nBFGS(n2).run(fmax=0.01)\n\n\n\n\n\n\n\n\n\nvib = Vibrations(n2)\nvib.run()\nvib.summary()\n\n\n\n","type":"content","url":"/uma-tutorial#molecular-vibrations","position":19},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl2":"Bulk alloy phase behavior"},"type":"lvl2","url":"/uma-tutorial#bulk-alloy-phase-behavior","position":20},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl2":"Bulk alloy phase behavior"},"content":"Adapted from \n\nhttps://​kitchingroup​.cheme​.cmu​.edu​/dft​-book​/dft​.html​#orgheadline29\n\nWe manually compute the formation energy of pure compounds and some alloy compositions to assess stability.\n\nfrom ase.atoms import Atom, Atoms\nfrom ase.filters import FrechetCellFilter\nfrom ase.optimize import FIRE\nfrom fairchem.core import FAIRChemCalculator, pretrained_mlip\n\npredictor = pretrained_mlip.get_predict_unit(\"uma-s-1\")\n\ncu = Atoms(\n    [Atom(\"Cu\", [0.000, 0.000, 0.000])],\n    cell=[[1.818, 0.000, 1.818], [1.818, 1.818, 0.000], [0.000, 1.818, 1.818]],\n    pbc=True,\n)\ncu.calc = FAIRChemCalculator(predictor, task_name=\"omat\")\n\nopt = FIRE(FrechetCellFilter(cu))\nopt.run(0.05, 100)\n\ncu.get_potential_energy()\n\n\n\n\n\n\n\n\n\n\n\npd = Atoms(\n    [Atom(\"Pd\", [0.000, 0.000, 0.000])],\n    cell=[[1.978, 0.000, 1.978], [1.978, 1.978, 0.000], [0.000, 1.978, 1.978]],\n    pbc=True,\n)\npd.calc = FAIRChemCalculator(predictor, task_name=\"omat\")\n\nopt = FIRE(FrechetCellFilter(pd))\nopt.run(0.05, 100)\n\npd.get_potential_energy()\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/uma-tutorial#bulk-alloy-phase-behavior","position":21},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"Alloy formation energies","lvl2":"Bulk alloy phase behavior"},"type":"lvl3","url":"/uma-tutorial#alloy-formation-energies","position":22},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"Alloy formation energies","lvl2":"Bulk alloy phase behavior"},"content":"\n\ncupd1 = Atoms(\n    [Atom(\"Cu\", [0.000, 0.000, 0.000]), Atom(\"Pd\", [-1.652, 0.000, 2.039])],\n    cell=[[0.000, -2.039, 2.039], [0.000, 2.039, 2.039], [-3.303, 0.000, 0.000]],\n    pbc=True,\n)  # Note pbc=True is important, it is not the default and OMAT\n\ncupd1.calc = FAIRChemCalculator(predictor, task_name=\"omat\")\n\nopt = FIRE(FrechetCellFilter(cupd1))\nopt.run(0.05, 100)\n\ncupd1.get_potential_energy()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncupd2 = Atoms(\n    [\n        Atom(\"Cu\", [-0.049, 0.049, 0.049]),\n        Atom(\"Cu\", [-11.170, 11.170, 11.170]),\n        Atom(\"Pd\", [-7.415, 7.415, 7.415]),\n        Atom(\"Pd\", [-3.804, 3.804, 3.804]),\n    ],\n    cell=[[-5.629, 3.701, 5.629], [-3.701, 5.629, 5.629], [-5.629, 5.629, 3.701]],\n    pbc=True,\n)\ncupd2.calc = FAIRChemCalculator(predictor, task_name=\"omat\")\n\nopt = FIRE(FrechetCellFilter(cupd2))\nopt.run(0.05, 100)\n\ncupd2.get_potential_energy()\n\n\n\n\n\n\n\n\n\n\n\n# Delta Hf cupd-1 = -0.11 eV/atom\nhf1 = (\n    cupd1.get_potential_energy() - cu.get_potential_energy() - pd.get_potential_energy()\n)\nhf1\n\n\n\n# DFT: Delta Hf cupd-2 = -0.04 eV/atom\nhf2 = (\n    cupd2.get_potential_energy()\n    - 2 * cu.get_potential_energy()\n    - 2 * pd.get_potential_energy()\n)\nhf2\n\n\n\nhf1 - hf2, (-0.11 - -0.04)\n\n\n\nThese indicate that cupd-1 and cupd-2 are both more stable than phase separated Cu and Pd, and that cupd-1 is more stable than cupd-2. The absolute formation energies differ from the DFT references, but the relative differences are quite close. The absolute differences could be due to DFT parameter choices (XC, psp, etc.).","type":"content","url":"/uma-tutorial#alloy-formation-energies","position":23},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"Phonon calculation","lvl2":"Bulk alloy phase behavior"},"type":"lvl3","url":"/uma-tutorial#phonon-calculation","position":24},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"Phonon calculation","lvl2":"Bulk alloy phase behavior"},"content":"This takes 4-10 minutes. Adapted from \n\nhttps://​wiki​.fysik​.dtu​.dk​/ase​/ase​/phonons​.html​#example.\n\nPhonons have applications in computing the stability and free energy of solids. See:\n\nhttps://​www​.sciencedirect​.com​/science​/article​/pii​/S1359646215003127\n\nhttps://​iopscience​.iop​.org​/book​/mono​/978​-0​-7503​-2572​-1​/chapter​/bk978​-0​-7503​-2572​-1ch1\n\nfrom ase.build import bulk\nfrom ase.phonons import Phonons\n\npredictor = pretrained_mlip.get_predict_unit(\"uma-s-1\")\ncalc = FAIRChemCalculator(predictor, task_name=\"omat\")\n\n# Setup crystal\natoms = bulk(\"Al\", \"fcc\", a=4.05)\n\n# Phonon calculator\nN = 7\nph = Phonons(atoms, calc, supercell=(N, N, N), delta=0.05)\nph.run()\n\n# Read forces and assemble the dynamical matrix\nph.read(acoustic=True)\nph.clean()\n\npath = atoms.cell.bandpath(\"GXULGK\", npoints=100)\nbs = ph.get_band_structure(path)\n\ndos = ph.get_dos(kpts=(20, 20, 20)).sample_grid(npts=100, width=1e-3)\n\n\n\n\n\n# Plot the band structure and DOS:\nimport matplotlib.pyplot as plt  # noqa\n\nfig = plt.figure(figsize=(7, 4))\nax = fig.add_axes([0.12, 0.07, 0.67, 0.85])\n\nemax = 0.04\nbs.plot(ax=ax, emin=0.0, emax=emax)\n\ndosax = fig.add_axes([0.8, 0.07, 0.17, 0.85])\ndosax.fill_between(\n    dos.get_weights(),\n    dos.get_energies(),\n    y2=0,\n    color=\"grey\",\n    edgecolor=\"k\",\n    lw=1,\n)\n\ndosax.set_ylim(0, emax)\ndosax.set_yticks([])\ndosax.set_xticks([])\ndosax.set_xlabel(\"DOS\", fontsize=18);\n\n\n\n","type":"content","url":"/uma-tutorial#phonon-calculation","position":25},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl2":"Transition States (NEBs)"},"type":"lvl2","url":"/uma-tutorial#transition-states-nebs","position":26},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl2":"Transition States (NEBs)"},"content":"Nudged elastic band calculations are among the most costly calculations we do. UMA makes these quicker!\n\nNEB Workflow\n\nThe standard workflow for transition state calculations:\n\nGet and relax the initial state\n\nGet and relax the final state\n\nConstruct band and interpolate the images\n\nRelax the band\n\nAnalyze and plot the band\n\nWe explore diffusion of an O adatom from an hcp to an fcc site on Pt(111).","type":"content","url":"/uma-tutorial#transition-states-nebs","position":27},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"Initial state","lvl2":"Transition States (NEBs)"},"type":"lvl3","url":"/uma-tutorial#initial-state","position":28},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"Initial state","lvl2":"Transition States (NEBs)"},"content":"\n\nfrom ase.build import add_adsorbate, fcc111, molecule\nfrom ase.optimize import LBFGS\nfrom fairchem.core import FAIRChemCalculator, pretrained_mlip\n\npredictor = pretrained_mlip.get_predict_unit(\"uma-s-1\")\ncalc = FAIRChemCalculator(predictor, task_name=\"oc20\")\n\n# Set up your system as an ASE atoms object\ninitial = fcc111(\"Pt\", (3, 3, 3), vacuum=8, periodic=True)\n\nadsorbate = molecule(\"O\")\nadd_adsorbate(initial, adsorbate, 2.0, \"fcc\")\ninitial.calc = calc\n\n# Set up LBFGS dynamics object\nopt = LBFGS(initial)\nopt.run(0.05, 100)\nprint(initial.get_potential_energy())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/uma-tutorial#initial-state","position":29},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"Final state","lvl2":"Transition States (NEBs)"},"type":"lvl3","url":"/uma-tutorial#final-state","position":30},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"Final state","lvl2":"Transition States (NEBs)"},"content":"\n\n# Set up your system as an ASE atoms object\nfinal = fcc111(\"Pt\", (3, 3, 3), vacuum=8, periodic=True)\n\nadsorbate = molecule(\"O\")\nadd_adsorbate(final, adsorbate, 2.0, \"hcp\")\nfinal.calc = FAIRChemCalculator(predictor, task_name=\"oc20\")\n\n# Set up LBFGS dynamics object\nopt = LBFGS(final)\nopt.run(0.05, 100)\nprint(final.get_potential_energy())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/uma-tutorial#final-state","position":31},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"Setup and relax the band","lvl2":"Transition States (NEBs)"},"type":"lvl3","url":"/uma-tutorial#setup-and-relax-the-band","position":32},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"Setup and relax the band","lvl2":"Transition States (NEBs)"},"content":"\n\nfrom ase.mep import NEB\n\nimages = [initial]\nfor i in range(3):\n    image = initial.copy()\n    image.calc = FAIRChemCalculator(predictor, task_name=\"oc20\")\n    images.append(image)\n\nimages.append(final)\n\n\nneb = NEB(images)\nneb.interpolate()\n\nopt = LBFGS(neb, trajectory=\"neb.traj\")\nopt.run(0.05, 100)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom ase.mep import NEBTools\n\nNEBTools(neb.images).plot_band();\n\n\n\nThis could be a good initial guess to initialize an NEB in DFT.","type":"content","url":"/uma-tutorial#setup-and-relax-the-band","position":33},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl2":"Ideas for things you can do with UMA"},"type":"lvl2","url":"/uma-tutorial#ideas-for-things-you-can-do-with-uma","position":34},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl2":"Ideas for things you can do with UMA"},"content":"Further Reading\n\nHere are some research papers demonstrating advanced UMA applications:\n\nFineTuna - Use it for initial geometry optimizations then do DFT\n\nDOI: 10.1088/2632-2153/ac8fe0\n\nDOI: 10.1088/2632-2153/ad37f0\n\nAdsorbML - Prescreen adsorption sites to find relevant ones\n\nNature Computational Science (2023)\n\nCatTsunami - Screen NEBs more thoroughly\n\nACS Catalysis (2024)\n\nFree energy estimations - Compute vibrational modes for entropy\n\nJ. Phys. Chem. C (2024)\n\nMassive screening - 685M relaxations of catalyst surfaces\n\narXiv:2411.11783","type":"content","url":"/uma-tutorial#ideas-for-things-you-can-do-with-uma","position":35},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl2":"Advanced applications"},"type":"lvl2","url":"/uma-tutorial#advanced-applications","position":36},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl2":"Advanced applications"},"content":"These take a while to run.","type":"content","url":"/uma-tutorial#advanced-applications","position":37},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"AdsorbML","lvl2":"Advanced applications"},"type":"lvl3","url":"/uma-tutorial#adsorbml","position":38},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"AdsorbML","lvl2":"Advanced applications"},"content":"It is so cheap to run these calculations that we can screen a broad range of adsorbate sites and rank them in stability. The AdsorbML approach automates this. This takes quite a while to run here, and we don’t do it in the workshop.","type":"content","url":"/uma-tutorial#adsorbml","position":39},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"Expert adsorption energies","lvl2":"Advanced applications"},"type":"lvl3","url":"/uma-tutorial#expert-adsorption-energies","position":40},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"Expert adsorption energies","lvl2":"Advanced applications"},"content":"This tutorial reproduces Fig 6b from the following paper: Zhou, Jing, et al. “Enhanced Catalytic Activity of Bimetallic Ordered Catalysts for Nitrogen Reduction Reaction by Perturbation of Scaling Relations.” ACS Catalysis 134 (2023): 2190-2201 (\n\nZhou et al. (2023)).\n\nThis takes up to an hour with a GPU, and much longer with a CPU.","type":"content","url":"/uma-tutorial#expert-adsorption-energies","position":41},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"CatTsunami","lvl2":"Advanced applications"},"type":"lvl3","url":"/uma-tutorial#cattsunami","position":42},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"CatTsunami","lvl2":"Advanced applications"},"content":"The CatTsunami tutorial is an example of enumerating initial and final states, and computing reaction paths between them with UMA.","type":"content","url":"/uma-tutorial#cattsunami","position":43},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"Acknowledgements","lvl2":"Advanced applications"},"type":"lvl3","url":"/uma-tutorial#acknowledgements","position":44},{"hierarchy":{"lvl1":"UMA Intro Tutorial","lvl3":"Acknowledgements","lvl2":"Advanced applications"},"content":"This tutorial was originally compiled by John Kitchin (CMU) for the NAM29 catalysis tutorial session, using a variety of resources from the FAIR chemistry repository.","type":"content","url":"/uma-tutorial#acknowledgements","position":45},{"hierarchy":{"lvl1":"Technical Presentations"},"type":"lvl1","url":"/technical-talks","position":0},{"hierarchy":{"lvl1":"Technical Presentations"},"content":"Explore recorded technical talks and presentations from FAIRChem researchers covering the latest developments in machine learning for atomistic simulations.\n\nNote\n\nThese presentations provide in-depth coverage of FAIRChem models, datasets, and applications. They are a great resource for understanding the motivation behind our work and seeing demonstrations of the technology in action.","type":"content","url":"/technical-talks","position":1},{"hierarchy":{"lvl1":"Technical Presentations","lvl2":"Featured Talks"},"type":"lvl2","url":"/technical-talks#featured-talks","position":2},{"hierarchy":{"lvl1":"Technical Presentations","lvl2":"Featured Talks"},"content":"FAIRChem Technical Overview\n\nAn overview of the Open Catalyst Project and FAIRChem framework, covering model architectures, training strategies, and applications to catalysis.\n\nResearch Applications and Future Directions\n\nExploring research applications of FAIRChem models and future directions for machine learning in computational chemistry and materials science.","type":"content","url":"/technical-talks#featured-talks","position":3}]}