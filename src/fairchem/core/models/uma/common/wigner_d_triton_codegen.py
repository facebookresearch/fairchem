"""
Code generator for Triton Wigner D kernels.

This script generates the fully-unrolled Triton kernel code for any l value.
The generated code is optimized for maximum performance by avoiding runtime
loops and conditionals.

Usage:
    python wigner_d_triton_codegen.py --ell 3 > wigner_d_l3_kernel.py
    python wigner_d_triton_codegen.py --ell 4 > wigner_d_l4_kernel.py

Copyright (c) Meta Platforms, Inc. and affiliates.
This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.
"""

from __future__ import annotations

import argparse
from itertools import combinations_with_replacement
from typing import Iterator


def generate_monomials(degree: int) -> list[tuple[int, int, int, int]]:
    """
    Generate all monomials of given degree in 4 variables (w, x, y, z).

    Returns list of (a, b, c, d) tuples where a + b + c + d = degree,
    in lexicographic order.
    """
    monomials = []

    def generate(remaining_vars: int, remaining_deg: int, current: list[int]) -> None:
        if remaining_vars == 1:
            monomials.append(tuple(current + [remaining_deg]))
            return
        for i in range(remaining_deg + 1):
            generate(remaining_vars - 1, remaining_deg - i, current + [i])

    generate(4, degree, [])
    return monomials


def monomial_to_expr(a: int, b: int, c: int, d: int) -> str:
    """Convert monomial exponents to Python expression."""
    parts = []

    # Use precomputed powers
    if a > 0:
        parts.append(f"w{a}" if a > 1 else "w")
    if b > 0:
        parts.append(f"x{b}" if b > 1 else "x")
    if c > 0:
        parts.append(f"y{c}" if c > 1 else "y")
    if d > 0:
        parts.append(f"z{d}" if d > 1 else "z")

    if not parts:
        return "1.0"
    return " * ".join(parts)


def generate_power_computation(degree: int, indent: str = "    ") -> str:
    """Generate code to compute all needed powers of w, x, y, z."""
    lines = []

    for var in ["w", "x", "y", "z"]:
        lines.append(f"{indent}# Powers of {var}")
        if degree >= 2:
            lines.append(f"{indent}{var}2 = {var} * {var}")
        if degree >= 3:
            lines.append(f"{indent}{var}3 = {var}2 * {var}")
        if degree >= 4:
            lines.append(f"{indent}{var}4 = {var}2 * {var}2")
        if degree >= 5:
            lines.append(f"{indent}{var}5 = {var}4 * {var}")
        if degree >= 6:
            lines.append(f"{indent}{var}6 = {var}3 * {var}3")
        if degree >= 7:
            lines.append(f"{indent}{var}7 = {var}4 * {var}3")
        if degree >= 8:
            lines.append(f"{indent}{var}8 = {var}4 * {var}4")
        lines.append("")

    return "\n".join(lines)


def generate_kernel(ell: int) -> str:
    """Generate complete Triton kernel for given l value."""
    degree = 2 * ell
    monomials = generate_monomials(degree)
    n_monomials = len(monomials)
    n_outputs = (2 * ell + 1) ** 2

    # Header
    code = f'''"""
Auto-generated Triton kernel for l={ell} Wigner D computation.

Generated by wigner_d_triton_codegen.py
- Degree: {degree}
- Monomials: {n_monomials}
- Outputs: {n_outputs} ({2*ell+1}x{2*ell+1})
"""

import torch
import triton
import triton.language as tl


@triton.jit
def _wigner_d_l{ell}_kernel(
    q_ptr,              # Input: (N, 4)
    D_ptr,              # Output: (N, {n_outputs})
    C_T_ptr,            # Coefficients transposed: ({n_monomials}, {n_outputs})
    N,                  # Number of quaternions
    stride_q,           # Stride for q
    stride_d,           # Stride for D
    stride_c_row,       # Stride for C_T rows
    BLOCK_Q: tl.constexpr,
):
    """Fused Wigner D l={ell} kernel with {n_monomials} monomials."""
    pid = tl.program_id(0)

    q_start = pid * BLOCK_Q
    q_offsets = q_start + tl.arange(0, BLOCK_Q)
    q_mask = q_offsets < N

    # Load quaternion components
    w = tl.load(q_ptr + q_offsets * stride_q + 0, mask=q_mask, other=0.0)
    x = tl.load(q_ptr + q_offsets * stride_q + 1, mask=q_mask, other=0.0)
    y = tl.load(q_ptr + q_offsets * stride_q + 2, mask=q_mask, other=0.0)
    z = tl.load(q_ptr + q_offsets * stride_q + 3, mask=q_mask, other=0.0)

    # Precompute powers
'''

    # Add power computation
    code += generate_power_computation(degree)

    # Add output loop
    code += f'''
    # Compute each output element
    for out_idx in tl.static_range({n_outputs}):
        acc = tl.zeros((BLOCK_Q,), dtype=w.dtype)
        c_base = out_idx

'''

    # Add monomial accumulation - group by leading coefficient for readability
    current_a = -1
    for i, (a, b, c, d) in enumerate(monomials):
        if a != current_a:
            if current_a >= 0:
                code += "\n"
            code += f"        # a={a} monomials\n"
            current_a = a

        expr = monomial_to_expr(a, b, c, d)
        code += f"        acc += tl.load(C_T_ptr + {i} * stride_c_row + c_base) * ({expr})\n"

    # Add store
    code += f'''
        # Store result
        tl.store(D_ptr + q_offsets * stride_d + out_idx, acc, mask=q_mask)


def quaternion_to_wigner_d_l{ell}_triton(q: torch.Tensor) -> torch.Tensor:
    """
    Compute l={ell} Wigner D matrix using fused Triton kernel.

    Args:
        q: Unit quaternions of shape (N, 4) in (w, x, y, z) convention.

    Returns:
        Wigner D matrices of shape (N, {2*ell+1}, {2*ell+1}).
    """
    from fairchem.core.models.uma.common.wigner_d_triton_utils import _get_kernel_data

    N = q.shape[0]
    D_flat = torch.empty(N, {n_outputs}, dtype=q.dtype, device=q.device)

    C_T = _get_kernel_data({ell}, q.dtype, q.device)

    BLOCK_Q = 64
    grid = ((N + BLOCK_Q - 1) // BLOCK_Q,)

    _wigner_d_l{ell}_kernel[grid](
        q, D_flat, C_T, N,
        stride_q=q.stride(0),
        stride_d=D_flat.stride(0),
        stride_c_row=C_T.stride(0),
        BLOCK_Q=BLOCK_Q,
    )

    return D_flat.view(N, {2*ell+1}, {2*ell+1})
'''

    return code


def main():
    parser = argparse.ArgumentParser(description="Generate Triton Wigner D kernel")
    parser.add_argument("--ell", type=int, required=True, help="Angular momentum l")
    parser.add_argument("--info", action="store_true", help="Print info only")
    args = parser.parse_args()

    monomials = generate_monomials(2 * args.ell)
    n_outputs = (2 * args.ell + 1) ** 2

    if args.info:
        print(f"l={args.ell}:")
        print(f"  Degree: {2 * args.ell}")
        print(f"  Monomials: {len(monomials)}")
        print(f"  Outputs: {n_outputs} ({2*args.ell+1}x{2*args.ell+1})")
        print(f"  Operations per quaternion: {len(monomials) * n_outputs}")
        return

    print(generate_kernel(args.ell))


if __name__ == "__main__":
    main()
